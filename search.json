[{"title":"1. 简介","url":"/1-introduction.html","content":"本文档提供关于 OpenCore 用户配置文件的信息，以使 macOS 操作系统正常工作。你应当视本文档为 OpenCore 预期行为的解释。如果在已经发布的 OpenCore 版本中找到与文档中的描述存在偏差的行为，应当视为 OpenCore 存在 Bug 或文档出现错误，应通过 Acidanthera Bugtracker 进行反馈。 本文档仅作为规范结构、并非用于提供手把手的配置教程。本文档的目标受众是程序员、工程师、有对 macOS 内部和 UEFI 有足够了解的人。因此本文档只提供英文版本，任何通过其他来源分发的文档和文档翻译都是非官方的，并且可能存在错误。 译者注： 此处以及之后的「本文档」都指代 OpenCore 的官方文档（而非你现在访问的网站）。 你应当使用英语在 Acidanthera Bugtracker 进行反馈。 对于大部分用户来说，第三方提供的教程、工具可能更易于使用、受众更广。但是这类材料（译者注：即由第三方提供的，如「手把手的配置教程」）都容易收到其作者的喜好和品位、对本文档的误解、过时的理解等。如果您正在使用这些资料来源，例如 OpenCore Desktop Guide（及其 父页面）或者「OpenCore 非官方简体中文翻译」，请务必在参考本文档后再作出每个决定、并判断其后果。 在通过 Acidanthera Bugtracker 反馈任何问题之前，请确保你彻底理解了 OpenCore 的每个配置选项及其对应的概念。 1.1 通用术语 plist — 是一种用 XML 编写的、储存 ASCII 属性列表格式的集合文件，又称 XML 1.0 版。 统一类型标识符（UTI）： com.apple.property-list。 plist 由多个 plist object 组成，这些对象组合在一起形成一种具有层次的结构。 由于 plist 格式的定义不明确，因此本文中的所有定义只有在运行 plutil -lint 有效后才能被应用。外部参考： , man plutil。 plist type — 指 plist 集合（plist array, plist dictionary, plist key）和基本类型（plist string, plist data, plist date, plist boolean, plist integer, plist real）。 plist object — 是用来定义 plist type 的实现形式，可以理解为值。 plist array — 类数组集合，参数为 array。包含零个或多个 plist object。 plist dictionary — 类地图（关联数组）集合，参数为 dict 。包含零个或多个 plist key。 plist key — 包含一个以 plist key 名称命名的 plist object，参数为 key。由 7 位 ASCII 集的可打印字符组成。 plist string — 7 位 ASCII 集的可打印字符串，参数为 string。 plist data — base64 编码的对象，参数为 data。 plist date — ISO-8601 日期表示法，参数为 date，不支持。 plist boolean — 逻辑声明对象，其值为 true (1) 或 false (0)，参数为 true 和 false。 plist integer — 带符号的 10 进制，参数为 integer。适用于以二进制补码表示的 64 位无符号整数，除非在特定的 plist object 描述中明确提及一个更小的、有或无符号的整数类型。 plist real — 浮点数，参数为 real，不支持。 plist metadata — 实现将 value 强制转换为 data。 允许传递 plist string，此时的结果用空结果字节序列（即 C 字符串）表示；允许传递 plist integer，此时的结果用二进制补码形式的 32 位小尾数字节序列表示；允许传递 plist boolean， 此时的值为一个字节：01 表示 true，00 表示 false；允许传递 plist data 本身。其他类型或更大的整数会导致未定义、非预期的行为。 "},{"title":"10. PlatformInfo","url":"/10-platform-info.html","content":"机型信息由手动生成、填充以与 macOS 服务兼容的几个标识字段组成。配置的基础部分可以从 AppleModels、一个可以从 YAML 格式的数据库中生成一组接口的工具包中获得。这些字段将会被写入三个位置： SMBIOS DataHub NVRAM 大多数字段在 SMBIOS 中指定覆盖，并且这些字段的名称符合 EDK2 SmBios.h 头文件。但是，在 Data Hub 和 NVRAM 中有几个重要的字段。有些值可以在多个字段 和/或 目标中找到，因此有两种方法可以控制它们的更新过程：手动指定所有值（默认方法）；半自动。 可以使用 dmidecode 工具来检查 SMBIOS 内容。你可以从 Acidanthera/dmidecode 下载 Acidanthera 制作的增强版。 10.1 Properties1. AutomaticType: plist booleanFailsafe: falseDescription: 基于 Generic 属性而不是 DataHub、NVRAM 和 SMBIOS 属性生成机型信息。 当 Generic 属性足够灵活的时候，这一选项将会变得非常有用： When enabled SMBIOS、DataHub、PlatformNVRAM is used. When disabled Generic is not used. 2. UpdateDataHubType: plist booleanFailsafe: falseDescription: 更新 Data Hub 字段。根据 Automatic 的值，这些字段会从 Generic 或 DataHub 中读取。 3. UpdateNVRAMType: plist booleanFailsafe: falseDescription: 是否更新 NVRAM 中关于机型信息的相关字段。 根据 Automatic 的值，这些字段会从 Generic 或 PlatformNVRAM 中读取。所有其他字段都将在 NVRAM 部分中指定。 如果将此值设置为 false，则可以使用 nvram 部分更新上述变量；反之若将此值设置为 true，而同时 nvram 部分存在任何字段，会产生意料之外的行为。 4. UpdateSMBIOSType: plist booleanFailsafe: falseDescription: 更新 SMBIOS 字段。根据 Automatic 的值，这些字段会从 Generic 或 SMBIOS 中读取。 5. UpdateSMBIOSModeType: plist stringFailsafe: CreateDescription: 更新 SMBIOS 字段的方式有： TryOverwrite — 如果新的数据大小 小于等于 按页对齐的原始数据，且对解锁 legacy region 没有影响，则选择 Overwrite 方式；否则选择 Create 方式。在某些硬件上可能会有问题。 Create — 在 AllocateMaxAddress 将表替换为新分配的 EfiReservedMemoryType，没有回退机制。 Overwrite — 如果数据大小合适则覆盖现有的 gEfiSmbiosTableGuid 和 gEfiSmbiosTable3Guid，否则将以不明状态中止。 Custom — 把第一个 SMBIOS 表（gEfiSmbios(3)TableGuid）写入 gOcCustomSmbios(3)TableGuid，以此来解决固件在 ExitBootServices 覆盖 SMBIOS 内容的问题；否则等同于 Create。需要 AppleSmbios.kext 和 AppleACPIPlatform.kext 打补丁来读取另一个 GUID: &quot;EB9D2D31&quot; - &quot;EB9D2D35&quot; (in ASCII)， 这一步由 CustomSMBIOSGuid quirk 自动完成。 注： 使用 Custom 有一个副作用（译者注：我怎么感觉是好事）使得 SMBIOS 设置只对 macOS 生效，避免了与现有的 Windows 激活和依赖机型的 OEM 设置的相关问题。不过，苹果在 Windows 下的特定工具（译者注：如 BootCamp for Windows）可能会受到影响 6. GenericType: plist dictonaryOptional: Automatic 为 false 时可不填Description: 更新所有字段。当 Automatic 激活时此处为只读。 7. DataHubType: plist dictonaryOptional: Automatic 为 true 时可不填Description: 更新 Data Hub 字段。当 Automatic 未激活时此处为只读。 8. PlatformNVRAMType: plist dictonaryOptional: Automatic 为 true 时可不填Description: 更新 platform NVRAM 字段。当 Automatic 未激活时此处为只读。 9. SMBIOSType: plist dictonaryOptional: Automatic 为 true 时可不填Description: 更新 SMBIOS 字段。当 Automatic 未激活时此处为只读。 10.2 Generic Properties1. SpoofVendorType: plist booleanFailsafe: falseDescription: 将 SMBIOS 中的 vendor 字段设置为 Acidanthera。 由于在 SystemManufacturer 相关介绍中介绍的原因，在 SMBIOS 的 vendor 字段中使用 Apple 是危险的。但是，某些固件可能无法提供有效值，可能会导致某些软件的破坏。 2. AdviseWindowsType: plist booleanFailsafe: falseDescription: 在 FirmwareFeatures 中强制提供 Windows 支持。 向 FirmwareFeatures 中添加如下比特： FW_FEATURE_SUPPORTS_CSM_LEGACY_MODE (0x1) - 如果没有此比特，且 EFI 分区不是硬盘中的第一个分区，那么则无法重新启动到硬盘里的 Windows 系统。 FW_FEATURE_SUPPORTS_UEFI_WINDOWS_BOOT (0x20000000) - 如果没有此比特，且 EFI 分区是硬盘中的第一个分区，那么则无法重新启动到硬盘里的 Windows 系统。 3. SystemProductNameType: plist stringFailsafe: MacPro6,1Description: 请参考下文 SMBIOS 章节中的 SystemProductName。 4. SystemSerialNumberType: plist stringFailsafe: OPENCORE_SN1Description: 请参考下文 SMBIOS 章节中的 SystemSerialNumber。 5. SystemUUIDType: plist string, GUIDFailsafe: OEM specifiedDescription: 请参考下文 SMBIOS 章节中的 SystemUUID。 6. MLBType: plist stringFailsafe: OPENCORE_MLB_SN11Description: 请参考下文 SMBIOS 章节中的 BoardSerialNumber。 7. ROMType: plist data, 6 bytesFailsafe: all zeroDescription: 参考 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ROM。 10.3 DataHub Properties1. PlatformNameType: plist stringFailsafe: Not installedDescription: 在 gEfiMiscSubClassGuid 中设置 name。在 Mac 上找到的值为 ASCII 码形式的 platform。 2. SystemProductNameType: plist stringFailsafe: Not installedDescription: 在 gEfiMiscSubClassGuid 中设置 Model。在 Mac 上找到的值等于 Unicode 形式的 SMBIOS SystemProductName。 3. SystemSerialNumberType: plist stringFailsafe: Not installedDescription: 在 gEfiMiscSubClassGuid 中设置 SystemSerialNumber。在 Mac 上找到的值等于 Unicode 形式的 SMBIOS SystemSerialNumber。 4. SystemUUIDType: plist string, GUIDFailsafe: Not installedDescription: 在 gEfiMiscSubClassGuid 中设置 system-id。在 Mac 上找到的值等于 SMBIOS SystemUUID。 5. BoardProductType: plist stringFailsafe: Not installedDescription: 在 gEfiMiscSubClassGuid 中设置 board-id。在 Mac 上找到的值等于 ASCII 码形式的 SMBIOS BoardProduct。 6. BoardRevisionType: plist data, 1 byteFailsafe: 0Description: 在 gEfiMiscSubClassGuid 中设置 board-rev。在 Mac 上找到的值似乎与 internal board revision 相对应（e.g. 01）。 7. StartupPowerEventsType: plist integer, 64-bitFailsafe: 0Description: 在 gEfiMiscSubClassGuid Sets 中设置 StartupPowerEvents。在 Mac 上找到的值是 power management state 位掩码，通常为 0。X86PlatformPlugin.kext 能读取的已知 bit 有： 0x00000001 — Shutdown cause was a PWROK event (Same as GEN_PMCON_2 bit 0) 0x00000002 — Shutdown cause was a SYS_PWROK event (Same as GEN_PMCON_2 bit 1) 0x00000004 — Shutdown cause was a THRMTRIP#event (Same as GEN_PMCON_2 bit 3) 0x00000008 — Rebooted due to a SYS_RESET# event (Same as GEN_PMCON_2 bit 4) 0x00000010 — Power Failure (Same as GEN_PMCON_3 bit 1 PWR_FLR) 0x00000020 — Loss of RTC Well Power (Same as GEN_PMCON_3 bit 2 RTC_PWR_STS) 0x00000040 — General Reset Status (Same as GEN_PMCON_3 bit 9 GEN_RST_STS) 0xffffff80 — SUS Well Power Loss (Same as GEN_PMCON_3 bit 14) 0x00010000 — Wake cause was a ME Wake event (Same as PRSTS bit 0, ME_WAKE_STS) 0x00020000 — Cold Reboot was ME Induced event (Same as PRSTS bit 1 ME_HRST_COLD_STS) 0x00040000 — Warm Reboot was ME Induced event (Same as PRSTS bit 2 ME_HRST_WARM_STS) 0x00080000 — Shutdown was ME Induced event (Same as PRSTS bit 3 ME_HOST_PWRDN) 0x00100000 — Global reset ME Wachdog Timer event (Same as PRSTS bit 6) 0x00200000 — Global reset PowerManagment Wachdog Timer event (Same as PRSTS bit 15) 8. InitialTSCType: plist integer, 64-bitFailsafe: 0Description: 在 gEfiProcessorSubClassGuid 中设置 InitialTSC。设置初始 TSC 值，通常为 0。 9. FSBFrequencyType: plist integer, 64-bitFailsafe: AutomaticDescription: 在 gEfiProcessorSubClassGuid 中设置 FSBFrequency。 设置 CPU FSB 频率。此值等于 CPU 主频除以最高总线比率，以 Hz 为单位。请参考 MSR_NEHALEM_PLATFORM_INFO(CEh) MSR 值来确定 Intel CPU 的最高总线比率。 注：此值虽然不是用于 Skylake 或更新的平台，但也可设置。 10. ARTFrequencyType: plist integer, 64-bitFailsafe: AutomaticDescription: 在 gEfiProcessorSubClassGuid 中设置 ARTFrequency。 此值包含 CPU ART 频率，即晶体时钟频率。为 Skylake 或更新的平台独有，以 Hz 为单位。Client Intel segment 通常为 24 MHz，Server Intel segment 通常为 25 MHz，Intel Atom CPUs 通常为 19.2 MHz。macOS 10.15 及以下均默认为 24 MHz。 注：由于 Intel Skylake X 平台特有 EMI-reduction 电路，其 ART 频率可能会比 24 或 25 MHz 有所损失（大约 0.25%）。参考 Acidanthera Bugtracker。 11. DevicePathsSupportedType: plist integer, 32-bitFailsafe: Not installedDescription: 在 gEfiMiscSubClassGuid 中设置 DevicePathsSupported。必须设置为 1 才能确保 AppleACPIPlatform.kext 将 SATA 设备路径添加到 Boot#### 和 efi-boot-device-data 变量。所有新款 Mac 都设置为 1。 12. SmcRevisionType: plist data, 6 bytesFailsafe: Not installedDescription: 在 gEfiMiscSubClassGuid 中设置 REV。自定义属性由 VirtualSMC 或 FakeSMC 读取，用于生成 SMC REV key。 13. SmcBranchType: plist data, 8 bytesFailsafe: Not installedDescription: 在 gEfiMiscSubClassGuid 中设置 RBr。自定义属性由 VirtualSMC 或 FakeSMC 读取，用于生成 SMC RBr key。 14. SmcPlatformType: plist data, 8 bytesFailsafe: Not installedDescription: 在 gEfiMiscSubClassGuid 中设置 RPlt。自定义属性由 VirtualSMC 或 FakeSMC 读取，用于生成 SMC RPlt key。 10.4 PlatformNVRAM Properties1. BIDType: plist stringFailsafe: Not installedDescription: 指定 NVRAM 变量 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_BID。 2. ROMType: plist data, 6 bytesFailsafe: Not installedDescription: 指定 NVRAM 变量 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_ROM 和 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ROM。 3. MLBType: plist stringFailsafe: Not installedDescription: 指定 NVRAM 变量 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_MLB 和 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:MLB。 4. FirmwareFeaturesType: plist data, 8 bytesFailsafe: Not installedDescription: 此变量与 FirmwareFeaturesMask 配对使用。指定 NVRAM 变量： 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:FirmwareFeatures 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ExtendedFirmwareFeatures 5. FirmwareFeaturesMaskType: plist data, 8 bytesFailsafe: Not installedDescription: 此变量与 FirmwareFeatures 配对使用。指定 NVRAM 变量： 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:FirmwareFeaturesMask 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ExtendedFirmwareFeaturesMask 10.5 SMBIOS Properties1. BIOSVendorType: plist stringFailsafe: OEM specifiedSMBIOS: BIOS Information (Type 0) — VendorDescription: BIOS 供应商。SystemManufacturer 的所有规则都适用。 2. BIOSVersionType: plist stringFailsafe: OEM specifiedSMBIOS: BIOS Information (Type 0) — BIOS VersionDescription: 固件版本。此值更新时会同时影响更新推送配置文件以及 macOS 版本的兼容性。在较旧的固件中看起来类似于 MM71.88Z.0234.B00.1809171422，并且在 BiosId.h 中有所描述。在较新的固件中看起来类似于 236.0.0.0.0 或 220.230.16.0.0 (iBridge: 16.16.2542.0.0,0)。 iBridge 版本是从 BridgeOSVersion 变量中读取的，并且只在具有 T2 芯片的 Mac 上有显示。 3. BIOSReleaseDateType: plist stringFailsafe: OEM specifiedSMBIOS: BIOS Information (Type 0) — BIOS Release DateDescription: 固件发布日期。与 BIOSVersion 类似，看起来像是 12/08/2017 这种格式。 4. SystemManufacturerType: plist stringFailsafe: OEM specifiedSMBIOS: System Information (Type 1) — ManufacturerDescription: 特定主板的 OEM 制造商。除非特别需要，否则最好不要设定，也不要包含 Apple Inc. 字样，这样做会混淆操作系统中的大量服务，例如固件更新、eficheck 以及 Acidanthera 开发的内核扩展（如 Lilu 及其插件）。此外还可能导致某些操作系统（如 Linux）无法引导。 5. SystemProductNameType: plist stringFailsafe: OEM specifiedSMBIOS: System Information (Type 1), Product NameDescription: 选择偏好的 Mac 机型来把设备标记为系统支持的机型。在任何配置中都应指定该值，以便之后自动生成 SMBIOS 表的相关值和相关配置参数。如果 SystemProductName 与目标操作系统不兼容，可用引导参数 -no_compat_check 来覆盖。 注：如果 SystemProductName 位置，并且相关字段也未指定，默认值会被设定为 MacPro6,1。目前已知产品的列表详见 MacInfoPkg。 6. SystemVersionType: plist stringFailsafe: OEM specifiedSMBIOS: System Information (Type 1) — VersionDescription: 产品迭代版本号。可能与 1.1 类似。 7. SystemSerialNumberType: plist stringFailsafe: OEM specifiedSMBIOS: System Information (Type 1) — Serial NumberDescription: 按照格式定义的产品序列号。已知的序列号的格式在 macserial 中可以找到。 8. SystemUUIDType: plist string, GUIDFailsafe: OEM specifiedSMBIOS: System Information (Type 1) — UUIDDescription: UUID 被设计为在时间和空间上都是唯一的标识符，其生成是随机与去中心化的。 9. SystemSKUNumberType: plist stringFailsafe: OEM specifiedSMBIOS: System Information (Type 1) — SKU NumberDescription: Mac 主板 ID (board-id)。在旧型号的机器中看起来类似于 Mac-7BA5B2D9E42DDD94 或 Mac-F221BEC8。有时可以直接留空。 10. SystemFamilyType: plist stringFailsafe: OEM specifiedSMBIOS: System Information (Type 1) — FamilyDescription: 系列名称，看起来类似于 iMac Pro。 11. BoardManufacturerType: plist stringFailsafe: OEM specifiedSMBIOS: Baseboard (or Module) Information (Type 2) - ManufacturerDescription: 主板制造商。SystemManufacturer 的所有规则都适用。 12. BoardProductType: plist stringFailsafe: OEM specifiedSMBIOS: Baseboard (or Module) Information (Type 2) - ProductDescription: Mac 主板 ID (board-id)。在旧型号机器中看起来类似于 Mac-7BA5B2D9E42DDD94 或 Mac-F221BEC8。 13. BoardVersionType: plist stringFailsafe: OEM specifiedSMBIOS: Baseboard (or Module) Information (Type 2) - VersionDescription: 主板版本号。有各种各样，可能与 SystemProductName 或 SystemProductVersion 匹配。 14. BoardSerialNumberType: plist stringFailsafe: OEM specifiedSMBIOS: Baseboard (or Module) Information (Type 2) — Serial NumberDescription: 主板序列号，有对应的格式，具体格式见 macserial 的描述。 15. BoardAssetTagType: plist stringFailsafe: OEM specifiedSMBIOS: Baseboard (or Module) Information (Type 2) — Asset TagDescription: 资产标签号。有各种各样，可以留空或填 Type2 - Board Asset Tag。 16. BoardTypeType: plist integerFailsafe: OEM specifiedSMBIOS: Baseboard (or Module) Information (Type 2) — Board TypeDescription: 0xA (Motherboard (includes processor, memory, and I/O) 或 0xB (Processor/Memory Module)，详见 Table 15 – Baseboard: Board Type for more details。 17. BoardLocationInChassisType: plist stringFailsafe: OEM specifiedSMBIOS: Baseboard (or Module) Information (Type 2) — Location in ChassisDescription: 各种各样，可以留空或填 Part Component。 18. ChassisManufacturerType: plist stringFailsafe: OEM specifiedSMBIOS: System Enclosure or Chassis (Type 3) — ManufacturerDescription: 主板制造商。SystemManufacturer 的所有规则都适用。 19. ChassisTypeType: plist integerFailsafe: OEM specifiedSMBIOS: System Enclosure or Chassis (Type 3) — TypeDescription: 机箱类型，详见 Table 17 — System Enclosure or Chassis Types。 20. ChassisVersionType: plist stringFailsafe: OEM specifiedSMBIOS: System Enclosure or Chassis (Type 3) — VersionDescription: 应和 BoardProduct 符合。 21. ChassisSerialNumberType: plist stringFailsafe: OEM specifiedSMBIOS: System Enclosure or Chassis (Type 3) — VersionDescription: 应和 SystemSerialNumber 符合。 22. ChassisAssetTagType: plist stringFailsafe: OEM specifiedSMBIOS: System Enclosure or Chassis (Type 3) — Asset Tag NumberDescription: 机箱类型名称。有各种各样，可以留空或填 MacBook-Aluminum。 23. PlatformFeatureType: plist integer, 32-bitFailsafe: 0xFFFFFFFFSMBIOS: APPLE_SMBIOS_TABLE_TYPE133 - PlatformFeatureDescription: 平台功能位掩码，详见 AppleFeatures.h。填写 0xFFFFFFFF 值时不提供此表。 24. SmcVersionType: plist data, 16 bytesFailsafe: All zeroSMBIOS: APPLE_SMBIOS_TABLE_TYPE134 - VersionDescription: ASCII 字符串，包含 SMC 版本号（大写）。在基于 T2 芯片的 Mac 设备上缺少这一字段。当此值设置为零时，这一选项会被忽略。 25. FirmwareFeaturesType: plist data, 8 bytesFailsafe: 0SMBIOS: APPLE_SMBIOS_TABLE_TYPE128 - FirmwareFeatures and ExtendedFirmwareFeaturesDescription: 64 位固件功能位掩码。详见 AppleFeatures.h。低 32 位与 FirmwareFeatures 匹配，高 64 位与 ExtendedFirmwareFeatures 匹配。 26.FirmwareFeaturesMaskType: plist data, 8 bytesFailsafe: 0SMBIOS: APPLE_SMBIOS_TABLE_TYPE128 - FirmwareFeaturesMask and ExtendedFirmwareFeaturesMaskDescription: 扩展固件功能位掩码。详见 AppleFeatures.h。低 32 位与 FirmwareFeatures 匹配，高 64 位与 ExtendedFirmwareFeatures 匹配。 27. ProcessorTypeType: plist integer, 16-bitFailsafe: AutomaticSMBIOS: APPLE_SMBIOS_TABLE_TYPE131 - ProcessorTypeDescription: 由处理器的主要和次要类型组成。 28. MemoryFormFactorType: plist integer, 8-bitFailsafe: OEM specifiedSMBIOS: Memory Device (Type 17) — Form FactorDescription: Memory Form Factor。在 Mac 上应为 DIMM 或 SODIMM。"},{"title":"11. UEFI","url":"/11-uefi.html","content":"11.1 IntroductionUEFI（统一可扩展固件接口）是一种规范，用于定义操作系统和平台固件之间的软件接口。本部分允许加载其他 UEFI 模块 和/或 对板载固件进行调整。要检查固件内容，应用修改并执行升级，可以使用 UEFITool 和其他实用程序。 11.2 Drivers根据固件不同、可能需要不同的驱动程序。加载不兼容的驱动程序可能会导致无法启动系统，甚至导致固件永久性损坏。OpenCore 目前对以下 UEFI 驱动提供支持。OpenCore 可能兼容对其他 UEFI 驱动，但不能确定。 CrScreenshotDxe — 截图驱动。启用后，按下 F10 将能够截图并保存在 EFI 分区根目录下。该驱动基于 Nikolaj Schlej 修改的 LongSoft 开发的 CrScreenshotDxe。 OpenRuntime — （原名 FwRuntimeServices.efi）OC_FIRMWARE_RUNTIME 协议通过支持只读、只写 NVRAM 变量，提升了 OpenCore 和 Lilu 的安全性。有些 Quirks 如 RequestBootVarRouting 依赖此驱动程序。由于 runtime 驱动的性质（与目标操作系统并行运行），因此它不能在 OpenCore 本身实现，而是与 OpenCore 捆绑在一起。 HiiDatabase — 来自 MdeModulePkg 的 HII 服务驱动。Ivy Bridge 及其以后的大多数固件中都已内置此驱动程序。某些带有 GUI 的应用程序（例如 UEFI Shell）可能需要此驱动程序才能正常工作。 EnhancedFatDxe — 来自 FatPkg 的 FAT 文件系统驱动程序。这个驱动程序已经被嵌入到所有 UEFI 固件中，无法为 OpenCore 使用。众所周知，许多固件的 FAT 支持实现都有错误，导致在尝试写操作时损坏文件系统。如果在引导过程中需要写入 EFI 分区，则可能组要将此驱动程序嵌入固件中。 NvmExpressDxe — 来自MdeModulePkg 的 NVMe 驱动程序。从 Broadwell 一代开始的大多数固件都包含此驱动程序。对于 Haswell 以及更早的版本，如果安装了 NVMe SSD 驱动器，则将其嵌入固件中可能会更理想。 OpenUsbKbDxe — USB 键盘驱动在自定义 USB 键盘驱动程序的基础上新增了对 AppleKeyMapAggregator 协议的支持。这是内置的 KeySupport 的等效替代方案。根据固件不同，效果可能会更好或者更糟。 HfsPlus - Apple 固件中常见的具有 Bless 支持的专有 HFS 文件系统驱动程序。对于 Sandy Bridge 和更早的 CPU，由于这些 CPU 缺少 RDRAND 指令支持，应使用 HfsPlusLegacy 驱动程序。 VBoxHfs — 带有 bless 支持的 HFS 文件系统驱动。是 Apple 固件中 HfsPlus 驱动的开源替代。虽然功能完善，但是启动速度比 HFSPlus 慢三倍，并且尚未经过安全审核。 XhciDxe — 来自 MdeModulePkg 的 XHCI USB controller 驱动程序。从 Sandy Bridge 代开始的大多数固件中都包含此驱动程序。在较早的固件或旧系统可以用于支持外部 USB 3.0 PCI 卡。 AudioDxe — UEFI 固件中的 HDA 音频驱动程序，适用于大多数 Intel 和其他一些模拟音频控制器。Refer to acidanthera/bugtracker#740 for known issues in AudioDxe. ExFatDxe — 用于 Bootcamp 支持的专有 ExFAT 文件系统驱动程序，通常可以在 Apple 固件中找到。 对于 Sandy Bridge 和更早的 CPU，由于缺少 RDRAND 指令支持，应使用 ExFatDxeLegacy 驱动程序。 Ps2KeyboardDxe — 从 MdeModulePkg 提取出来的 PS/2 键盘驱动。OpenDuetPkg 和一些固件可能不包括这个驱动，但对于 PS/2 键盘来说该驱动是必须的。注：和 OpenUsbKbDxe 不同，该驱动不提供对 AppleKeyMapAggregator 的支持、因此需要启用 KeySupport 这个 Quirk。 Ps2MouseDxe — 从 MdeModulePkg 提取出来的 PS/2 鼠标驱动。该固件，虽然只有非常老旧的笔记本的固件中可能没有不包含该驱动，但是笔记本依赖该驱动才能在引导界面使用触控板。 PartitionDxe — 一个专门的分区管理驱动程序，用于加载旧版 macOS 的 DMG 映像（如 macOS 10.9 的分区映像）。对于 Sandy Bridge 或者更早的 CPU，由于缺少 RDRAND 指令支持，应使用 PartitionDxeLegacy 驱动程序。 UsbMouseDxe — 从 MdeModulePkg 提取出来的 USB 鼠标驱动。该固件，一般只有虚拟机（如 OVMF）的固件中可能没有不包含该驱动，但是这些虚拟机依赖该驱动才能在引导界面使用鼠标。 要从 UDK（EDK II）编译驱动程序，可以使用编译 OpenCore 类似的命令。 11.3 Tools一些不依赖 OpenCore 的工具可以帮助调试固件和硬件。下面列出了一些已知的工具。虽然有些工具可以从 OpenCore 启动，但大部分工具都应该直接或从 OpenCoreShell 中单独运行。 要启动到 OpenShell 或任何其他工具，直接将 OpenShell.efi 保存在 FAT32 分区中的 EFI/BOOT/BOOTX64.EFI 下。此时分区方案是 GPT 还是 MBR 并不重要。虽然这种方法可以在 Mac 和其他计算机上都可以使用，但是如果只在 Mac 上使用的话还可以在 HFS+ 或 APFS 分区上使用该工具。 Note 1: You may have to copy /System/Library/CoreServices/BridgeVersion.bin to /Volumes/VOLNAME/DIR.Note 2: To be able to use bless you may have to disable System Integrity Protection.Note 3: To be able to boot you may have to disable Secure Boot if present. 一些已知的 UEFI 工具： BootKicker (内置) - 进入 Apple 的 BootPicker 菜单（仅 Mac 同款显卡才可以使用）。 ChipTune (内置) - 测试 BeepGen 协议，生成不同频率和长度的音频信号。 CleanNvram (内置) - 重置 NVRAM，以一个单独的工具呈现。 FwProtect (内置) - 解锁和回锁 NVRAM 保护，让其他工具在从 OpenCore 启动时能够获得完整的 NVRAM 访问权限。 GopStop (内置) - 用一个 简单的场景 测试 GraphicOutput 协议。 HdaCodecDump (内置) - 解析和转储高清晰度音频编解码器（Codec）信息（需要 AudioDxe）。 KeyTester (内置) - 在 SimpleText 模式下测试键盘输入。 OpenCore Shell (内置) - 由 OpenCore 配置的 UEFI Shell，与绝大部分固件兼容。 RtcRw - Utility to read and write RTC (CMOS) memory. PavpProvision - Perform EPID provisioning (requires certificate data configuration). ResetSystem - Utility to perform system reset. Takes reset type as an argument: ColdReset, WarmReset, Shutdown. Default to ColdReset. VerifyMsrE2 (内置) - 检查 CFG Lock（MSR 0xE2 写保护）在所有 CPU 核心之间的一致性。 11.4 OpenCanopyOpenCanopy 是一个 OpenCore 的图形化界面接口，基于 OpenCorePkg OcBootManagementLib 实现，提供与现有的文字模式类似的功能。当 PickerMode 设置为 External 时启用。 OpenCanopy 所需的图象资源位于 Resources 目录下，一些简单的资源（字体和图标）可以在 OcBinaryData 仓库 中获取。字体为 12pt 的 Helvetica，比例缩放。 Font format corresponds to AngelCode binary BMF. While there are many utilities to generate font files, currently it is recommended to use dpFontBaker to generate bitmap font (using CoreText produces best results) and fonverter to export it to binary format. Note: OpenCanopy 是一个试验性质的功能、不应用于日常使用。你可以在 acidanthera/bugtracker#759 获取相关的详细信息。 11.5 OpenRuntimeOpenRuntime 是一个 OpenCore 的插件，提供了对 OC_FIRMWARE_RUNTIME 协议的实现。该协议对 OpenCore 的部分功能提供了支持，而这部分功能由于需要 Runtime（如操作系统）中运行、因此无法内置在 OpenCore 中。该协议提供了包括但不限于如下功能： NVRAM namespaces, allowing to isolate operating systems from accessing select variables (e.g. RequestBootVarRouting or ProtectSecureBoot). Read-only and write-only NVRAM variables, enhancing the security of OpenCore, Lilu, and Lilu plugins, like VirtualSMC, which implements AuthRestart support. NVRAM isolation, allowing to protect all variables from being written from an untrusted operating system (e.g. DisableVariableWrite). UEFI Runtime Services memory protection management to workaround read-only mapping (e.g. EnableWriteUnprotector). 11.6 PropertiesAPFSType: plist dictFailsafe: NoneDescription: 配置 APFS 分区驱动，具体配置内容参见下文 APFS Properties 部分。 AudioType: plist dictFailsafe: NoneDescription: 配置音频后端支持，具体配置如下文所述。 Audio support provides a way for upstream protocols to interact with the selected hardware and audio resources. All audio resources should reside in \\EFI\\OC\\Resources\\Audio directory. Currently the only supported audio file format is WAVE PCM. While it is driver-dependent which audio stream format is supported, most common audio cards support 16-bit signed stereo audio at 44100 or 48000 Hz. Audio file path is determined by audio type, audio localisation, and audio path. Each filename looks as follows: [audio type]_[audio localisation]_[audio path].wav. For unlocalised files filename does not include the language code and looks as follows: [audio type]_[audio path].wav. Audio type can be OCEFIAudio for OpenCore audio files or AXEFIAudio for macOS bootloader audio files. Audio localisation is a two letter language code (e.g. en) with an exception for Chinese, Spanish, and Portuguese. Refer to APPLE_VOICE_OVER_LANGUAGE_CODE definition for the list of all supported localisations. Audio path is the base filename corresponding to a file identifier. For macOS bootloader audio paths refer to APPLE_VOICE_OVER_AUDIO_FILE definition. For OpenCore audio paths refer to OC_VOICE_OVER_AUDIO_FILE definition. The only exception is OpenCore boot chime file, which is OCEFIAudio_VoiceOver_Boot.wav. Audio localisation is determined separately for macOS bootloader and OpenCore. For macOS bootloader it is set in preferences.efires archive in systemLanguage.utf8 file and is controlled by the operating system. For OpenCore the value of prev-lang:kbd variable is used. When native audio localisation of a particular file is missing, English language (en) localisation is used. Sample audio files can be found in OcBinaryData repository. ConnectDriversType: plist booleanFailsafe: falseDescription: 驱动程序加载后执行 UEFI 控制器连接操作。 此选项对于加载某些遵循 UEFI 驱动模型的 驱动程序（如文件系统驱动、音频输出驱动）很有用，因为这些驱动可能无法自行启动。此选项对会自动连接的驱动程序来说是不必要的，并且可能会稍微减慢启动速度。 注：某些固件（特别是 Apple 的）仅连接包含操作系统的驱动器以加快启动过程。启用此选项可以在拥有多个驱动器时查看所有引导选项。 DriversType: plist arrayFailsafe: NoneDescription: 从 OC/Drivers 目录下加载选择的驱动。 设计为填充 UEFI 驱动程序加载的文件名。 InputType: plist dictFailsafe: NoneDescription: Apply individual settings designed for input (keyboard and mouse) in Input Properties section below. OutputType: plist dictFailsafe: NoneDescription: Apply individual settings designed for output (text and graphics) in Output Properties section below. ProtocolOverridesType: plist dictFailsafe: NoneDescription: Force builtin versions of select protocols described in ProtocolOverrides Properties section below. 注：all protocol instances are installed prior to driver loading. QuirksType: plist dictFailsafe: NoneDescription: Apply individual firmware quirks described in Quirks Properties section below. ReservedMemoryType: plist arrayDescription: Designed to be filled with plist dict values, describing memory areas exquisite to particular firmware and hardware functioning, which should not be used by the operating system. An example of such memory region could be second 256 MB corrupted by Intel HD 3000 or an area with faulty RAM. 11.7 APFS PropertiesEnableJumpstartType: plist booleanFailsafe: FalseDescription: 从一个 APFS 容器中加载 APFS 驱动。 APFS 的 EFI 驱动内置在所有可以作为系统启动盘的 APFS 容器之中。这一选项将会根据基于 ScanPolicy 找到的 APFS 容器，从中加载 APFS 驱动。更多详情请查看 苹果 APFS 文件系统参考手册 中的 EFI Jummpstart 章节。 HideVerboseType: plist booleanFailsafe: FalseDescription: 是否隐藏 APFS 驱动的 verbose 信息。 APFS 驱动的 verbose 信息有助于 debug。 JumpstartHotPlugType: plist booleanFailsafe: FalseDescription: 允许从进入 OpenCore 引导菜单后插入的可移除硬盘上的 APFS 容器中加载 APFS 驱动。 这一选项不仅提供了进入 OpenCore 以后再插入 U 盘的支持，而且还允许了在 OpenCore 引导菜单下 APFS U 盘的热插拔。 MinDateType: plist integerFailsafe: 0Description: 允许加载的最老 APFS 驱动的发布日期 APFS 驱动的版本号基于其发布日期。较旧版本的 APFS 驱动可能与较新的系统不兼容、或者有未修补的漏洞。通过这一选项可以避免 OpenCore 加载过旧版本的 APFS 驱动。 0 - 使用默认数值。OpenCore 会随着未来更新，内置的默认数值也会不断更新。如果你会一直更新你的系统，我们推荐使用这一数值。目前默认数值为 2018/06/21。 -1 - 允许使用任何版本的 APFS 驱动（强烈不推荐）。 其他数值 - 数值格式应为形如 20200401 的格式。你可以从 OpenCore 的启动日志和 OcApfsLib 中找到 APFS 驱动的版本号。 MinVersionType: plist integerFailsafe: 0Description: 允许加载的最老 APFS 驱动的版本号 APFS 驱动的版本号和 macOS 版本相关。较旧版本的 APFS 驱动可能与较新的系统不兼容、或者有未修补的漏洞。通过这一选项可以避免 OpenCore 加载过旧版本的 APFS 驱动。 0 - 使用默认数值。OpenCore 会随着未来更新，内置的默认数值也会不断更新。如果你会一直更新你的系统，我们推荐使用这一数值。目前默认数值选自 App Store 中能够下载到的 High Sierra（748077008000000）。 -1 - 允许使用任何版本的 APFS 驱动（强烈不推荐）。 其他数值 - 数值格式应为形如 1412101001000000 的格式（这是 macOS Catalina 10.15.4 的 APFS 驱动版本号）你可以从 OpenCore 的启动日志和 OcApfsLib 中找到 APFS 驱动的版本号。 11.8 Audio PropertiesAudioCodecType: plist integerFailsafe: 0Description: Codec address on the specified audio controller for audio support. Normally this contains first audio codec address on the builtin analog audio controller (HDEF). Audio codec addresses, e.g. 2, can be found in the debug log (marked in bold): OCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(&lt;redacted&gt;,00000000) (4 outputs)OCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(&lt;redacted&gt;,00000000) (1 outputs)OCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(&lt;redacted&gt;,02000000) (7 outputs) As an alternative this value can be obtained from IOHDACodecDevice class in I/O Registry containing it in IOHDACodecAddress field. AudioDeviceType: plist stringFailsafe: empty stringDescription: Device path of the specified audio controller for audio support. Normally this contains builtin analog audio controller (HDEF) device path, e.g. PciRoot(0x0)/Pci(0x1b,0x0). The list of recognised audio controllers can be found in the debug log (marked in bold): OCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(&lt;redacted&gt;,00000000) (4 outputs)OCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(&lt;redacted&gt;,00000000) (1 outputs)OCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(&lt;redacted&gt;,02000000) (7 outputs) As an alternative gfxutil -f HDEF command can be used in macOS. Specifying empty device path will result in the first available audio controller to be used. AudioOutType: plist integerFailsafe: 0Description: Index of the output port of the specified codec starting from 0. Normally this contains the index of the green out of the builtin analog audio controller (HDEF). The number of output nodes in the debug log (marked in bold): OCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(&lt;redacted&gt;,00000000) (4 outputs)OCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(&lt;redacted&gt;,00000000) (1 outputs)OCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(&lt;redacted&gt;,02000000) (7 outputs) The quickest way to find the right port is to bruteforce the values from 0 to N - 1. AudioSupportType: plist booleanFailsafe: falseDescription: 通过连接到固件音频驱动程序以激活音频支持。 Enabling this setting routes audio playback from builtin protocols to a dedicated audio port (AudioOut) of the specified codec (AudioCodec) located on the audio controller (AudioDevice). MinimumVolumeType: plist integerFailsafe: 0Description: Minimal heard volume level from 0 to 100. Screen reader will use this volume level, when the calculated volume level is less than MinimumVolume. Boot chime sound will not play if the calculated volume level is less than MinimumVolume. PlayChimeType: plist booleanFailsafe: falseDescription: 开机时播放 Mac 特有的风铃的声音。 Enabling this setting plays boot chime through builtin audio support. Volume level is determined by MinimumVolume and VolumeAmplifier settings and SystemAudioVolume NVRAM variable. Note: this setting is separate from StartupMute NVRAM variable to avoid conflicts when the firmware is able to play boot chime. VolumeAmplifierType: plist integerFailsafe: 0Description: Multiplication coefficient for system volume to raw volume linear translation from 0 to 1000. Volume level range read from SystemAudioVolume varies depending on the codec. To transform read value in [0, 127] range into raw volume range[0, 100] the read value is scaled to VolumeAmplifier percents: Note: the transformation used in macOS is not linear, but it is very close and this nuance is thus ignored. 11.9 Input PropertiesKeyFilteringType: plist booleanFailsafe: falseDescription: Enable keyboard input sanity checking. Apparently some boards like GA Z77P-D3 may return uninitialised data in EFI_INPUT_KEY with all input protocols. This option discards keys that are neither ASCII, nor are defined in the UEFI specification (see tables 107 and 108 in version 2.8). KeyForgetThresholdType: plist integerFailsafe: 0Description: 两次按键之间的间隔时间，单位为毫秒。 AppleKeyMapAggregator 协议应该包含当前按下的键的固定长度的缓冲。但是大部分驱动程序仅将按键按下报告为中断、并且按住按键会导致在一定的时间间隔后再提交按下行为。一旦超时到期，我们就是用超时从缓冲区中删除一次按下的键，并且没有新提交。 此选项允许根据你的平台设置此超时。在大多数平台上有效的推荐值为 5 毫秒。作为参考，在 VMWare 上按住一个键大约每 2 毫秒就会重复一次，而在 APTIO V 上是 3 - 4 毫秒。因此，可以在较快的平台上设置稍低的值、在较慢的平台设置稍高的值，以提高响应速度。 KeyMergeThresholdType: plist integerFailsafe: 0Description: 按住按键被重置的间隔时间，单位为毫秒。 与 KeyForgetThreshold 类似，这一选项适用于按键提交的顺序。为了能够识别同时按下的按键，我们需要设置一个超时时间，在这个时间内可以假定这两个按键是同时按下的。 对于 VMWare，同时按下多个键的间隔是 2 毫秒。对于 APTIO V 平台为 1 毫毛。一个接一个地按下按键会导致 6 毫秒和 10 毫秒的延迟。此选项的建议值为 2 毫秒，但对于较快的平台可以选取较小的值，反之亦然。 KeySupportType: plist booleanFailsafe: falseDescription: 启用这一选项后将会开启内置键盘支持。 这一选项基于 AppleGenericInput（AptioInputFix），激活内部键盘拦截器驱动程序以填充 AppleKeyMapAggregator 数据库以实现输入功能。如果使用了单独的驱动程序（如 AppleUsbKbDxe），则永远不要开启这一选项。 KeySupportModeType: plist stringFailsafe: empty stringDescription: 将内部键盘的输入转换设置为 AppleKeyMapAggregator 协议模式。 Auto — 从下述选项中自动选择 V1 — UEFI 传统输入协议 EFI_SIMPLE_TEXT_INPUT_PROTOCOL. V2 — UEFI 现代标准输入协议 EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL. AMI — APTIO 输入协议 AMI_EFIKEYCODE_PROTOCOL. Note: Currently V1, V2, and AMI unlike Auto only do filtering of the particular specified protocol. This may change in the future versions. KeySwapType: plist booleanFailsafe: falseDescription: 启用后将交换 Command 和 Option。 此选项对于 Option 键位于 Command 右侧的键盘来说会很有用。 PointerSupportType: plist booleanFailsafe: falseDescription: 启用后将试图修复 UEFI 选择器协议。 该选项通过选择 OEM 协议实现标准 UEFI 指针协议 EFI_SIMPLE_POINTER_PROTOCOL。该选项在 Z87 华硕主板可能有用（该主板的 EFI_SIMPLE_POINTER_PROTOCOL 存在问题）。 PointerSupportModeType: plist stringFailsafe: empty stringDescription: 设置用于内部指针驱动程序的 OEM 协议。 目前只支持 ASUS 值，使用的是 Z87 和 Z97主板上的特殊协议。更多详情请参考 LongSoft/UefiTool#116。 TimerResolutionType: plist integerFailsafe: 0Description: 固件始终刷新的频率（单位 100 纳秒） 设置较低的值可以提高界面和输入处理性能的响应能力。建议值为 50000（即 5 毫秒）或稍高一些。选择 ASUS Z87 主板时，请使用 60000，苹果主板请使用 100000。你也可以将此值保留为 0，由 OpenCore 自动计算。 11.10 Output PropertiesTextRendererType: plist stringFailsafe: BuiltinGraphicsDescription: 选择通过标准控制台输出的渲染器。 Currently two renderers are supported: Builtin and System. System renderer uses firmware services for text rendering. Builtin bypassing firmware services and performs text rendering on its own. Different renderers support a different set of options. It is recommended to use Builtin renderer, as it supports HiDPI mode and uses full screen resolution. UEFI firmwares generally support ConsoleControl with two rendering modes: Graphics and Text. Some firmwares do not support ConsoleControl and rendering modes. OpenCore and macOS expect text to only be shown in Graphics mode and graphics to be drawn in any mode. Since this is not required by UEFI specification, exact behaviour varies. Valid values are combinations of text renderer and rendering mode: BuiltinGraphics — Switch to Graphics mode and use Builtin renderer with custom ConsoleControl. SystemGraphics — Switch to Graphics mode and use System renderer with custom ConsoleControl. SystemText — Switch to Text mode and use System renderer with custom ConsoleControl. SystemGeneric — Use System renderer with system ConsoleControl assuming it behaves correctly. The use of BuiltinGraphics is generally straightforward. For most platforms it is necessary to enable ProvideConsoleGop, set Resolution to Max. The use of System protocols is more complicated. In general the preferred setting is SystemGraphics or SystemText. Enabling ProvideConsoleGop, setting Resolution to Max, enabling ReplaceTabWithSpace is useful on almost all platforms. SanitiseClearScreen, IgnoreTextInGraphics, and ClearScreenOnModeSwitch are more specific, and their use depends on the firmware. 注：Some Macs, namely MacPro5,1, may have broken console output with newer GPUs, and thus only BuiltinGraphics may work for them. ConsoleModeType: plist stringFailsafe: Empty stringDescription: Sets console output mode as specified with the WxH (e.g. 80x24) formatted string. Set to empty string not to change console mode. Set to Max to try to use largest available console mode. Currently Builtin text renderer supports only one console mode, so this option is ignored. 注：This field is best to be left empty on most firmwares. ResolutionType: plist stringFailsafe: Empty stringDescription: 设置控制台的屏幕分辨率。 Set to WxH@Bpp (e.g. 1920x1080@32) or WxH (e.g. 1920x1080) formatted string to request custom resolution from GOP if available. Set to empty string not to change screen resolution. Set to Max to try to use largest available screen resolution. On HiDPI screens APPLE_VENDOR_VARIABLE_GUID UIScale NVRAM variable may need to be set to 02 to enable HiDPI scaling in in Builtin text renderer, FileVault 2 UEFI password interface, FileVault 2 UEFI password interface and boot screen logo. Refer to Recommended Variables section for more details. 注：This will fail when console handle has no GOP protocol. When the firmware does not provide it, it can be added with ProvideConsoleGop set to true. ClearScreenOnModeSwitchType: plist booleanFailsafe: falseDescription: 有些固件在从图形模式切换到文本模式时，只会清除部分屏幕、而会留下一部分之前绘制的图像。启用这一选项后，在切换到文本模式之前会用黑色填充整个图形屏幕。 注：这一选项只会在 System 渲染器上生效。 DirectGopRenderingType: plist booleanFailsafe: falseDescription: Use builtin graphics output protocol renderer for console. On some firmwares this may provide better performance or even fix rendering issues, like on MacPro5,1. However it is recommended not to use this option unless there is an obvious benefit as it may even result in slower scrolling. IgnoreTextInGraphicsType: plist booleanFailsafe: falseDescription: Select firmwares output text onscreen in both graphics and text mode. This is normally unexpected, because random text may appear over graphical images and cause UI corruption. Setting this option to true will discard all text output when console control is in mode different from Text. 注：This option only applies to System renderer. ReplaceTabWithSpaceType: plist booleanFailsafe: falseDescription: Some firmwares do not print tab characters or even everything that follows them, causing difficulties or inability to use the UEFI Shell builtin text editor to edit property lists and other documents. This option makes the console output spaces instead of tabs. 注：This option only applies to System renderer. ProvideConsoleGopType: plist booleanFailsafe: falseDescription: Ensure GOP (Graphics Output Protocol) on console handle. macOS bootloader requires GOP to be present on console handle, yet the exact location of GOP is not covered by the UEFI specification. This option will ensure GOP is installed on console handle if it is present. 注：This option will also replace broken GOP protocol on console handle, which may be the case on MacPro5,1 with newer GPUs. ReconnectOnResChangeType: plist booleanFailsafe: falseDescription: Reconnect console controllers after changing screen resolution. On some firmwares when screen resolution is changed via GOP, it is required to reconnect the controllers, which produce the console protocols (simple text out). Otherwise they will not produce text based on the new resolution. 注：On several boards this logic may result in black screen when launching OpenCore from Shell and thus it is optional. In versions prior to 0.5.2 this option was mandatory and not configurable. Please do not use this unless required. SanitiseClearScreenType: plist booleanFailsafe: falseDescription: Some firmwares reset screen resolution to a failsafe value (like 1024x768) on the attempts to clear screen contents when large display (e.g. 2K or 4K) is used. This option attempts to apply a workaround. 注：This option only applies to System renderer. On all known affected systems ConsoleMode had to be set to empty string for this to work. 11.11 Protocols PropertiesAppleAudioType: plist booleanFailsafe: falseDescription: Reinstalls Apple audio protocols with builtin versions. Apple audio protocols allow macOS bootloader and OpenCore to play sounds and signals for screen reading or audible error reporting. Supportedprotocols are beep generation and VoiceOver. VoiceOver protocol is specific to Gibraltar machines (T2) and is not supported before macOS High Sierra (10.13). Instead older macOS versions use AppleHDA protocol, which is currently not implemented. Only one set of audio protocols can be available at a time, so in order to get audio playback in OpenCore user interface on Mac system implementing some of these protocols this setting should be enabled. Note: Backend audio driver needs to be configured in UEFI Audio section for these protocols to be able to stream audio. AppleBootPolicyType: plist booleanFailsafe: falseDescription: 重新安装内置的 Apple Boot Policy 协议，可用于确保 VM 或旧版 Mac 设备上的 APFS 兼容性。 注：某些 Mac 设备（如 MacPro5,1）虽然兼容 APFS，但是其 Apple Boot Policy 协议包含了恢复分区检测问题，因此也建议启用这一选项。 AppleDebugLogType: plist booleanFailsafe: falseDescription: 重新安装内置的 Apple 调试日志输出协议。 AppleEventType: plist booleanFailsafe: falseDescription: 重新安装内置的 Apple Event 协议，可以确保在 VM 或旧版 Mac 设备上的 Faile Vault V2 兼容性。 AppleImageConversionType: plist booleanFailsafe: falseDescription: 重新安装内置的 Apple Image Conservation 协议。 AppleKeyMapType: plist booleanFailsafe: falseDescription: 重新安装内置的 Apple Key Map 协议。 AppleRtcRamType: plist booleanFailsafe: falseDescription: 重新安装内置的 Apple RTC RAM 协议。 注：内置的 Apple RTC RAM 协议可能会过滤掉 RTC 内存地址的潜在 I/O。地址列表可以在 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:rtc-blacklist 中以数组的方式指定。 AppleSmcIoType: plist booleanFailsafe: falseDescription: 重新安装内置的 SMC I/O 协议。 这一协议代替了传统的 VirtualSmc.efi，并与所有 SMC kext 驱动兼容。如果你在用 FakeSMC，可能需要手动往 NVRAM 中添加键值对。 AppleUserInterfaceThemeType: plist booleanFailsafe: falseDescription: 重新安装内置的 Apple User Interface Theme 协议。 DataHubType: plist booleanFailsafe: falseDescription: 重新安装具有内置版本的 Data Hub 协议。如果已经安装了协议，这将删除所有先前的属性。 DevicePropertiesType: plist booleanFailsafe: falseDescription: 重新安装内置版本的 Device Property 协议。 如果已经安装，它将删除所有以前的属性。这一选项可用于确保在 VM 或旧版 Mac 设备上的兼容性。 FirmwareVolumeType: plist booleanFailsafe: falseDescription: 强制包装固件卷协议或安装新版本以支持 File Vault 2 的自定义光标图像。建议启用这一选项以确保 File Vault 2 在除 VM 和传统 Mac 设备之外的兼容性。 注：包括 VMWare 在内的多个虚拟机在 HiDPI 模式下光标会损坏，因此建议为所有虚拟机启用这一选项。 HashServicesType: plist booleanFailsafe: falseDescription: 强制重新安装内置版本的 Hash Services 协议。为了在 SHA-1 哈希协议不完整的固件上确保 File Vault 2 的兼容性，这一 Quirk 应设置为 true。对于大多数固件来说，你可以通过将 UIScale 设置为 02 查看是否会出现禁行图标，来诊断你的固件是否需要这一 Quirk。一般来说，APTIO V（Haswell 和更早的平台）之前的平台都会受到影响。 OSInfoType: plist booleanFailsafe: falseDescription: 强制使用内置版本重新安装 OS Info 协议。该协议通常用于通过固件或其他应用程序从 macOS 引导加载程序接收通知。 UnicodeCollationType: plist booleanFailsafe: falseDescription: 强制重新安装内置版本的 Unicode Collation 服务。建议启用这一选项以确保 UEFI Shell 的兼容性。一些较旧的固件破坏了 Unicode 排序规则, 启用后可以修复这些系统上 UEFI Shell 的兼容性 (通常为用于 IvyBridge 或更旧的设备) 11.12 QuirksDeduplicateBootOrderType: plist booleanFailsafe: falseDescription: Remove duplicate entries in BootOrder variable in EFI_GLOBAL_VARIABLE_GUID. This quirk requires RequestBootVarRouting to be enabled and therefore OC_FIRMWARE_RUNTIME protocol implemented in OpenRuntime.efi. By redirecting Boot prefixed variables to a separate GUID namespace with the help of RequestBootVarRouting quirk we achieve multiple goals: Operating systems are jailed and only controlled by OpenCore boot environment to enhance security. Operating systems do not mess with OpenCore boot priority, and guarantee fluent updates and hibernation wakes for cases that require reboots with OpenCore in the middle. Potentially incompatible boot entries, such as macOS entries, are not deleted or anyhow corrupted. However, some firmwares do their own boot option scanning upon startup by checking file presence on the available disks. Quite often this scanning includes non-standard locations, such as Windows Bootloader paths. Normally it is not an issue, but some firmwares, ASUS firmwares on APTIO V in particular, have bugs. For them scanning is implemented improperly, and firmware preferences may get accidentally corrupted due to BootOrder entry duplication (each option will be added twice) making it impossible to boot without cleaning NVRAM. To trigger the bug one should have some valid boot options (e.g. OpenCore) and then install Windows with RequestBootVarRouting enabled. As Windows bootloader option will not be created by Windows installer, the firmware will attempt to create it itself, and then corrupt its boot option list. This quirk removes all duplicates in BootOrder variable attempting to resolve the consequences of the bugs upon OpenCore loading. It is recommended to use this key along with BootProtect option. ExitBootServicesDelayType: plist integerFailsafe: 0Description: 在 EXIT_BOOT_SERVICES 事件后添加延迟，单位为毫秒。 这是一个非常丑陋的 Quirks，用于修复 Still waiting for root device 提示信息。在使用 FileVault 2 时，特别是华硕 Z87-Pro 等 APTIO IV 固件这种错误经常发生。似乎因为某种原因，FileVault 与 EXIT_BOOT_SERVICES 同时执行、导致 macOS 无法访问 SATA 控制器。未来应该会找到一个更好的方法。如果需要启用这一选项，设置 3-5 秒的延时就可以了。 IgnoreInvalidFlexRatioType: plist booleanFailsafe: falseDescription: Select firmwares, namely APTIO IV, may contain invalid values in MSR_FLEX_RATIO (0x194) MSR register. These values may cause macOS boot failure on Intel platforms. 注：While the option is not supposed to induce harm on unaffected firmwares, its usage is not recommended when it is not required. ReleaseUsbOwnershipType: plist booleanFailsafe: falseDescription: 尝试从固件驱动程序中分离 USB 控制器所有权。尽管大多数固件都设法正确执行了该操作或者提供有一个选项，但某些固件没有，从而导致操作系统可能会在启动时冻结。除非需要，否则不建议启用这一选项。 RequestBootVarRoutingType: plist booleanFailsafe: falseDescription: 请求将所有带有 Boot 前缀的变量从 EFI_GLOBAL_VARIABLE_GUID 重定向到 OC_VENDOR_VARIABLE_GUID。 This quirk requires OC_FIRMWARE_RUNTIME protocol implemented in OpenRuntime.efi（原名 FwRuntimeServices.efi）. 当固件删除不兼容的启动条目时，这一 Quirk 可以让默认的启动条目保存在引导菜单中。简单地说就是，如果你想使用「系统偏好设置」中的「启动磁盘」，就必须启用这一 Quirk。 TscSyncTimeoutType: plist integerFailsafe: 0Description: Attempts to perform TSC synchronisation with a specified timeout. The primary purpose of this quirk is to enable early bootstrap TSC synchronisation on some server and laptop models when running a debug XNU kernel. For the debug kernel the TSC needs to be kept in sync across the cores before any kext could kick in rendering all other solutions problematic. The timeout is specified in microseconds and depends on the amount of cores present on the platform, the recommended starting value is 500000. This is an experimental quirk, which should only be used for the aforementioned problem. In all other cases the quirk may render the operating system unstable and is not recommended. The recommended solution in the other cases is to install a kernel driver like VoodooTSCSync, TSCAdjustReset or CpuTscSync (a more specialised variant of VoodooTSCSync for newer laptops). Note: The reason this quirk cannot replace the kernel driver is because it cannot operate in ACPI S3 mode (sleep wake) and because the UEFI firmwares provide very limited multicore support preventing the precise update of the MSR registers. UnblockFsConnectType: plist booleanFailsafe: falseDescription: 某些固件通过「按驱动程序」模式下来阻止引导项加载。 注：如果惠普笔记本在 OpenCore 界面没有看到引导项时启用这一选项。 11.13 ReservedMemory PropertiesAddressType: plist integerFailsafe: 0Description: Start address of the reserved memory region, which should be allocated as reserved effectively marking the memory of this type inaccessible to the operating system. The addresses written here must be part of the memory map, have EfiConventionalMemory type, and page-aligned (4 KBs). CommentType: plist stringFailsafe: Empty stringDescription: Arbitrary ASCII string used to provide human readable reference for the entry. It is implementation defined whether this value is used. SizeType: plist integerFailsafe: 0Description: Size of the reserved memory region, must be page-aligned (4 KBs). EnabledType: plist booleanFailsafe: falseDescription: This region will not be reserved unless set to true."},{"title":"12. 排错","url":"/12-troubleshooting.html","content":"12.1 Windows 支持我能安装 Windows 系统吗？虽然 OpenCore 并没有提供官方的 Windows 支持，但是使用 Boot Camp 安装 64 位 UEFI Windows（即 Windows 8 及更高版本）应该是可以正常工作的。安装第三方 UEFI、或者仅部分支持 UEFI 引导的系统（如 Windows 7）可能需要额外注意。不论如何，记住以下几点： MBR (Master Boot Record) 属于 Legacy 引导，因此将不会被支持。 在 OpenCore 上应用的所有更改（ACPI、NVRAM、SMBIOS）都应该与操作系统本身无关。OpenCore 会将这些改动生效于所有操作系统，这样在 Windows 上可以获得 Boot Camp 的体验。 macOS 要求硬盘中的第一份分区为 EFI 分区，并且与 Windows 的默认布局不支持。尽管 OpenCore 确实提供了一个 解决方法，但是强烈建议不要依赖这个方法。 Windows 系统可能需要重新激活。为了避免这种情况发生，请考虑将 SystemUUID 设置为原始固件的 UUID。请注意，在旧固件上 UUID 可能是无效的（非随机的）。如果你还遇到了什么问题，可以考虑使用 HWID 或 KMS38 的 Windows 许可证。从 OpenCore 0.5.8 开始，你还可以通过设置 UpdateSMBIOSMode 为 Custom 来避免 OEM 激活失效。Windows 激活的细节不在本文档的讨论范围内，你应该能够在网上查找到相关资料。 我需要安装其他什么软件吗？在大多数情况下，要启用多操作系统切换、安装相关驱动程序，你将需要 Boot Camp 提供的 Windows 支持软件。为了简化下载过程、或者配置硬盘中已经安装好的 Windows，可以使用 Brigadier 这个实用软件。请注意在使用 Brigadier 之前，你可能需要先下载并安装 7-Zip。 译者注：7-zip 官方中文网站 记住，一定要使用最新版本的 Boot Camp 的 Windows 支持软件。6.1 之前的版本不支持 APFS 文件系统、因此无法运行。要下载最新的软件，请将最新 Mac 的型号作为参数传递给 Brigadier，如 ./brigadier.exe -m iMac19,1。之后，在不受支持的 Mac 型号上安装 Boot Camp，请以管理员身份运行 PowerShell，输入 msiexec /i BootCamp.msi 即可。如果你之前不小心已经安装了旧版本的 Boot Camp，则必须先通过运行 msiexec /x BootCamp.msi 将其卸载。BootCamp.msi 文件位于 BootCamp/Drivers/Apple 目录中、可以通过资源管理器访问。 译者注：在资源管理器下，按住 Shift 同时右击窗口中空白处，此时菜单中会显示「在此处运行 PowerShell」，即在当前目录下运行 PowerShell。但是这种方式启动的 PowerShell 不具备管理员权限。 尽管 Boot Camp 提供的 Windows 支持软件解决了大多数兼容性问题，但是有时候您还是需要手动解决一些问题： 要反转鼠标滚轮的滚动方向，必须按照 这个网站 提供的方法、设置 FlipFlopWheel 的值为 1。 译者注：涉及到的注册表是 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\HID\\VID_???\\VID_???\\Device Parameters.你可以在 PowerShell 中执行下述命令进行设置； 如果需要撤销更改，可以使用下述命令： RealTimeIsUniversal 必须设置为 1 以避免 Windows 和 macOS 之间的时间不同步。 译者注：众所周知，Windows 将硬件时间视为本地时间，而 macOS 会计算 UTC 后当做系统时间。通过修改上述提到的注册表值，可以让 Windows 将硬件时间视为 UTC 时间。用到的 CMD 命令如下所示： 如果要访问 Apple 的文件系统（APFS、HFS），你可能需要安装单独的软件。已知的工具有 Apple HFS+ driver (hack for Windows 10)、HFSExplorer、MacDrive、Paragon APFS、Paragon HFS+、TransMac，等等。 译者注：切记不要在 Windows 下写入 APFS 或 HFS，十有八九你会导致分区表错误和无法恢复的数据丢失。别怪我们没有警告过你！！ 为什么我会在 Boot Camp 启动硬盘 控制面板 中看到 Basic data partition？Boot Camp 使用 GPT 分区表获取每个引导选项的名称。独立安装 Windows 后，你必须手动重新标记分区。这可以通过许多工具完成，比如开源的 gdisk，使用方法如下： Listing 3: Relabeling Windows volume 如何选择 NTFS 驱动程序提供 NTFS 读写支持的第三方驱动程序，如 NTFS-3G、Paragon NTFS、Tuxera NTFS 或 希捷移动硬盘 Paragon 驱动程序 会破坏 macOS 的功能，比如 系统偏好设置 中的 启动磁盘 选项。虽然我们仍然不建议使用这些经常破坏文件系统的驱动程序（我们推荐使用 macOS 内建的 NTFS 读写支持，可以通过终端或 GUI 启用），但是这些驱动程序的厂商也提供了他们各自的解决方案，在这里我们仅列举两个： Tuxera 的常见问题解答页面 Paragon 相关的技术支持文档 译者注：虽然 acidanthera 团队推荐使用 macOS 内置的 NTFS 支持，但是译者强烈反对这种方法（不论是直接方法还是使用类似 Mounty 的第三方工具）。修改 fstab 的风险是极高的。在你清楚你在做什么之前，不要轻举妄动！！ 12.2 调试与其他硬件相关的项目类似，OpenCore 也支持审计与调试。使用 NOOPT 或 DEBUG 构建版本（而非 RELEASE 构建版本）可以产生更多的调试输出。对于 NOOPT 构建版本，你还可以使用 GDB 或 IDA Pro 进行调试。对于 GDB 请查看 OpenCore Debug 相关页面；对于 IDA Pro，你需要 7.3 或更高版本，更多详细信息请参考 IDA Pro 提供的页面：Debugging the XNU Kernel with IDA Pro。 To obtain the log during boot you can make the use of serial port debugging. Serial port debugging is enabled in Target, e.g. 0xB for onscreen with serial. OpenCore uses 115200 baud rate, 8 data bits, no parity, and 1 stop bit. For macOS your best choice are CP2102-based UART devices. Connect motherboard TX to USB UART RX, and motherboard GND to USB UART GND. Use screen utility to get the output, or download GUI software, such as CoolTerm. 注释: On several motherboards (and possibly USB UART dongles) PIN naming may be incorrect. It is very common to have GND swapped with RX, thus you have to connect motherboard &quot;TX&quot; to USB UART GND, and motherboard &quot;GND&quot; to USB UART RX. Remember to enable COM port in firmware settings, and never use USB cables longer than 1 meter to avoid output corruption. To additionally enable XNU kernel serial output you will need debug=0x8 boot argument. 12.3 技巧和窍门1. 啊呀呀呀我系统没法启动了我该怎么看日志啊？通常情况下，获取实际的错误信息就足够了。为此，请确保： 你正在使用 OpenCore 的 DEBUG 或 NOOPT 版本。 日志已启用（1）并且在屏幕上显示（2）：Misc =&gt; Debug =&gt; Target = 3. 将以下这些等级的日志输出到屏幕上：DEBUG_ERROR (0x80000000)、DEBUG_WARN (0x00000002) 和 DEBUG_INFO (0x00000040)：Misc =&gt; Debug =&gt; DisplayLevel = 0x80000042. 遇到 DEBUG_ERROR 这样的致命错误时中止启动：Misc =&gt; Security =&gt; HaltLevel = 0x80000000。 禁用 Watch Dog 以避免自动重启：Misc =&gt; Debug =&gt; DisableWatchDog = true。 已启用 启动菜单 显示：Misc =&gt; Boot =&gt; ShowPicker = true 如果你在日志中看不出明显的错误，请逐一检查 Quirks 部分中可用的 hacks。例如，对于 Early Boot 出现的问题（如 OpenCore 启动菜单无法显示），通过 UEFI Shell（随 OpenCore 打包在一起）可以查看相关调试信息。 2. 如何自定义启动项？OpenCore 遵循 Apple Bless 标准模型、从引导目录中的 .contentDetails 和 .disk_label.contentDetails 文件中提取条目名称。这些文件包含带有输入标题的 ASCII 字符串，你可以修改它们。 3. 如何选择默认启动的系统？OpenCore 使用 UEFI 首选启动项 来选择默认的启动项。设置的方式随 BIOS 不同而不同，具体请参考 macOS 启动磁盘 或 Windows Boot Camp 控制面板。 由于使用 OpenCore 提供的 BOOTx64.efi 作为首选启动项会限制这项功能（可能还会导致一些固件删除不兼容的引导选项），我们强烈建议你启用 RequestBootVarRouting quirk，这会将你所做的选择保留在 OpenCore 变量空间中。请注意，RequestBootVarRouting 需要单独的 .efi 驱动文件（译者注：即 OpenRuntime.efi）。 4. 安装 macOS 最简单的方法是什么？在线安装。将 Recovery 镜像（*.dmg 和 *.chunklist 文件）和 OpenCore 一起复制到一个 FAT32 分区中。加载 OpenCore 的启动菜单并选择后缀为 .dmg 的条目。如果你有强迫症，你可以修改 .contentDetails 文件改变条目显示的文字。 你可能会用到 AppleModels 内置的 macrecovery.py 来下载 Recovery 镜像。 如果你需要进行离线安装，请参考 How to create a bootable installer for macOS。除了通过 App Store 或 系统更新，你还可以使用 第三方工具 下载 macOS 镜像文件。 5. 为什么无法加载 Recovery 恢复镜像 进行在线安装？可能是因为你没带 HFS+ 驱动。目前我们所知道的 Recovery 分区全都是 HFS+ 文件系统。 6. 我可以在 Apple 的硬件、或虚拟机中使用 OpenCore 吗？可以，没有必要，但请加大力度 OpenCore 支持包括 MacPro 5,1 和虚拟机在内的大部分较新的 Mac 想好。不过，OpenCore有关在 Mac 硬件上使用的具体细节微乎其微。你可以在 MacRumors.com 查看相关讨论。 7. 为什么 Find 和 Replace 的补丁的长度必须相等？对于 x86 机器码来说，相对寻址 无法进行大小不同的替换。对于 ACPI 代码来说这是有风险的，而且在技术上这与替换 ACPI 表等价，所以 OpenCore 没有实现。更多详细的解答可以在 AppleLife.ru 上和本文档的 ACPI 章节找到。 8. 我应该如何决定哪些 Booter Quirk 需要被启用？这些 Quirk 源自 AptioMemoryFix 驱动，为更多的固件提供了广泛支持。如果你正在使用 OpenRuntime，并且想要获得和 AptioMemoryFix 类似的行为，请启用下述 Quirks： ProvideConsoleGop （UEFI Quirk） AvoidRuntimeDefrag DiscardHibernateMap EnableSafeModeSlide EnableWriteUnprotector ForceExitBootServices ProtectMemoryRegions ProvideCustomSlide RebuildAppleMemoryMap SetupVirtualMap 但是，对于大部分现代的设备来说，上述 Quirks 不一定是必须的。比如 DevirtualiseMmio 和 ProtectUefiServices 通常是需要启用的，但是 DiscardHibernateMap 和 ForceExitBootServices 一般不建议启用。 不幸的是，对于某些 Quirks 来说（RebuildAppleMemoryMap, EnableWriteUnprotector, ProtectMemoryRegions, RebuildAppleMemoryMap, SetupVirtualMap 和 SyncRuntimePermissions）由于没有明确的参考，因此需要自行尝试最佳组合。详细内容请参考本文档中对这些 Quirks 的描述。"},{"title":"2. 配置","url":"/2-configuration.html","content":"2.1 配置术语 OC config — OpenCore 的配置文件，格式为 plist，文件名为 config.plist。OpenCore 的配置文件具有可扩展性，并被设计为具有多个命名空间的结构。每个命名空间下允许具有 plist array 或 plist dictionary，在本文档相应部分中对其进行了描述 valid key — OC Config 中的 plist key object。除了明确描述的 valid key 以外，以 # 符号开头的值（如 #Hello）也将被视为 valid key，并被表示为注释。虽然表示为注释的值会被丢弃，但是它们仍然是 valid key。其他的 plist key 都是无效、不合法的，它们的存在可能会导致未定义、非预期的行为。 valid value — 有效、合法的 plist object，并能匹配一些特定的 plist object 描述中所有附加条件（若有）。 invalid value — 指 plist object 本身是有效、合法的，但属于其他 plist type、与特定 plist object 描述中附加条件不符（例如 value range）或者在对应集合中缺如。invalid value 会被不确定的方式读取为这个 plist obejct 的任何可能值（即，重启前后的值可能会不同），可能报错也可能不报错。尽管读取 invalid value 相当于读取某些已定义的 valid value，但是将不兼容的值应用于主机系统可能会产生未定义、非预期的行为。 optional value — 可缺少，或以特定 plist object 描述提供的特定方式（区别于 invalid value）读取的有效值。而其他情况下（译者注：未提供读取方式）的 invalid value 仍然会被应用。value 除非被明确标记为 optional value，否则必须存在，如果缺少则会被读取为 invalid value。 fatal behaviour — 导致引导终止的行为。对 fatal behaviour 的实现，要求必须停止引导过程，直到下一次主机系统引导为止。允许，但不强制要求执行冷重启或显示任何警告消息。 undefined behaviour — 本文档中未定义的行为，通常是因为某一选项的特定配置、或某些值被忽略导致的。在这种情况下，其实现可能会采取包括 fatal behaviour，而这些行为一般都会对系统安全性产生负面影响。 译者注：以上术语的相关描述仅限于本文档所指的 OC Config。 2.2 配置处理如果 OpenCore 发现了 OC Config，则至少会读取并处理一次。根据 OpenCore 的引导机制的不同，如果存在多个 OC Config 文件，OpenCore 可能会读取其中任何一个或数个。如果硬盘中没有 OC Config，OpenCore 将会使用可选值和无效值的规则。 OC Config 有大小、嵌套和键值数量的限制。OC Config 的大小不得超过 16 MB，嵌套层数不得超过 8 层，每个 plist object 中最多有 16384 个节点（一个 plist dictionary 将被计为一对节点）。不符合上述规则的 OC Config 文件将可能导致未定义、非预期的行为。常见的 OC Config 错误格式包括： 不符合 plist DTD 存在本文档中没有记载的 plist object 违反文件大小、嵌套层级和键值数量的限制 我们建议（但非强制）遇到格式错误的 OC Config 时不停止加载、然后继续进行就好像 OC Config 不存在一样。为了是先前向兼容性，建议（但非强制）要求实现对采用无效值的行为进行警告。采用无效值的建议做法是在使用的情况下遵守以下规则： Type Value plist string Empty string (&lt;string&gt;&lt;/string&gt;) plist data Empty data (&lt;data&gt;&lt;/data&gt;) plist integer 0 (&lt;integer&gt;0&lt;/integer&gt;) plist boolean False (&lt;false/&gt;) plist tristate False (&lt;false/&gt;) 2.3 配置结构OC Config 包括以下几个独立部分，将在本文档中分别进行介绍。默认情况下配置文件将尽可能不启用任何功能以及禁用某些功能。总的来说，这些配置一般由如下的操作构成： Add：为数据提供 添加 操作支持。已经存在的值不会被覆盖，必要时请使用 Delete。 Delete：为数据提供 删除 操作支持 Patch：为数据提供 补丁 操作支持 Quirks：提供特定的黑科技支持 配置文件分为以下几个独立部分： ACPI Booter DeviceProperties Kernel Misc NVRAM PlatformInfo UEFI 译者注：对上述部分的介绍位于文档的第 4 至 11 章节。可以在本网站左侧边栏中的目录中找到这些章节的入口。 你可以使用 ConfigValidity 实用工具校验配置文件是否存在语法错误。请注意，ConfigValidity 的版本必须和 OpenCore 的版本一致，而且不一定能够检测出所有的错误。 注意：为了保险起见，目前大多数属性都有默认值（译者注：后续文档中以 FailSafe 字段呈现）。如果在配置项中未指定任何值，默认值将会生效。不要依赖默认值，务必在配置中正确指定所有字段。"},{"title":"3. Setup","url":"/3-setup.html","content":"3.1 目录结构 使用目录引导时，使用的目录结构应该遵循上述目录结构。可用的条目有： BOOTx64.efi 和 Bootstrap.efi - 初始引导程序。除非 OpenCore.efi 已作为驱动程序启动，否则将用于加载 OpenCore.efi。对于大部分固件来说，BOOTx64.efi 是 UEFI 默认启动项，而 Bootstrap.efi 可以被注册为自定义启动项，避免 BOOTx64.efi 被其它操作系统所覆盖。 boot - Duet bootstrap loader，用于在传统 BIOS 固件上模拟 UEFI 环境、并加载 OpenCore.efi。 ACPI - 用于存储 ACPI 补充信息的目录。 Drivers - 用于存储 UEFI 补充驱动程序的目录。 Kexts - 用于存储内核驱动（kext）补充的目录。 Tools - 用于存储补充工具的目录。 OpenCore.efi - 主引导驱动程序，负责操作系统加载。 vault.plist - OC Config 可能加载的所有文件的哈希。 config.plist - OC Config（即 OpenCore 的配置文件，见「配置术语」）。这一目录同时也用于存放 GUI 界面所使用的图片，见 OpenCanopy 相关章节。 vault.sig - vault.plist 的签名文件。 nvram.plist - OpenCore 变量导入文件。 Resources - 媒体资源使用的目录，如 屏幕朗读 的语音文件（见「UEFI Audio 属性」章节）。 SysReport - 存放 SysReport 功能产生的系统错误报告。 opencore-YYYY-MM-DD-HHMMSS.txt - OpenCore 日志文件。 panic-YYYY-MM-DD-HHMMSS.txt - Kernal Panic 日志文件。 注: 受限于固件的实现行为，OpenCore 可能无法访问绝对路径长度大于 OC_STORAGE_SAFE_PATH_MAX（默认值为 128）的目录。 3.2 安装和升级如果要安装 OpenCore，请在使用 GPT 格式的硬盘上、按照上一节的文件夹结构建立文件和文件夹。尽管本文档的相应部分的确提供了有关你所需的外部资源（如 ACPI 表、UEFI 驱动程序或 kexts）的某些信息，但是本文档不保证会提供关于这些外部资源的全部信息。关于 kext 的完整信息可以查看由 OpenCore 提供的 可选 kext 列表；而本文档也在安全属性的相关章节提供了 Vauting 的相关信息。 OpenCore 的配置文件可以使用任何常规的文本编辑器（如 nano、vim、VSCode）进行编辑，但是专用软件可以带来更好的体验。在 macOS 上我们推荐使用 Xcode。你也可以使用 ProperTree ，这是一个轻量级的跨平台的开源 plist 编辑器。 如果要通过 BIOS 进行开机，你必须使用第三方 UEFI 环境提供程序。OpenDuetPkg 是一个常用的为旧操作系统提供 Legacy 引导的 UEFI 环境提供程序。要在这样的旧操作系统上运行 OpenCore，你可以使用一个独立的工具 BootInstall 安装 OpenDuetPkg（目前已和 OpenCore 打包在一起发布）。 如果要升级 OpenCore，Differences.pdf 提供了 OpenCore 配置文件变更的相关信息，Changelog.md 提供了 OpenCore 的更新日志。 译者注：以下两节是为准备参与 OpenCore 开发的人员准备的。 3.3 贡献代码OpenCore can be compiled as an ordinary EDK II. Since UDK development was abandoned by TianoCore, OpenCore requires the use of EDK II Stable. Currently supported EDK II release is hosted in acidanthera/audk. The required patches for the package are present in Patches directory. The only officially supported toolchain is XCODE5. Other toolchains might work, but are neither supported, nor recommended. Contribution of clean patches is welcome. Please do follow EDK II C Codestyle. To compile with XCODE5, besides Xcode, one should also install NASM and MTOC. The latest Xcode version is recommended for use despite the toolchain name. Examplecommand sequence may look as follows: For IDE usage Xcode projects are available in the root of the repositories. Another approach could be Sublime Text with EasyClangComplete plugin. Add .clang_complete file with similar content to your UDK root: Warning: Tool developers modifying config.plist or any other OpenCore files must ensure that their tool checks for opencore-version NVRAM variable (see Debug Properties section below) and warn the user if the version listed is unsupported or prerelease. OpenCore configuration may change across the releases and the tool shall ensure that it carefully follows this document. Failure to do so may result in this tool to be considered as malware and blocked with all possible means. 3.4 代码约定Just like any other project we have conventions that we follow during the development. All third-party contributors are highly recommended to read and follow the conventions listed below before submitting their patches. In general it is also recommended to firstly discuss the issue in Acidanthera Bugtracker before sending the patch to ensure no double work and to avoid your patch being rejected. Organisation. The codebase is contained in OpenCorePkg repo. which is the primary EDK II package. Whenever changes are required in multiple repositories, separate pull requests should be sent to each. Committing the changes should happen firstly to dependent repositories, secondly to primary repositories to avoid automatic build errors. Each unique commit should compile with XCODE5 and preferably with other toolchains. In the majority of the cases it can be checked by accessing the CI interface. Ensuring that static analysis finds no warnings is preferred. External pull requests and tagged commits must be validated. That said, commits in master may build but may not necessarily work. Internal branches should be named as follows: author-name-date, e.g. vit9696-ballooning-20191026. Commit messages should be prefixed with the primary module (e.g. library or code module) the changes were made in. For example, OcGuardLib: Add OC_ALIGNED macro. For non-library changes Docs or Build prefixes are used. Design. The codebase is written in a subset of freestanding C11 (C17) supported by most modern toolchains used by EDK II. Applying common software development practices or requesting clarification is recommended if any particular case is not discussed below. Never rely on undefined behaviour and try to avoid implementation defined behaviour unless explicitly covered below (feel free to create an issue when a relevant case is not present). Use OcGuardLib to ensure safe integral arithmetics avoiding overflows. Unsigned wraparound should be relied on with care and reduced to the necessary amount. Check pointers for correct alignment with OcGuardLib and do not rely on the architecture being able to dereference unaligned pointers. Use flexible array members instead of zero-length or one-length arrays where necessary. Use static assertions (STATIC_ASSERT) for type and value assumptions, and runtime assertions (ASSERT) for precondition and invariant sanity checking. Do not use runtime assertions to check for errors as they should never alter control flow and potentially be excluded. Assume UINT32/INT32 to be int-sized and use %u, %d, and %x to print them. Assume UINTN/INTN to be of unspecified size, and cast them to UINT64/INT64 for printing with %Lu, %Ld and so on as normal. Do not rely on integer promotions for numeric literals. Use explicit casts when the type isimplementation-dependent or suffixes when type size is known. Assume U for UINT32 and ULL for UINT64. Do ensure unsigned arithmetics especially in bitwise maths, shifts in particular. sizeof operator should take variables instead of types where possible to be error prone. Use ARRAY_SIZE to obtain array size in elements. Use L_STR_LEN and L_STR_SIZE macros from OcStringLib to obtain string literal sizes to ensure compiler optimisation. Do not use goto keyword. Prefer early return, break, or continue after failing to pass error checking instead of nesting conditionals. Use EFIAPI, force UEFI calling convention, only in protocols, external callbacks between modules, and functions with variadic arguments. Provide inline documentation to every added function, at least describing its inputs, outputs, precondition, postcondition, and giving a brief description. Do not use RETURN_STATUS. Assume EFI_STATUS to be a matching superset that is to be always used when BOOLEAN is not enough. Security violations should halt the system or cause a forced reboot. Codestyle. The codebase followsEDK II codestyle with few changesand clarifications. Write inline documentation for the functions and variables only once: in headers, where a header prototype is available, and inline for static variables and functions. Use line length of 120 characters or less, preferably 100 characters. Use spaces after casts, e.g. (VOID *)(UINTN) Variable. Use SPDX license headers as shown in acidanthera/bugtracker#483. Debugging. The codebase incorporates EDK II debugging and few custom features to improve the experience. Use module prefixes, 2-5 letters followed by a colon (:), for debug messages. For OpenCorePkg use OC:, for libraries and drivers use their own unique prefixes. Do not use dots (.) in the end of debug messages and separate EFI_STATUS, printed by %r, with a hyphen (e.g. OCRAM: Allocation of %u bytes failed - **%rtextbackslash n).** Use DEBUG_CODE_BEGIN () and DEBUG_CODE_END () constructions to guard debug checks that may potentially reduce the performance of release builds and are otherwise unnecessary. Use DEBUG macro to print debug messages during normal functioning, and RUNTIME_DEBUG for debugging after EXIT_BOOT_SERVICES. Use DEBUG_VERBOSE debug level to leave debug messages for future debugging of the code, which are currently not necessary. By default DEBUG_VERBOSE messages are ignored even in DEBUG builds. Use DEBUG_INFO debug level for all non critical messages (including errors) and DEBUG_BULK_INFO for extensive messages that should not appear in NVRAM log that is heavily limited in size. These messages are ignored in RELEASE builds. Use DEBUG_ERROR to print critical human visible messages that may potentially halt the boot process, and DEBUG_WARN for all other human visible errors, RELEASE builds included. When trying to find the problematic change it is useful to rely on git-bisect functionality."},{"title":"4. ACPI","url":"/4-acpi.html","content":"4.1 简介ACPI（Advanced Configuration and Power Interface，高级配置和电源接口）是发现和配置计算机硬件的开放标准。ACPI 规格 定义了实现用的标准表（如 DSDT、SSDT、FACS、DMAR）和各种方法（如 _DSM 和 `_PRW）。现代硬件几乎不需要更改即可保持 ACPI 兼容性，但是 OpenCore 仍然提供了修改 ACPI 的方法。 要反汇编和编译 ACPI 表，可以使用由 ACPICA 开发的 iASL compiler。你可以从 Acidanthera/MaciASL 下载 iASL 的图形界面程序。 对 ACPI 的修补按照如下顺序执行： Patch Delete Add Quirks 为了解决操作系统检测的问题，所有对 ACPI 的更改会在所有操作系统上生效。但是在某些场景下（ACPI 编写不规范、操作系统链式引导启动、ACPI 调试）会出现问题。因此在修补 ACPI 时，需要使用 \\_OSI 方法。 在系统引导前加载补丁使得编写「代理」补丁成为可能 —— 「代理」补丁即通过重命名的方法修补 DSDT 中的原始行为，然后通过 SSDT 注入同名的行为进行替代。 OpenCore、WhateverGreen、VirtualSmc、VoodooPS2 的 GitHub 仓库中都包含了部分 SSDT 和其他 ACPI 修补的方法。在 AppleLife 的 Laboratory 板块、DSDT 板块提供了不少教程和样例（如 笔记本电池修补教程）。Dortania 也编写了许多 ACPI 有关的教程。但是请注意，这些教程和 OpenCore 无关，他们提供的解决方法也不一定有用。 译者注：对于中国黑苹果玩家，强烈推荐 OC-little 项目，提供了众多 SSDT 范例和相关指导；笔记本用户电池修补请参考 这篇教程。 4.2 属性列表4.2.1 AddType: plist arrayFailsafe: EmptyDescription: 从 OC/ACPI 目录加载指定的 ACPI 表。 设计为用 plist dict 值填充以描述每个块级项目。请参阅下面 4.3 Add 属性 章节。 4.2.2 DeleteType: plist arrayFailsafe: EmptyDescription: 从 ACPI 栈中删除选定的表。 设计为用 plist dict 值填充以描述每个块级项目。请参阅下面 4.4 Delete 属性 章节。 4.2.3 PatchType: plist arrayFailsafe: EmptyDescription: 在添加或删除 ACPI 表之前执行的二进制修补。 设计为用 plist dictionary 值填充以描述每个块级项目。请参阅下面 4.5 Patch 属性 章节。 4.2.4 QuirksType: plist dictDescription: 应用下文 4.6 Quirks 属性 章节中描述的 Quirks。 4.3 Add 属性4.2.1 CommentType: plist stringFailsafe: Empty stringDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 4.2.2 EnabledType: plist booleanFailsafe: falseDescription: 除非此值为 true，否则此 ACPI 表不会被添加。 4.2.3 PathType: plist stringFailsafe: Empty stringDescription: 需要加载的 ACPI 表所在的路径。示例值如 DSDT.aml、SubDir/SSDT-8.aml、SSDT-USBX.aml。 所有 ACPI 表都从 OC/ACPI 目录加载，加载顺序遵循数组中的项目顺序。 注： 除具有 DSDT 表标识符（由解析得到的数据、而非由其文件名决定）的表外，所有表都将作为新表插入 ACPI 栈。而 DSDT 表与其余的表不同，将会执行 DSDT 表的替换。 4.4 Delete 属性4.2.1 AllType: plist booleanFailsafe: falseDescription: 如果设置为 true，则所有符合条件的 ACPI 表都会被舍弃。 否则，只舍弃第一个匹配到的。 4.2.2 CommentType: plist stringFailsafe: Empty stringDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 4.2.3 EnabledType: plist booleanFailsafe: falseDescription: 除非此值为 true，否则此 ACPI 表不会被舍弃。 4.2.4 OemTableIdType: plist data, 8 bytesFailsafe: All zeroDescription: 将表的 OEM ID 匹配为此处所填的值，全部为 0 时忽略。 4.2.5 TableLengthType: plist integerFailsafe: 0Description: 将表的大小匹配为此处所填的值，填 0 时忽略。 4.2.6 TableSignatureType: plist data, 4 bytesFailsafe: All zeroDescription: 将表的签名匹配为此处的值，全部为 0 时忽略。 注：当序列需要在多处替换的时候，务必注意不要指定表的签名，尤其是在进行不同类型的重命名操作的时候。 4.5 Patch 属性4.5.1 CommentType: plist stringFailsafe: Empty stringDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 4.5.2 CountType: plist integerFailsafe: 0Description: 补丁应用的次数。如果将此值设置为 0，补丁将会被应用于所有匹配。 4.5.3 EnabledType: plist booleanFailsafe: falseDescription: 除非设置为 true，否则此处的 ACPI 补丁不会生效。 4.5.4 FindType: plist dataFailsafe: Empty dataDescription: 需要寻找的 Data，长度必须和 Replace 相等。 4.5.5 LimitType: plist integerFailsafe: 0Description: 要搜索的最大字节数。当此值为 0 时会遍历整个 ACPI 表。 4.5.6 MaskType: plist dataFailsafe: Empty dataDescription: 查找比较期间使用的数据按位掩码。 通过忽略未屏蔽（设置为零）位来进行模糊搜索。可以设置为空数据以忽略，否则此值的长度必须和 Replace 的长度相等。 4.5.7 OemTableIdType: plist data, 8 bytesFailsafe: All zeroDescription: 将表的 OEM ID 匹配为此处所填的值，全部为 0 时忽略。 4.5.8 ReplaceType: plist dataFailsafe: Empty dataDescription: 一个或多个字节的替换数据。 4.5.9 ReplaceMarkType: plist dataFailsafe: Empty dataDescription: 替换数据期间使用的数据按位掩码。 通过忽略未屏蔽（设置为零）位来进行模糊搜索。可以设置为空数据以忽略，否则此值的长度必须和 Replace 的长度相等。 4.5.10 SkipType: plist integerFailsafe: 0Description: 完成替换之前要跳过的匹配数。 4.5.11 TableLengthType: plist integerFailsafe: 0Description: 将表的大小匹配为此处所填的值，填 0 时忽略。 4.5.11 TableSignatureType: plist data, 4 bytesFailsafe: All zeroDescription: 将表的签名匹配为此处的值，全部为 0 时忽略。 大多数情况下，ACPI 补丁是有害而无益的： 避免用 ACPI 补丁重命名设备。这样做可能会使设备重命名失败，或者会对不相关的设备进行错误地重命名（如 EC 和 EC0）。为了保证 ACPI 的一致性，在 I/O 注册表级别重命名设备会更加安全，比如 WhateverGreen 的做法。 避免为了支持更高级的功能集而给 _OSI 打补丁，除非你非常需要。这样做通常会侵入 APTIO 固件，从而导致需要用打更多的补丁去填坑。现代的固件基本不需要，而真正需要的那些固件只要打一些更小的补丁就可以了。 尽量避免重命名 _PRW 或 _DSM 之类的魔改举动。 在某些情况下，打补丁确实是有意义的： 刷新 HPET（或其他设备）的 method header 来避免老硬件上的 _OSI 兼容性检查。可通过将 A0 10 93 4F 53 46 4C 00 替换为 A4 0A 0F A3 A3 A3 A3 A3 的办法，使带有 if ((OSFL () == Zero)) { If (HPTE) ... Return (Zero) 的 _STA method 达到强制返回 0xF 的目的。 在 SSDT 中实现自定义 method，比如笔记本电脑上功能键可以通过将 _Q11 替换为 XQ11 的方法进行仿冒。 TianoCore 源文件 AcpiAml.h 可能会对于理解 ACPI 操作码有所帮助。 注：Find 和 Replace 的长度 必须完全一样，否则 ACPI 表可能会被破坏、导致系统不稳定。必要时请使用「代理」补丁的方法、或使用 NOP 填充剩余区域 4.6 Quirks 属性4.6.1 FadtEnableResetType: plist booleanFailsafe: falseDescription: 在 FADT 表中提供寄存器复位标志，用于修复旧硬件的重启和关机。除非需要，否则不建议启用。 只有在传统硬件和少数笔记本上需要。这一 Quirk 也可以修复电源快捷键（译者注：Command + 电源键）。不建议启用，除非不启用就无法关机和重启。 4.6.2 NormalizeHeadersType: plist booleanFailsafe: falseDescription: 清理 ACPI 表头字段以解决 macOS ACPI 实现错误导致的引导崩溃参考: 由 Alex James（theracermaster）在调试 AppleACPIPlatform 时发现。从 macOS Mojave (10.14) 开始，这个错误已经被修复。 4.6.3 RebaseRegionsType: plist booleanFailsafe: falseDescription: 尝试试探性地重定位 ACPI 内存区域。不建议启用这一选项，除非你需要自定义 DSDT。 ACPI 表通常由底层固件动态生成。在与位置无关的代码中，ACPI 表可能包含用于设备配置的 MMIO 区域的物理地址，通常按区域（例如 OperationRegion）分组。 更改固件设置或硬件配置，升级或修补固件不可避免地会导致动态生成的 ACPI 代码发生变化，这有时会导致上述 OperationRegion 结构中的地址发生变化。 因此，对 ACPI 表进行任何形式的修改都是非常危险的。最合理的方法是对 ACPI 进行尽可能少的更改，并尝试不替换任何表，尤其是 DSDT。 如果无法不得不替换 DSDT，则至少应尝试确保自定义 DSDT 基于最新的 DSDT 或避免对受影响区域的读写。如果没有其他帮助，可以尝试通过尝试修复 ACPI 地址来避免在 macOS 引导的 PCI Configuration Begin 阶段出现停顿的情况。 4.6.4 ResetHwSigType: plist booleanFailsafe: falseDescription: 将 FACS 表中 HardwareSignature 的值重置为 0。 启用这一选项可以解决固件无法在重新启动过程中保持硬件签名导致的休眠唤醒问题。 4.6.5 ResetLogoStatusType: plist booleanFailsafe: falseDescription: 将 BGRT 表中 Displayed 状态字段重置为 false. 这适用于提供 BGRT 表、但随后无法处理屏幕更新的固件。如果在开机时无法显示 OEM Windows 标志的硬件可以尝试开启开启。"},{"title":"5. Booter","url":"/5-booter.html","content":"5.1 简介本部分允许在 Apple BootLoader（boot.efi）上应用不同种类的 UEFI 修改。目前，这些修改为不同的固件提供了各种补丁和环境更改。其中一些功能最初是作为 AptioMemoryFix.efi 的一部分，如今 AptioMemoryFix.efi 已经不再维护。如果你还在使用，请参考 Tips and Tricks 章节提供的迁移步骤。 如果您是第一次在自定义固件上使用此功能，则首先需要执行一系列检查。开始之前，请确保您具有： 最新版本的 UEFI 固件（去主板厂家的官网上看看） 禁用了 Fast Boot 和 Hardware Fast Boot。如果 BIOS 里有相关选项，禁用掉。 Above 4G Decoding 或类似功能，如果有的话，请在固件设置中启用。注意，在某些主板上（特别是 ASUS WS-X299-PRO）这个选项会造成不良影响，必须禁用掉。虽然目前还不知道是不是其他主板也有同样问题，但是如果你遇到了不稳定的启动故障，可以首先考虑检查一下这个选项。 启用了 DisableIoMapper quirk、或者在 BIOS 中禁用 VT-d、或者删去了 ACPI DMAR 表。 启动参数中 没有 slide。 除非你没法开机、并且在日志里看见了 No slide values are usable! Use custom slide!，否则不论如何也不要使用这个启动参数。 CFG Lock (MSR 0xE2 写保护) 在 BIOS 中被禁用。如果 BIOS 中没有、而且你心灵手巧，你可以考虑 手动打补丁将其禁用 。更多细节请参考 VerifyMsrE2。 在 BIOS 中禁用 CSM (Compatibility Support Module)。NVIDIA 6xx / AMD 2xx 或更老的平台可能需要刷新 GOP ROM，具体步骤参考 GopUpdate 或者 AMD UEFI GOP MAKER。 除非 USB 设备断开连接，否则如果引导停止，则仅在 BIOS 中启用 EHCI / XHCI Hand-off。 在 BIOS 中启用 VT-x、Hyper Threading、Execute Disable Bit。 有时你还可能需要在 BIOS 中禁用 Thunderbolt support、Intel SGX 和 Intel Platform Trust。但是这一操作不是必须的。 在调试睡眠问题时，您可能希望（临时）禁用 Power Nap 和自动关闭电源，这似乎有时会导致在旧平台上唤醒黑屏或循环启动的问题。具体问题可能因人而异，但通常你应首先检查 ACPI 表，比如这是在 Z68 主板 上找到的一些 Bug。要关闭 Power Nap 和其他功能，请在终端中运行以下命令： 注：这些设置可能会在硬件更改、操作系统更新和某些其他情况下重置。要查看它们的当前状态，请在终端中使用 pmset -g 命令。 5.2 属性列表5.2.1 MmioWhitelistType: plist arrayDescription: 设计为用 plist dict 值填充，用来描述在启用 DevirtualiseMmio 这个 Quirk 时特定固件能够运作的关键地址。详见下面的 MmioWhitelist Properties 章节。 译者注：如果开机卡在 PCI... 可以尝试开启 Item 1 下的 Patch 5.2.2 QuirksType: plist dictDescription: 应用下面的 Quirks 属性部分中所述的各个引导 Quirk。 5.3 MmioWhitelist 属性5.3.1 AddressType: plist integerFailsafe: 0Description: 指排除在外的 MMIO 地址, 其内存描述符（Memory Descriptor）会被 DevirtualiseMmio 虚拟化（不变）。该值所在的区域会被分配一个虚拟地址，因此在操作系统运行期间，固件能够直接与该内存区域进行通信。 5.3.2 CommentType: plist stringFailsafe: Empty stringDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 5.3.3 EnabledType: plist booleanFailsafe: falseDescription: 除非设置为 true，否则此地址将被虚拟化。 5.4 Quirks 属性AvoidRuntimeDefragType: plist booleanFailsafe: falseDescription: 防止 boot.efi 运行时执行内存碎片整理 这个选项通过提供对可变存储的支持，修复了包括日期、时间、NVRAM、电源控制等 UEFI Runtime 服务。 注: 除 Apple 和 VMware 固件外，都需要启用此选项。 DevirtualiseMmioType: plist booleanFailsafe: falseDescription: 从选定的 MMIO 区域中删除 Runtime 属性。 通过删除已知内存区域的 runtime bit，此选项可减少内存映射中 stolen memory footprint。 这个 Quirks 可能会导致可用的 KASLR slides 增加，但如果没有其他措施，不一定与目标主板兼容。 通常，这会释放 64 到 256 MB的内存（具体数值会显示在调试日志中）。在某些平台上这是引导 macOS 的唯一方法，否则在引导加载程序阶段会出现内存分配错误。 该选项通常对所有固件都有用，除了一些非常古老的固件（例如 Sandy Bridge）。 在某些固件上，它可能需要一个例外映射列表。为了使 NVRAM 和休眠功能正常工作，获取其虚拟地址仍然是必要的。 请参考 MmioWhitelist 章节来实现这个。 译者注：对于某些 300 系列主板是必须的 DisableSingleUserType: plist booleanFailsafe: falseDescription: 禁用 Apple 单用户模式 这个选项可以禁用 CMD+S 热键和 -s 启动参数来限制单用户模式。启用这一 Quirks 后预期行为应和 T2 的模型行为类似。请参考 Apple 的 这篇文章 以了解如何在启用这一 Quirks 后继续使用单用户模式。 DisableVariableWriteType: plist booleanFailsafe: falseDescription: 防止 macOS 获取 NVRAM 的写入权限。 这个选项可以限制 macOS 对 NVRAM 的写入。这个 Quirk 需要 OpenRuntime.efi（原名 FwRuntimeServices.efi）提供了 OC_FIRMWARE_RUNTIME 协议的实现. 注: 这个 Quirk 也可以避免由于无法将变量写入 NVRAM 而导致的对操作系统的破坏。 译者注：在 Z390/HM370 等没有原生 macOS 支持 NVRAM 的主板上需要开启。 DiscardHibernateMapType: plist booleanFailsafe: falseDescription: 复用原始的休眠内存映射。 这一选项强制 XNU 内核忽略新提供的内存映射、认定设备从休眠状态唤醒后无需对其更改。如果你在使用 Windows，则 务必启用 这一选项，因为 Windows 要求 S4 唤醒后保留运行内存的大小和未知。 注: 这可能用于解决较旧硬件上的错误内存映射。如 Insyde 固件的 Ivy Bridge 笔记本电脑或者 Acer V3-571G。 除非您完全了解这一选项可能导致的后果，否则请勿使用此功能。 EnableSafeModeSlideType: plist booleanFailsafe: falseDescription: 修补引导加载程序以在安全模式下启用 KASLR。 这个选项与启动到安全模式（启动时按住 Shift 或受用了 -x 启动参数）有关。默认情况下，安全模式会使用 slide=0，这个 Quirks 试图通过修补 boot.efi 接触这一限制。只有当 ProvideCustomSlide 启用后才可以启用本 Quirks。 注: 除非启动到安全模式失败，否则不需要启用此选项。 EnableWriteUnprotectorType: plist booleanFailsafe: falseDescription: 关闭 CR0 寄存器中的写入保护。 这个选项会在 UEFI Runtime Services 执行过程中，删除 CR0 寄存器中的写保护 WP bit，从而绕过其代码页的 RX̂ 权限。这个 Quirk 需要配合 OpenRuntime.efi（原 FwRuntimeServices.efi）里的 OC_FIRMWARE_RUNTIME 协议来实现。 注：这个 Quirk 可能会破坏你的固件的安全性。如果你的固件支持内存属性表 (MAT)，请优先使用下文中的 RebuildAppleMemoryMap 那个 Quirk。 ForceExitBootServicesType: plist booleanFailsafe: falseDescription: 在失败时用新的内存映射（Memory Map）重试 ExitBootServices。 开启后会确保 ExitBootServices 即使在 MemoryMap 参数过期时也能调用成功，方法主要是获取当前的内存映射，并重试调用 ExitBootServices。 注：是否启用这个 Quirks 取决于你是否遇到了 Early Boot 故障。除非你详细了解这一选项可能导致的后果，否则请勿启用这一选项。 ProtectMemoryRegionsType: plist booleanFailsafe: falseDescription: 保护内存区域免于不正确的读写。 有些固件会错误映射内存区域： CSM 区域会被标记为引导服务的代码或数据，从而成为 XNU 内核的空闲内存。 MMIO 区域会被标记为预留内存，保持不被映射的状态，但在运行时可能需要在 NVRAM 的支持下才能访问。 这一 Quirk 会尝试修复这些区域的类型，比如用 ACPI NVS 标记 CSM，MMIO 标记 MMIO。 注：是否启用这一 Quirk 取决于你是否遇到了休眠、睡眠无法唤醒、启动失败或其他问题。一般来说，只有古董固件才需要启用。 ProtectSecureBootType: plist booleanFailsafe: falseDescription: 保护 UEFI 安全启动变量不被写入。 尝试从操作系统写入 db、dbx、PK 和 KEK 时生成报告。 注：这个 Quirk 主要试图避免碎片整理导致的 NVRAM 相关问题，如 Insyde 或 MacPro5,1。 ProtectUefiServicesType: plist booleanFailsafe: falseDescription: 保护 UEFI 服务不被固件覆盖。 某些现代固件（包括硬件和 VMware 之类的虚拟机）可能会在加载驱动及相关操作的过程中，更新 UEFI 服务的指针。这一行为会直接破坏其他影响内存管理的 Quirk，如 DevirtualiseMmio、ProtectMemoryRegions，或 RebuildAppleMemoryMap；也可能会破坏其他 Quirk，具体取决于 Quirk 的作用。 注：在 VMware 上，是否需要开启这个 Quirk 取决于是否有 Your Mac OS guest might run unreliably with more than one virtual core. 这样的消息。 ProvideCustomSlideType: plist booleanFailsafe: falseDescription: 为低内存设备提供自定义 KASLR slide 值。 开启这个选项后，将会对固件进行内存映射分析，检查所有 slide（从 1 到 255）中是否有可用的。由于 boot.efi 私用 rdrand 或伪随机 rdtsc 随机生成此值，因此有可能出现冲突的 slide 值被使用并导致引导失败。如果出现潜在的冲突，这个选项将会强制为 macOS 选择一个伪随机值。这同时确保了 slide= 参数不会被传递给操作系统。 注: OpenCore 会自动检查是否需要启用这一选项。如果 OpenCore 的调试日志中出现 OCABC: Only N/256 slide values are usable! 则请启用这一选项。 RebuildAppleMemoryMapType: plist booleanFailsafe: falseDescription: 生成与 macOS 兼容的内存映射。 Apple 内核在解析 UEFI 内存映射时有几个限制： 内存映射的大小不能超过 4096 字节，因为 Apple 内核将其映射为一个 4 KiB 页面。由于某些固件的内存映射大小非常大（大约超过 100 个条目），Apple 内核会在启动时崩溃。 内存属性表会被忽略。EfiRuntimeServicesCode 内存静态获得 RX 权限，其他内存类型则获得 RW 权限。某些固件驱动会在运行时把数据写到全局变量中，因此 Apple 内核在调用 UEFI Runtime Services 时会崩溃，除非驱动的 .data 部分有 EfiRuntimeServicesData 类型。 为了解决这些限制，这个 Quirk 将内存属性表的权限应用到传递给 Apple 内核的内存映射中，如果生成的内存映射超过 4KiB，则可选择尝试统一类似类型的连续插槽。 注 1：由于许多固件自带的内存保护不正确，所以这个 Quirk 一般要和 SyncRuntimePermissions 一起启用。注 2：根据是否遇到第一阶段启动失败再决定是否启用这一 Quirk。在支持内存属性表 (MAT) 的平台上，这一 Quirk 是 EnableWriteUnprotector 更好的替代。 SetupVirtualMapType: plist booleanFailsafe: falseDescription: 将 SetVirtualAddresses 调用修复为虚拟地址. 选择让固件在调用 SetVirtualAddresses 后通过虚拟地址访问内存，可能会导致 Early Boot 故障。这个 Quirk 可通过对分配的虚拟地址和物理内存进行 Early Boot 身份映射来解决这个问题。 注：是否启用这个 Quirks 取决于你是否遇到了 Early Boot 故障。目前具有内存保护支持的新固件（例如 OVMF ）由于一些原因不支持此 Quirks：acidanthera/bugtracker#719。 SignalAppleOSType: plist booleanFailsafe: falseDescription: 不论使用什么操作系统、总是向 OSInfo 报告启动的是 macOS。 Mac 设备在不同的操作系统中具有不同的行为，因此如果你在使用 Mac 设备，这一功能会非常有用。例如，你可以通过启用这一选项为某些双 GPU 的 MacBook 型号中在 Windows 和 Linux 中启用 Intel GPU。 SyncRuntimePermissionsType: plist booleanFailsafe: falseDescription: 更新运行时环境的内存权限。 某些固件无法正确处理运行时权限，表现为： 把 OpenRuntime 在内存映射中错误地标记为不可执行。 把 OpenRuntime 在内存属性表中错误的标记为不可执行。 在 OpenRuntime 加载之后丢失内存属性表中的条目。 把内存属性表中的项目标记为 read-write-execute。 这个 Quirk 会通过更新内存映射和内存属性表来纠正这一问题。 注：是否开启这一 Quirk 取决于 macOS、Linux 或 Windows 是否遇到 Early Boot 故障。一般来说，只有 2018 年以后发布的固件才会受到影响。"},{"title":"6. DeviceProperties","url":"/6-device-properties.html","content":"6.1 简介设备相关配置通过专用的缓存区（EfiDevicePathPropertyDatabase）提供给 macOS，这个缓冲区是设备路径到属性名称与值的键值对的序列化映射。 属性相关数据可以使用 gfxutil 进行调试。在 macOS 下获取当前属性数据请使用 ioreg： 6.2 属性列表6.2.1 AddType: plist dictDescription: 将设备属性从设备路径的映射（plist dict）设置为变量名称和值的映射（plist dict），其中变量名称和值的格式为 plist metadata。设备路径必须以 canonic string 格式提供（例如： PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)）。添加的属性只有在不存在且未被屏蔽的情况下才会被设置。注：目前，属性只能通过原始驱动程序添加。因此除非安装了单独的驱动程序，否则没有理由 Delete 变量。 6.2.2 DeleteType: plist dictDescription: 从设备路径的映射（plist dict）到 plist 字符串格式的变量名数组（数据类型 plist array）中删除设备属性。 译者注：这里的设置等同于 Clover 里的 ACPI 重命名 _DSM → XDSM =&gt; TgtBridge 6.3 常见属性一些常见的属性包括： device-id用户指定的设备标识符，用于 I/O 套件匹配。数据类型为 4 byte data. vendor-id用户指定的供应商标识符，用于 I/O 套件匹配。数据类型为 4 byte data. AAPL,ig-platform-idIntel GPU 缓冲帧标识符，用于在 Ivy Bridge 上选择缓冲帧区域。数据类型为 4 byte data。 AAPL,snb-platform-idIntel GPU 缓冲帧标识符，用于在 Sandy Bridge 上选择缓冲帧区域。数据类型为 4 byte data。 layout-idAppleHDA 的音频布局，4 byte data。 "},{"title":"7. Kernel","url":"/7-kernel.html","content":"7.1 简介本章节介绍了如何在 Apple Kernel（XNU）上应用各种不同的内核空间修改，包括内核驱动程序（kext）注入、修补以及屏蔽。 7.2 属性列表7.2.1 AddType: plist arrayFailsafe: EmptyDescription: 从 OC/Kexts 目录加载选定的 Kext 驱动。 设计为使用 plist dict 数据填充以描述每个驱动程序。请参阅下述 Add 属性章节。Kext 驱动程序加载的顺序遵照数组中项目的顺序，因此如 Lilu 这种其他驱动程序的依赖驱动应该位于前面。 7.2.2 DeleteType: plist arrayFailsafe: EmptyDescription: 从内核中删除选定的内核驱动程序。 设计为使用 plist dict 数据填充以描述每个驱动程序。请参阅下述 Delete 属性章节。Kext 驱动程序加载的顺序遵照数组中项目的顺序，因此如 Lilu 这种其他驱动程序的依赖驱动应该位于前面。 7.2.3 EmulateType: plist dictDescription: 在内核空间中仿真选定的硬件。请参考下文 Emulate 属性。 7.2.4 PatchType: plist arrayFailsafe: EmptyDescription: 在添加和删除驱动程序步骤之前执行的对现有 Kext 驱动程序的二进制修补。 设计为使用 plist dictionary 数据填充以描述每个驱动程序。请参阅下述 Patch 属性章节。\b 7.2.5 QuirksType: plist dictDescription: 应用下面的 Quirks 属性章节中描述的各个内核和驱动程序 Quirk。 7.3 Add 属性7.3.1 BundlePathType: plist stringFailsafe: Empty stringDescription: Kext 相对于 EFI/OC/kexts/Other/ 的路径 (e.g. Lilu.kext or MyKext.kext/Contents/PlugIns/MySubKext.kext). 注，如 VoodooPS2Controller.kext 这种包括其他 kext 驱动的，需要分别单独添加，如 VoodooPS2Controller.kext/Contents/PlugIns/VoodooPS2Keyboard.kext。 7.3.2 CommentType: plist stringFailsafe: Empty stringDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 7.3.3 EnabledType: plist booleanFailsafe: falseDescription: 是否加载该驱动. 7.3.4 ExecutablePathType: plist stringFailsafe: Empty stringDescription: Kext 中实际可执行文件的路径（如 Lilu.kext 中的可执行文件路径是 Contents/MacOS/Lilu）。 译者注：空壳 Kext 没有可执行文件（如 USBPorts.kext），此项留空即可 7.3.5 MaxKernelType: plist stringFailsafe: Empty stringDescription: 在小于等于指定的 macOS 版本中添加该 Kext 驱动程序。 你可以使用 uname -r 指令获取当前内核版本，一般为三个整数、中间由半角局点分隔，如 18.7.0 代表的是 10.14.6。OpenCore 对内核版本解释的实现方式如下图所示： 内核版本比较的实现如下图所示： 将 Darwin 内核版本号字符串从左到右以 . 符号作为分隔符分割成三个整数，即为 ParseDarwinVersion 的三个参数。FindDarwinVersion 函数将会通过在内核镜像中查找形如 的字符串来定位 Darwin 内核版本号。 7.3.6 MinKernelType: plist stringFailsafe: Empty stringDescription: 在大于等于指定的 macOS 版本中添加该 Kext 驱动程序。 注：匹配逻辑请参阅 Add MaxKernel 的描述。 译者注：以上两个属性定义了这个驱动将在什么版本范围的 macOS 中加载。留空表示在所有的 macOS 版本下都加载。 7.3.7 PlistPathType: plist stringFailsafe: Empty stringDescription: Kext 中 Info.plist 文件的路径。一般为 Contents/Info.plist。 7.4 Delete 属性7.4.1 CommentType: plist stringFailsafe: Empty stringDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 7.4.2 EnabledType: plist booleanFailsafe: falseDescription: 除非设置为 true，否则这个内核驱动不会被加载。 7.4.3 IdentifierType: plist stringFailsafe: Empty stringDescription: Kext Bundle 标识符（比如com.apple.driver.AppleTyMCEDriver）。 7.4.4 MaxKernelType: plist stringFailsafe: Empty stringDescription: 在小于等于指定的 macOS 版本中阻止 Kext 驱动程序。 注：匹配逻辑请参阅 Add MaxKernel 的描述。 7.4.5 MinKernelType: plist stringFailsafe: Empty stringDescription: 在大于等于指定的 macOS 版本中阻止 Kext 驱动程序。 注：匹配逻辑请参阅 Add MaxKernel 的描述。 7.5 Emulate 属性7.5.1 Cpuid1DataType: plist data, 16 bytesFailsafe: All zeroDescription: EAX、EBX、ECX、EDX 值的序列，用来取代 XNU 内核中的 CPUID (1) 调用。 该属性应用于以下两种需求： 对不支持的 CPU 型号启用支持。 对不支持的 CPU Variant 启用 XCPM 支持。 通常来讲只需要处理 EAX 的值，因为它代表完整的 CPUID。剩余的字节要留为 0。字节顺序是小字节序（Little Endian），比如 C3 06 03 00 代表 CPUID 0x0306C3 (Haswell)。 推荐使用下面的组合启用 XCPM 支持： Haswell-E (0x0306F2) to Haswell (0x0306C3): Cpuid1Data: C3 06 03 00 00 00 00 00 00 00 00 00 00 00 00 00Cpuid1Mask: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 Broadwell-E (0x0406F1) to Broadwell (0x0306D4):Cpuid1Data: D4 06 03 00 00 00 00 00 00 00 00 00 00 00 00 00Cpuid1Mask: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 请记住，目前以下配置并不被兼容的（至少还没有人成功过）： 对于消费级的 Ivy Bridge（0x0306A9），苹果禁用了 XCPM 并推荐用户使用传统的电源管理。如果要使用这一选项，你还需要手动添加 _xcpm_patch 二进制修补以强制启用 XCPM。 低端处理器（如 Haswell+ 奔腾）不被 macOS 支持。如果要启用这些 CPU 请参阅 acidanthera/bugtracker#365 中的 Special NOTES 相关内容。 7.5.2 Cpuid1MaskType: plist data, 16 bytesFailsafe: All zeroDescription: Cpuid1Data 中激活的 bit 的位掩码。 当每个 Cpuid1Mask bit 都设置为 0 时将使用原始的 CPU bit，否则取 Cpuid1Data 的值。 7.6 Patch 属性7.6.1 BaseType: plist stringFailsafe: Empty stringDescription: 通过获取所提供的 Symbol 名称的地址，来选择 Symbol 匹配的 Base 进行补丁查找（或直接替换）。可以设置为空字符串以忽略。 7.6.2 CommentType: plist stringFailsafe: Empty stringDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 7.6.3 CountType: plist integerFailsafe: 0Description: 修补的次数，超过这一次数后便不再修补。0 表示修补所有查找到的。 7.6.4 EnabledType: plist booleanFailsafe: falseDescription: 除非设置为 true，否则不对内核进行该修补。 7.6.5 FindType: plist dataFailsafe: Empty dataDescription: 需要查找的数据。可留空，在 Base 处直接替换。若不留空，其大小必须等于 Replace。 7.6.6 IdentifierType: plist stringFailsafe: Empty stringDescription: Kext Bundle 标识符（如 com.apple.driver.AppleHDA）或内核补丁的 kernel。 7.6.7 LimitType: plist integerFailsafe: 0Description: 搜索的最大字节数。可以设置为 0 来查找整个 ext 或内核。 7.6.8 MaskType: plist dataFailsafe: Empty dataDescription: 在查找比较中使用数据位掩码。允许通过忽略未被屏蔽的 bit（设置为 0）进行模糊搜索。若留空则代表忽略，否则其大小必须等于 Replace。 7.6.9 MaxKernelType: plist stringFailsafe: Empty stringDescription: 在指定的或更早的 macOS 版本上打补丁。 注：匹配逻辑请参阅 Add MaxKernel 的描述。 7.6.10 MinKernelType: plist stringFailsafe: Empty stringDescription: 在指定的或更新的 macOS 版本上打补丁。 注：匹配逻辑请参阅 Add MaxKernel 的描述。 7.6.11 ReplaceType: plist dataFailsafe: Empty dataDescription: 一个或多个字节的替换数据。 7.6.12 ReplaceMaskType: plist dataFailsafe: Empty dataDescription: 替换时使用的数据位掩码。允许通过更新掩码（设置为非 0）来进行模糊替换。若留空则代表忽略，否则其大小必须等于 Replace。 7.6.13 SkipType: plist integerFailsafe: 0Description: 在替换前要跳过的发现事件数。 7.7 Quirks 属性AppleCpuPmCfgLockType: plist booleanFailsafe: falseDescription: 禁用 AppleIntelCPUPowerManagement.kext 中的 PKG_CST_CONFIG_CONTROL (0xE2) 修改，从而避免早期 Kernel Panic。 某些固件会锁定 PKG_CST_CONFIG_CONTROL MSR 寄存器。可以使用捆绑的 VerifyMsrE2 工具检查其状态。 由于现代固件已经提供了 CFG Lock 相关设置、从而可以配置 PKG_CST_CONFIG_CONTROL 寄存器锁定，此选项应该尽可能避免。对于一些不显示 CFG Lock 配置的固件，可以按照下述配置进行修改： 下载 UEFITool 和 IFR-Extractor 使用 UEFITool 中打开固件镜像文件，找到 CFG Lock 的 Unicode 字符串。如果你没有找到，意味着你的固件可能不支持 CFG Lock 解锁，那么你现在可以停下来了。 从 UEFITool 菜单中的 Extract Body 选项提取 Setup.bin 中的 PE32 镜像部分。 对提取出来的文件执行 IFR-Extractor（./ifrextract Setup.bin Setup.txt）。 从 Setup.txt 中找到 CFG Lock，VarStoreInfo（或者 VarOffset、VarName），记住紧随其后的偏移量值（例如 0x123）。 下载并执行由 brainsucker 编译的 修改版 GRUB Shell。你也可以是使用 datasone 制作的 新版本 GRUB Shell。 在 GRUB Shell 中，使用 setup_var 0x123 0x00（其中 0x123 应该被替换为你在前几步找到的偏移值），然后重启电脑。 警告: 可变偏移量对于每个主板乃至每一个固件版本都是唯一的。永远不要尝试使用别人的偏移量！ AppleXcpmCfgLockType: plist booleanFailsafe: falseDescription: 禁用 XNU 内核对 PKG_CST_CONFIG_CONTROL (0xE2) 修改，从而避免早期 Kernel Panic。 注：这一选项应该避免被使用，请参考上文中关于 AppleCpuPmCfgLock 的介绍。 AppleXcpmExtraMsrsType: plist booleanFailsafe: falseDescription: 对于没有 XCMP 支持的设备，禁用对选定 CPU 的多 MSR 访问。 通常将其与 Haswell-E，Broadwell-E，Skylake-SP 和类似 CPU 的 Emulate 结合使用。更多关于 XCPM 修补的信息可以在 acidanthera/bugtracker#365 找到。 注：Ivy Bridge 或 Pentium CPU 将需要其他未提供的补丁。建议对前者使用 AppleIntelCpuPowerManagement.kext。 AppleXcpmForceBoostType: plist booleanFailsafe: falseDescription: 在 XCPM 模式下强制使用最大性能。 该补丁将 0xFF00 写入 MSR_IA32_PERF_CONTROL (0x199)，有效地做到了一直保持最大倍数。 注：尽管有助于提高性能，但是在所有操作系统上都强烈建议不要启用这一选项。只有在某些 Xeon 型号的 CPU 才有可能从这个选项中受益。 CustomSMBIOSGuidType: plist booleanFailsafe: falseDescription: 对 UpdateSMBIOSMode 自定义模式执行 GUID 修补，通常用于戴尔笔记本电脑。 DisableIoMapperType: plist booleanFailsafe: falseDescription: 禁用 XNU (VT-d) 中的 IOMapper 支持，这可能与固件的实现相冲突。 注：相比直接在 ACPI 表中删除 DMAR，我们更推荐大家使用这一选项。这样不会破坏其他操作系统中的 VT-d 支持（总会有人需要用到的，对吧？）。 DisableRtcChecksumType: plist booleanFailsafe: falseDescription: 禁用 AppleRTC 初始校验和（0x58 - 0x59）写入。 注： 这个选项不能确保其他区域不被覆盖，如有需要，请使用 RTCMemoryFixup。 这个选项不能确保区域在固件阶段不被覆盖（例如 macOS bootloader）。如有需要，请参阅 AppleRtc 协议描述。 DummyPowerManagementType: plist booleanFailsafe: falseDescription: 禁用 AppleIntelCpuPowerManagement。 注：这一选项旨在替代 NullCpuPowerManagement.kext，用于 macOS 中没有电源管理驱动程序的 CPU。 ExternalDiskIconsType: plist booleanFailsafe: falseDescription: 修补 AppleAHCIPort.kext 图标，使 macOS 将所有 AHCI 存储设备显示为内部硬盘。 注：这一选项应尽量避免使用。现代固件通常情况下都是兼容的。 IncreasePciBarSizeType: plist booleanFailsafe: falseDescription: 将 IOPCIFamily 中 32 位 PCI Bar 的大小从 1 GB 增加到 4 GB。 注：你应该尽可能避免使用这一选项。通常这一选项只需要在配置错误或损坏的固件上开启。 译者注：如果你的 BIOS 中存在 Above4GDecoding 选项，请直接在 BIOS 中启用。 LapicKernelPanicType: plist booleanFailsafe: falseDescription: 禁用 LAPIC 中断导致的 Kernal Panic。 译者注：惠普电脑可能需要启用这一选项。 PanicNoKextDumpType: plist booleanFailsafe: falseDescription: 在发生内核崩溃时阻止输出 Kext 列表，提供可供排错参考的崩溃日志。 PowerTimeoutKernelPanicType: plist booleanFailsafe: falseDescription: 修复 macOS Catalina 中由于设备电源状态变化超时而导致的内核崩溃。 macOS Catalina 新增了一项额外的安全措施，导致在电源切换超时的时候会出现 Kernel Panic。配置错误的硬件可能会因此出现问题（如数字音频设备）、有的时候会导致睡眠唤醒的问题。这一 Quirk 和引导参数 setpowerstate_panic=0 功能大部分一致，但是后者只应该用于调试用途。 ThirdPartyDrivesType: plist booleanFailsafe: falseDescription: 修补 IOAHCIDeleteStorage.kext，以在第三方驱动器启用 TRIM、硬盘休眠等功能。 注：NVMe SSD 通常无需这一修改。对于 AHCI SSD（如 SATA SSD），macOS 从 10.15 开始提供 trimforce，可以将 01 00 00 00 值写入 APPLE_BOOT_VARIABLE_GUID 命名空间中的 EnableTRIM 变量。 XhciPortLimitType: plist booleanFailsafe: falseDescription: 修补 AppleUSBXHCI.kext、AppleUSBXHCIPCI.kext、IOUSBHostFamily.kext 以移除 15 端口限制。 注：请尽可能避免使用这一选项。USB 端口数量限制是由 locationID 格式使用的比特数决定的。真正长期有效的解决方案是限制可用的 USB 端口个数在 15 以下（通过 USB 定制的方法）。"},{"title":"8. Misc","url":"/8-misc.html","content":"8.1 Introduction本部分包含关于 OpenCore 行为的其他配置，以及不能被分类到其它章节的配置条目的说明。 OpenCore 尽可能地遵循 bless 模式，即 Apple Boot Policy。bless 模式的主要特点是允许在文件系统中嵌入启动选项（而且能通过专门的驱动程序访问），同时，相比于 UEFI 规范中的可移动媒体列表，它还支持更多的预定义启动路径。 只有当分区符合 Scan policy 时才能被启动（Scan policy 是一组限制条件，能够使其仅使用特定文件系统和特定设备类型的分区）。具体的扫描策略（Scan policy）将在下面的 ScanPolicy 属性中阐述。 扫描过程从获取 Scan policy 过滤过的分区开始。每个分区可能会产生多个主选项和备用选项。主选项描述的是安装在这个介质上的操作系统。备用选项描述的是介质上的操作系统的恢复项。备用选项可以在没有主选项的情况下存在，反之亦然。请注意，这些选项描述的操作系统不一定都在同一个分区上。每个主选项和备用选项都可以作为辅助选项（Auxiliary Option），也可以不作为辅助选项，具体细节参考下面的 HideAuxiliary 章节。用来确定启动选项的算法如下： 通过 Scan policy（和驱动可用性）过滤，获取所有可用的分区句柄。 从 BootOrder UEFI 变量中，获取所有可用的启动选项。 对于每个找到的启动选项： 检索该启动选项的设备路径。 执行对设备路径的修复（如 NVMe 子类型修复）和扩展（如 Boot Camp）。 通过定位到所产生的设备路径，来获取句柄（失败时忽略）。 在分区句柄列表中找到设备句柄（缺失时忽略）。 对磁盘设备路径（不指定引导程序）执行 bless（可能返回不止一个条目）。 对文件设备路径直接检查其文件系统。 排除所有带有黑名单文件名的选项（参考 BlacklistAppleUpdate 选项）。 在 OpenCore 启动分区中，通过 Header Check 排除所有 OpenCore Bootstrap 文件。 如果有分区句柄列表，则在列表中将设备句柄标记为 used。 将生成的条目注册为主选项，并确定他们的类型。某些类型的选项作为辅助选项（如 Apple HFS Recovery）。 对于每个分区句柄： 如果分区句柄被标记为 unused，则执行 bless 主选项列表检索。如果设置了 BlessOverride 列表，那么不仅能找到标准的 bless 路径，还能找到自定义的路径。 排除带有黑名单文件名的选项（参考 BlacklistAppleUpdate 选项）。 在 OpenCore 启动分区中，通过 Header Check 排除所有 OpenCore Bootstrap 文件。 将生成的条目注册为主选项，并确定他们的类型。某些类型的选项作为辅助选项（如 Apple HFS Recovery）。 如果分区已经具有来 Apple Recovery 类型的主选项，则继续处理下一个句柄。 通过 bless 恢复选项列表检索和预定义路径，来查找备用条目。 将生成的条目注册为备用辅助选项，并确定它们的类型。 把自定义条目和工具添加为主选项，不做有关 Auxiliary 的任何检查。 把系统条目（如 Reset NVRAM）添加为主要的辅助选项。 启动选择器中的启动选项的显示顺序和启动过程，是通过扫描算法分别来确定的。显示顺序如下： 备用选项跟随主选项，即，Apple Recovery 会尽可能地跟随相关的 macOS 选项。 选项会按照文件系统句柄固件的顺序列出，以便在整个启动过程中保持一个既定的顺序，不因加载操作系统的不同而变化。 自定义条目、工具和系统条目会被添加到所有选项之后。 辅助选项只有在进入「高级模式」后才会显示（一般是按 空格 键）。 启动过程如下： 尝试通过 BootNext UEFI 变量查找第一个有效的主选项。 如果失败，则通过 BootOrder UEFI 变量继续查找。 将该选项标记为默认启动选项。 是否通过启动选择器来启动选项，取决于 ShowPicker 选项的设置。 如果还失败，则显示启动选择器。 注 1：这个过程只有在启用了 RequestBootVarRouting 选项，或者固件不控制 UEFI 启动选项（如 OpenDuetPkg 或其他自定义 BDS）时，才会可靠地工作。如果不启用 BootProtect，那么其他操作系统有可能会覆盖 OpenCore，如果你打算使用 OpenCore，请确保启用这个选项。 注 2：UEFI 变量引导选项的引导参数，如果存在的话则会被丢弃，因为它们包含的一些参数可能会对操作系统产生不利影响，一旦启用了安全引导，这种影响是我们不希望看到的。 注 3：某些操作系统（说的就是你，Windows）会在第一次启动时，或 NVRAM 重置后，创建他们的启动选项，并将其标记为最上面的选项。这种情况发生时，默认的启动条目选择将会更新，直到下一次重新手动配置。 8.2 PropertiesBootType: plist dictDescription: 应用本章节 Boot Properties 中的引导相关设置。 BlessOverrideType: plist arrayDescription: 通过 Bless Model 添加自定义扫描路径。 设计为填充 plist string 条目，其中包含指向自定义引导程序的绝对 UEFI 路径，例如，用于 Debian 引导程序的 \\EFI\\debian\\grubx64.efi。这允许引导选择器自动发现异常的引导路径。在设计上它们等效于预定义的 Bless 路径（如 \\System\\Library\\CoreServices\\boot.efi 和 \\EFI\\Microsoft\\Boot\\bootmgfw.efi），但与预定义的 Bless 路径不同，它们具有最高优先级。 DebugType: plist dictDescription: 应用本章节 Debug Properties 中的调试相关设置。 EntriesType: plist arrayDescription: 在开机引导菜单中添加引导项。 应填入 plist dict 类型的值来描述相应的加载条目。详见 Entry Properties 部分。 SecurityType: plist dictDescription: 应用本章节 Security Properties 中的安全相关设置。 ToolsType: plist arrayDescription: 将工具条目添加到开机引导菜单。 应填入 plist dict 类型的值来描述相应的加载条目。详见 Entry Properties 部分。 注：选择工具（比如 UEFI shell）是很危险的事情，利用这些工具可以轻易地绕过安全启动链，所以千万不要出现在产品配置中，尤其是设置了 vault 和安全启动保护的设备（译者注：即，工具仅作调试用）。 8.3 Boot PropertiesConsoleAttributesType: plist integerFailsafe: 0Description: 为控制台设置特定的属性。 根据 UEFI 规范，文本渲染器支持的颜色参数为前景色与背景色之和。黑色背景色和黑色前景色 (0) 的值是预留的。以下是颜色名称一览： 0x00 — EFI_BLACK（黑色字体） 0x01 — EFI_BLUE（蓝色字体） 0x02 — EFI_GREEN（绿色字体） 0x03 — EFI_CYAN（青色字体） 0x04 — EFI_RED（红色字体） 0x05 — EFI_MAGENTA（紫色字体） 0x06 — EFI_BROWN（棕色字体） 0x07 — EFI_LIGHTGRAY（亮灰色字体） 0x08 — EFI_DARKGRAY（暗灰色字体） 0x09 — EFI_LIGHTBLUE（淡蓝色字体） 0x0A — EFI_LIGHTGREEN（淡绿色字体） 0x0B — EFI_LIGHTCYAN（淡青色字体） 0x0C — EFI_LIGHTRED（淡红色字体） 0x0D — EFI_LIGHTMAGENTA（淡紫色字体） 0x0E — EFI_YELLOW（黄色字体） 0x0F — EFI_WHITE（白色字体） 0x00 — EFI_BACKGROUND_BLACK（黑色背景） 0x10 — EFI_BACKGROUND_BLUE（蓝色背景） 0x20 — EFI_BACKGROUND_GREEN（绿色背景） 0x30 — EFI_BACKGROUND_CYAN（青色背景） 0x40 — EFI_BACKGROUND_RED（红色背景） 0x50 — EFI_BACKGROUND_MAGENTA（紫色背景） 0x60 — EFI_BACKGROUND_BROWN（棕色背景） 0x70 — EFI_BACKGROUND_LIGHTGRAY（亮灰色背景） 注：这个选项可能和 TextRenderer 的 System 参数有冲突，设置一个非黑的背景可以用来测试 GOP 是否正常运行。 HibernateModeType: plist stringFailsafe: NoneDescription: 休眠检测模式。 支持以下模式： None — 禁用休眠 Auto — 从 RTC 或 NVRAM 中检测 RTC — 从 RTC 检测 NVRAM — 从 NVRAM 检测 HideAuxiliaryType: plist booleanFailsafe: falseDescription: 默认情况下，隐藏开机引导项菜单中的辅助条目。 满足任一以下条件的引导项条目即会被视为「辅助项目」 该引导项是 macOS Recovery 分区 该引导项是 macOS Time Machine 分区 该引导项被标记为 Auxiliary 该引导项是一个系统（如 Clean NVRAM） 即使被隐藏，你仍然可以通过 空格 进入「扩展模式」查看所有条目（引导项菜单会被重新加载）： 一般的，隐藏辅助条目有助于加快启动速度。 PickerAttributesType: plist integerFailsafe: 0Description: 设置开机引导菜单的属性。 不同的选项可以用属性掩码的方式来设置，其中掩码包含 OpenCore 的预留值（BIT0 ~ BIT15）和 OEM 特定值（BIT16 ~ BIT31）。 目前 OpenCore 提供的值包括： 0x0001 — OC_ATTR_USE_VOLUME_ICON，提供引导项自定义图标： .VolumeIcon.icns 文件，位于 APFS Preboot 根目录下。 .VolumeIcon.icns 文件，位于其他文件系统的卷宗的根目录下。 &lt;TOOL_NAME&gt;.icns 文件，用来显示 Tools 图标。 卷宗图标可以在访达中设置。注意，启用此功能可能会导致 外部可移除硬盘的图标 和 内部不可移除硬盘的图标 无法区分。 0x0002 — OC_ATTR_USE_DISK_LABEL_FILE，提供引导项自定义渲染的标题： .disk_label (.disk_label_2x) 文件与 bootloader 相关，适用于所有文件系统。 &lt;TOOL_NAME.lbl (&lt;TOOL_NAME.l2x) 文件与工具相关，适用于 Tools。 可用 disklabel 实用工具或 bless 命令来生成预置标签。当禁用或者缺少文本标签 (.contentDetails or .disk_label.contentDetails) 时将以它来代替渲染。 0x0004 — OC_ATTR_USE_GENERIC_LABEL_IMAGE，为没有自定义条目的启动项提供预定义的标签图像。可能会缺少实际启动项的详细信息。 PickerAudioAssistType: plist booleanFailsafe: falseDescription: 在开机引导菜单中启用 屏幕朗读。 macOS Bootloader 屏幕朗读 的偏好设置是存在 isVOEnabled.int32 文件的 preferences.efires 中、并受操作系统控制。这里仅提供一个等效的开关。切换 OpenCore 开机引导菜单和 macOS BootLoader FileVault 2 登录界面也可以使用快捷键 Command + F5。 注：屏幕朗读 依赖可以正常工作的音频设备。 PollAppleHotKeysType: plist booleanFailsafe: falseDescription: 在开机引导菜单中启用 modifier hotkey。 除了 action hotkeys（在 PickerMode 一节中有所描述，由 Apple BDS 处理），还有由操作系统 bootloader 处理的修饰键，即 boot.efi。这些键可以通过提供不同的启动模式来改变操作系统的行为。 在某些固件上，由于驱动程序不兼容，使用修饰键可能会有问题。为了解决问题，这个选项允许你在启动选择器中以更宽松的方式注册选择的热键，比如：在按住 Shift 和其他按键的同时支持敲击按键，而不是只按 Shift，这在许多 PS/2 键盘上是无法识别的。已知的 modifier hotkeys 包括： CMD+C+MINUS — 禁用主板兼容性检查。 CMD+K — 从 release 版本的内核启动，类似于 kcsuffix=release 参数。 CMD+R — 从恢复分区启动。 CMD+S — 启动至单用户模式。 CMD+S+MINUS — 禁用 KASLR slide，需要事先禁用 SIP。 CMD+V — 启用 -v。 Shift — 启用安全模式。 ShowPickerType: plist booleanFailsafe: falseDescription: 是否显示开机引导菜单。 TakeoffDelayType: plist integer, 32 bitFailsafe: 0Description: 在 处理引导项启动 和 处理 action hotkeys 之前的延迟，以微秒为单位。 引入这一延迟有助于为你争取时间去完成按住 action hotkey 的操作，比如启动到恢复模式。在某些平台上，可能需要把此项设置为至少 5000-10000 来使 action hotkeys 生效，具体取决于键盘驱动程序的性质。 TimeoutType: plist integer, 32 bitFailsafe: 0Description: 开机引导菜单中，启动默认启动项之前超时时间（以秒为单位）。 使用 0 禁用倒计时。 译者注：0 为关闭倒计时而非跳过倒计时，相当于 Clover 的 -1。 PickerModeType: plist stringFailsafe: BuiltinDescription: 选择启动管理器的界面。 这里描述的是具有可选用户界面的底层启动管理器，支持以下值： Builtin — 使用由 OpenCore 处理的启动管理器，简单的文本用户界面。 External — 如果可用，则使用外部启动管理器协议，否则使用 Builtin 模式。 Apple — 如果可用，则使用 Apple 启动管理器，否则使用 Builtin 模式。 External 模式一旦成功，就会完全禁用 OpenCore 中的除策略强制执行的所有其他启动管理器，而 Apple 模式下可以绕过策略的强制执行。请参阅 ueficanopy 插件以了解自定义用户界面的实例。 OpenCore 内置的启动选择器包含了一系列在启动过程中选择的操作。支持的操作与 Apple BDS 类似，一般来说能够通过在启动过程中按住 action hotkeys 来实现，目前有以下几种： Default — 此项为默认选项，可以让 OpenCore 内置的启动选择器按照 启动磁盘 偏好设置中指定的方式加载默认的启动项。 ShowPicker — 此项会强制显示启动选择器，通常可以在启动时按住 OPT 键来实现。将 ShowPicker 设置为 true 会使 ShowPicker 成为默认选项。 ResetNvram — 此项会擦除 UEFI 变量，通常是在启动时按住 CMD+OPT+P+R 组合键来实现。另一种擦除 UEFI 变量的方法是在选择器中选择 Reset NVRAM，要使用这种方式需要将 AllowNvramReset 设置为 true。 BootApple — 此项会启动到第一个找到的 Apple 操作系统，除非 Apple 已经默认选择了操作系统。按住 X 来选择此选项。 BootAppleRecovery — 此项会启动到 Apple 操作系统的恢复系统。这里的系统要么是「与默认选中的操作系统相关的恢复系统」，要么是「第一个找到的非 Apple 的默认操作系统的恢复系统」，要么是「无恢复系统」。按住 CMD+R 组合键来选择此选项。 注 1：需要激活 KeySupport、OpenUsbKbDxe 或类似的驱动程序才能工作。无法获得全部按键功能的固件有很多。 注 2：当禁用 ShowPicker 时，除了 OPT 键之外，OpenCore 还支持 Escape 键来显示启动选项。这个键不仅适用于 Apple 启动选择器模式，也适用于 PS/2 键盘的固件，因为这种键盘无法提交按住 OPT 键的请求，需要连续点按 Escape 键来进入启动选择菜单。 注 3：有些 Mac 的 GOP 很棘手，可能很难进入 Apple 启动选择器。要解决这个问题，可以在不加载 GOP 的情况下 bless OpenCore 的 BootKicker 实用工具。 8.4 Debug PropertiesAppleDebugType: plist booleanFailsafe: falseDescription: 启用将 boot.efi 调试日志保存到 OpenCore 日志。 注：此项仅适用于 10.15.4 和更新版本。 ApplePanicType: plist booleanFailsafe: falseDescription: 将 macOS Kernel Panic 保存到 OpenCore 根分区。 保存的文件为 panic-YYYY-MM-DD-HHMMSS.txt。强烈建议使用 keepsyms=1 引导参数来查看 Panic 日志中的调试符号。如果没有，可以用 kpdescribe.sh 实用程序（OpenCore 绑定）来部分恢复堆栈跟踪。 开发者内核和调试内核会产生更有用的 Kernel Panic。调试的时候，可以考虑从 developer.apple.com 下载并安装 KernelDebugKit。如果要激活开发者内核，需要添加一个 kcsuffix=development 引导参数。使用 uname -a 命令来确保你当前加载的内核是一个开发者（或调试）内核。 如果没有实用 OpenCore 的 Kernel Panic 保存机制，仍然可以在 /Library/Logs/DiagnosticReports 目录下找到 Panic 日志。从 macOS Catalina 开始，Kernel Panic 会以 JSON 格式储存，所以在传递给 kpdescribe.sh 之前需要预处理： DisableWatchDogType: plist booleanFailsafe: falseDescription: 某些固件可能无法成功快速启动操作系统，尤其是在调试模式下，这会导致看门狗定时器中止引导过程。此选项关闭看门狗定时器，用于排错。 DisplayDelayType: plist integerFailsafe: 0Description: 屏幕上打印每行输出之间的延迟。 DisplayLevelType: plist integer, 64 bitFailsafe: 0Description: 与屏幕显示相关的 EDK II 调试级别的位掩码（总和）。除非 Target 启用了控制台在屏幕上输出日志，否则屏幕上的调试输出将不可见。支持以下级别（更多信息参见 DebugLib.h）： 0x00000002 (bit 1) — DEBUG_WARN in DEBUG, NOOPT, RELEASE. 0x00000040 (bit 6) — DEBUG_INFO in DEBUG, NOOPT. 0x00400000 (bit 22) — DEBUG_VERBOSE in custom builds. 0x80000000 (bit 31) — DEBUG_ERROR in DEBUG, NOOPT, RELEASE. SysReportType: plist booleanFailsafe: falseDescription: 在 EFI 分区中保存系统报告。 启用这一选项后，EFI 分区中将会新建一个 SysReport 目录。这一目录中将会保存 ACPI 和 SMBIOS 的调试信息。 注：基于安全的考虑，Release 构建的 OpenCore 将不会内置这一功能。如果需要使用这一功能请使用 Debug 构建版。 TargetType: plist integerFailsafe: 0Description: 启用日志记录目标的位掩码（总和）。默认所有日志的输出都是隐藏的，所以当需要调试时，有必要设置这个选项。 支持以下日志记录目标： 0x01 (bit 0) — 启用日志记录，否则所有日志都会被丢弃 0x02 (bit 1) — 在屏幕上输出日志 0x04 (bit 2) — 启用把日志记录到 Data Hub 0x08 (bit 3) — 启用串行端口记录 0x10 (bit 4) — 启用 UEFI 变量记录 0x20 (bit 5) — 启用非易失性 UEFI 变量记录 0x40 (bit 6) — 启用在 ESP 分区生成日志文件 控制台日志会比其他日志少，根据 build 类型（RELEASE、DEBUG 或 NOOPT）的不同，读取到的日志量也会不同（从最少到最多）。 Data Hub 日志中不包括 Kernel 和 Kext 的日志。要获取 Data Hub 日志，请使用 ioreg： UEFI 变量日志中不包含某些信息，也没有性能数据。为了安全起见，日志大小被限制在 32 KB。有些固件可能会提前截断它，或者在它无内存时完全删除它。使用非易失性 flag 将会在每打印一行后把日志写入 NVRAM 闪存。如要获取 UEFI 变量日志，请在 macOS 中使用以下命令： 警告：有些固件的 NVRAM 垃圾收集据说存在问题，它们可能无法做到在每次变量删除后都释放空间。在这类设备上，没有额外需要的话，请不要使用非易失性 NVRAM 日志。 虽然 OpenCore 的引导日志已经包含了基本的版本信息（包括 build 类型和日期），但即使在禁用引导日志的情况下，这些数据也可以在 NVRAM 中的 opencore-version 变量中找到。 文件记录会在 EFI 卷宗的根目录下创建一个名为 opencore-YYYY-MM-DD-HHMMSS.txt 的文件，其中包含了日志的内容（大写字母部分会被替换为固件中的日期和时间）请注意，固件中的一些文件系统驱动程序不可靠，并且可能会通过 UEFI 写入文件时损坏数据。日志是尝试用最安全的方式来写入的，因此速度很慢。当你使用慢速硬盘时，请确保已将 DisableWatchDog 设置为 true。 When interpreting the log, note that the lines are prefixed with a tag describing the relevant location (module) of the log line allowing one to better attribute the line to the functionality. The list of currently used tags is provided below. Drivers and tools: BMF — OpenCanopy, bitmap font BS — Bootstrap GSTT — GoptStop HDA — AudioDxe KKT — KeyTester MMDD — MmapDump OCPAVP — PavpProvision OCRST — ResetSystem OCUI — OpenCanopy OC — OpenCore main VMOPT — VerifyMemOpt Libraries: AAPL — OcDebugLogLib, Apple EfiBoot logging OCABC — OcAfterBootCompatLib OCAE — OcAppleEventLib OCAK — OcAppleKernelLib OCAU — OcAudioLib OCAV — OcAppleImageVerificationLib OCA —- OcAcpiLib OCBP — OcAppleBootPolicyLib OCB — OcBootManagementLib OCCL — OcAppleChunkListLib OCCPU — OcCpuLib OCC — OcConsoleLib OCDH — OcDataHubLib OCDI — OcAppleDiskImageLib OCFSQ — OcFileLib, UnblockFs quirk OCFS — OcFileLib OCFV — OcFirmwareVolumeLib OCHS — OcHashServicesLib OCIC — OcImageConversionLib OCII — OcInputLib OCJS — OcApfsLib OCKM — OcAppleKeyMapLib OCL — OcDebugLogLib OCMCO — OcMachoLib OCME — OcHeciLib OCMM — OcMemoryLib OCPI — OcFileLib, partition info OCPNG — OcPngLib OCRAM — OcAppleRamDiskLib OCRTC — OcRtcLib OCSB — OcAppleSecureBootLib OCSMB — OcSmbiosLib OCSMC — OcSmcLib OCST — OcStorageLib OCS — OcSerializedLib OCTPL — OcTemplateLib OCUC — OcUnicodeCollationLib OCUT — OcAppleUserInterfaceThemeLib OCXML — OcXmlLib 8.5 Security PropertiesAllowNvramResetType: plist booleanFailsafe: falseDescription: 启用这一选项后将允许使用 CMD+OPT+P+R 快捷键重置 NVRAM，同时 NVRAM Reset 条目也会出现在开机引导菜单中。 AllowSetDefaultType: plist booleanFailsafe: falseDescription: 允许使用 CTRL+Enter 和 CTRL+[数字] 设置默认启动项。 AuthRestartType: plist booleanFailsafe: falseDescription: 启用与 VirtualSMC 兼容的 authenticated restart。 authenticated restart 可以在重启 FileVault2 分区时不用再次输入密码。你可以使用下述指令执行一次 authenticated restart：sudo fdesetup authrestart。macOS 在安装系统更新使用的也是 authenticated restart。 VirtualSMC 通过将磁盘加密密钥拆分保存在 NVRAM 和 RTC 中来执行 authenticated restart。虽然 OpenCore 在启动系统后立刻删除密钥，但是这仍然可能被视为安全隐患。 BlacklistAppleUpdateType: plist booleanFailsafe: falseDescription: Ignore boot options trying to update Apple peripheral firmware. (e.g. MultiUpdater.efi). BootProtectType: plist stringFailsafe: NoneDescription: 该选项试图保证 Bootloader 的持久性、一致性。 可以使用的值有： None: 什么都不做 Bootstrap: 在启动引导程序时，在 UEFI 变量存储中创建或更新最高优先级 \\EFI\\OC\\Bootstrap\\Bootstrap.efi 引导选项 (Boot9696)。要使用这个选项，必须同时开启 RequestBootVarRouting。 在安装和升级第三方操作系统时 \\EFI\\BOOT\\BOOTx64.efi 文件可能会被覆盖掉，该选项则保证了出现覆盖情况时 Bootloader 的一致性。在 Bootstrap 模式下创建一个自定义启动项后，\\EFI\\BOOT\\BOOTx64.efi 这个文件路径将不再用于引导 OpenCore。 注 1：某些固件的 NVRAM 本身存在问题，可能会出现无启动项支持，或者其他各种不兼容的情况。虽然可能性不大，但使用此选项可能会导致启动失败。请在已知兼容的主板上使用，风险自行考虑。 注 2：请注意，NVRAM 重置也会同时清除 Bootstrap 模式下创建的启动选项。 ExposeSensitiveDataType: plist integerFailsafe: 0x6Description: 用于向操作系统暴露敏感数据的位掩码（总和）。 0x01 — 将可打印的引导器路径作为 UEFI 变量暴露出来 0x02 — 将 OpenCore 版本作为 UEFI 变量暴露出来 0x04 — 将 OpenCore 版本暴露在启动选择菜单的标题位置 0x08 — 将 OEM 信息作为一组 UEFI 变量暴露出来 根据加载顺序，暴露的启动器路径指向 OpenCore.efi 或其引导器。如要获得引导器路径，请在 macOS 中使用以下命令： 如要使用启动器路径加载启动器卷宗，请在 macOS 中使用以下命令： 如要获取 OpenCore 版本信息，请在 macOS 中使用以下命令： 如要获取 OEM 信息，请在 macOS 中使用以下命令： HaltLevelType: plist integer, 64 bitFailsafe: 0x80000000 (DEBUG_ERROR)Description: EDK II 调试级别的位掩码（总和），使 CPU 在获得 HaltLevel 消息后中止（停止执行）。可能的值与 DisplayLevel 值相匹配。 VaultType: plist stringFailsafe: SecureDescription: 启用 OpenCore 的 vault 机制。 有效值： Optional — 无要求，vault 不加载，不安全。 Basic — 需要有 vault.plist 文件存放在 OC 目录下。这个值提供了基本的文件系统完整性验证，可以防止无意中的文件系统损坏。 Secure — 需要有 vault.sig 签名的 vault.plist 文件存放在 OC 目录下。这个值包括了 Basic 完整性检查，但也会尝试建立一个可信的引导链。 vault.plist 文件应该包含 OpenCore 使用的所有文件的 SHA-256 哈希值。强烈建议使用这个文件，以确保无意中的文件修改（包括文件系统损坏）不会被忽视。要自动创建这个文件，请使用 create_vault.sh 脚本。无论底层的文件系统如何，路径名和大小写必须在 config.plist 和 vault.plist 之间相匹配。 vault.sig 文件应该包含一个来自 vault.plist SHA-256 哈希值的原始的 256 字节 RSA-2048 签名。这个签名是根据嵌入到 OpenCore.efi 中的公钥来验证的。如要嵌入公钥，以下任一步骤均可： 在 OpenCore.efi 编译过程中，在 OpenCoreVault.c 文件中提供公钥。 用二进制补丁的方式将 OpenCore.efi 中 =BEGIN OC VAULT= 和 ==END OC VAULT== ASCII 码之间的 0 替换为公钥。 RSA 公钥的 520 字节格式可参阅 Chromium OS 文档。如要从 X.509 证书或 PEM 文件中转换公钥，请使用 RsaTool。 以下操作的完整指令： 创建 vault.plist 创建一个新的 RSA 密钥（总是要这样做，以避免加载旧配置） 将 RSA 密钥嵌入到 OpenCore.efi 创建 vault.sig 可以参照如下指令： 注 1：必须使用外部方法来验证 OpenCore.efi 和 BOOTx64.efi 的安全启动路径，尽管它们看似显而易见。为此，建议你至少使用自定义证书来启用 UEFI 的 SecureBoot，并使用自定义的密钥来签名 OpenCore.efi 和 BOOTx64.efi 。关于在现代固件上定制安全启动的更多细节，请参见 Taming UEFI SecureBoot（俄文）。 注 2：当 vault.plist 存在，或者当公钥嵌入到 OpenCore.efi 中的时候，无论这个选项是什么，vault.plist 和 vault.sig 都会被使用。设置这个选项仅仅会确保配置的合理性，否则启动过程会中止。 ScanPolicyType: plist integer, 32 bitFailsafe: 0xF0103Description: 定义操作系统检测策略。 通过设置该值来根据所选 flag 的位掩码（总和）防止从非信任源扫描（和启动）。由于不可能可靠地检测到每一个文件类型或设备类型，因此在开放环境中不能完全依赖此功能，需要采取额外的措施。 第三方驱动程序可能会根据提供的扫描策略引入额外的安全（和性能）措施。扫描策略暴露在 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102 GUID的 scan-policy 变量中，仅适用于 UEFI 启动服务。 0x00000001 (bit 0) — OC_SCAN_FILE_SYSTEM_LOCK，将扫描限制于仅扫描此策略定义的已知文件系统。文件系统驱动可能感知不到这个策略，为了避免挂载不必要的文件系统，最好不要加载它的驱动程序。此 bit 不影响 dmg 挂载，因为它可能有各种文件系统。已知文件系统的前缀为 OC_SCAN_ALLOW_FS_。 0x00000002 (bit 1) — OC_SCAN_DEVICE_LOCK，将扫描限制于仅扫描此策略定义的已知设备类型。由于协议隧道并不一定能被检测到，因此请注意，在某些系统上可能会出现 USB 硬盘被识别成 SATA 等情况。如有类似情况，请务必报告。已知设备类型的前缀为 OC_SCAN_ALLOW_DEVICE_。 0x00000100 (bit 8) — OC_SCAN_ALLOW_FS_APFS，允许扫描 APFS 文件系统。 0x00000200 (bit 9) — OC_SCAN_ALLOW_FS_HFS，允许扫描 HFS 文件系统。 0x00000400 (bit 10) — OC_SCAN_ALLOW_FS_ESP，允许扫描 EFI 系统分区文件系统。 0x00000800 (bit 11) — OC_SCAN_ALLOW_FS_NTFS，允许扫描 NTFS（MSFT Basic Data）文件系统。 0x00001000 (bit 12) — OC_SCAN_ALLOW_FS_EXT，允许扫描 EXT（Linux Root）文件系统。 0x00010000 (bit 16) — OC_SCAN_ALLOW_DEVICE_SATA，允许扫描 SATA 设备。 0x00020000 (bit 17) — OC_SCAN_ALLOW_DEVICE_SASEX，允许扫描 SAS 和 Mac NVMe 设备。 0x00040000 (bit 18) — OC_SCAN_ALLOW_DEVICE_SCSI，允许扫描 SCSI 设备。 0x00080000 (bit 19) — OC_SCAN_ALLOW_DEVICE_NVME，允许扫描 NVMe 设备。 0x00100000 (bit 20) — OC_SCAN_ALLOW_DEVICE_ATAPI，允许扫描 CD/DVD 设备。 0x00200000 (bit 21) — OC_SCAN_ALLOW_DEVICE_USB，允许扫描 USB 设备。 0x00400000 (bit 22) — OC_SCAN_ALLOW_DEVICE_FIREWIRE，允许扫描 FireWire 设备。 0x00800000 (bit 23) — OC_SCAN_ALLOW_DEVICE_SDCARD，允许扫描读卡器设备。 注：举例：根据以上描述，0xF0103 值允许扫描带有 APFS 文件系统的 SATA、SAS、SCSI 和 NVMe 设备，不扫描 USB、CD 和 FireWire 设备上的 APFS 文件系统，也不扫描任何带有 HFS 或 FAT32 文件系统的设备。该值表示如下组合： OC_SCAN_FILE_SYSTEM_LOCK OC_SCAN_DEVICE_LOCK OC_SCAN_ALLOW_FS_APFS OC_SCAN_ALLOW_DEVICE_SATA OC_SCAN_ALLOW_DEVICE_SASEX OC_SCAN_ALLOW_DEVICE_SCSI OC_SCAN_ALLOW_DEVICE_NVME 8.6 Entry PropertiesArgumentsType: plist stringFailsafe: Empty stringDescription: 对该引导条目使用的引导参数。 AuxiliaryType: plist booleanFailsafe: falseDescription: 当 HideAuxiliary 被启用时，这一值为 true 的引导条目将不会显示在开机引导菜单中。 CommentType: plist stringFailsafe: Empty stringDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 EnabledType: plist booleanFailsafe: falseDescription: 除非设置为 true，否则该引导条目不会显示在开机引导菜单中。 NameType: plist stringFailsafe: Empty stringDescription: 引导条目在开机引导菜单中显示的名字。 PathType: plist stringFailsafe: Empty stringDescription: 引导入口。 Entries 用于指定外部启动选项，因此会在 Path 中取设备路径。这些值不会被检查，所以要非常小心。例如：PciRoot(0x0)/Pci(0x1,0x1)/.../\\EFI\\COOL.EFI。 Tools 用于指定内部引导选项，这些选项隶属于 bootloader vault，因此会取相对于 OC/Tools 目录的文件路径。例如：OpenShell.efi。 "},{"title":"9. NVRAM","url":"/9-nvram.html","content":"9.1 Introduction设置易失性 UEFI 变量（通常被称作 NVRAM 变量），数据类型为 plist dict。使用 man nvram 获取详细信息。macOS 广泛使用 NVRAM 变量使 操作系统、BootLoader、固件 之间互通，因此需要提供多个 NVRAM 变量才能正常运行 macOS。 每个 NVRAM 变量均由其名称、值、属性（参考 UEFI 规范）以及 GUID 组成，表示 NVRAM 变量属于哪一区域。macOS 使用如下（包括但不限于）几种 GUID： 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14 (APPLE_VENDOR_VARIABLE_GUID) 7C436110-AB2A-4BBB-A880-FE41995C9F82 (APPLE_BOOT_VARIABLE_GUID) 8BE4DF61-93CA-11D2-AA0D-00E098032B8C (EFI_GLOBAL_VARIABLE_GUID) 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102 (OC_VENDOR_VARIABLE_GUID) 注：某些变量可以通过 PlatformNVRAM 或 PlatformInfo 节的 Generic 子节添加。请确保本节中的变量不会与它们发生冲突，否则可能导致未定义的行为。 为了使 macOS 正常运行，通常需要使用 OC_FIRMWARE_RUNTIME 协议。该协议的实现目前是 OpenRuntime（原名 FwRuntimeServices.efi）驱动程序的一部分。虽然可能带来一些好处，但根据用途不同也会存在某些限制。 并非所有工具都可能知道受保护的名称空间。当使用 RequestBootVarRouting 时，在独立的命名空间中会限制对 Boot 前缀的变量访问。要访问原始变量，工具必须了解 OC_FIRMWARE_RUNTIME 协议的工作原理。 9.2 Properties1. AddType: plist dictDescription: 从一组 GUID 映射（plist dict）中读取格式为 plist metadata 的变量映射，并将其添加到 NVRAM 中。GUID 必须以 Canonical String 格式提供，大写或小写均可（如 8BE4DF61-93CA-11D2-AA0D-00E098032B8C）。 创建的变量会设置 EFI_VARIABLE_BOOTSERVICE_ACCESS 和 EFI_VARIABLE_RUNTIME_ACCESS 的属性。变量只有在不存在且未被屏蔽的情况下才会被设置，也就是说，如果想要覆盖一个现有的变量值，请将该变量的名称添加到 Delete 部分，这种方法能够提供一个默认的值，直到操作系统接手为止。 注：如果 plist key 不符合 GUID 格式，则可能出现一些未定义的行为。 2. DeleteType: plist dictDescription: 从一组 GUID 映射（plist dict）读取一组包含 plist string 的数组（plist array），这些将会被从 NVRAM 变量中被删除。 3. LegacyEnableType: plist booleanFailsafe: falseDescription: 允许从 ESP 分区的根目录中的 nvram.plist 文件读取 NVRAM 变量。 该文件必须以 plist dictionary 为文件根格式，并包含以下两个字段： Version — plist integer，文件版本，必须设定为 1。 Add — plist dictionary，等同于 config.plist 中的 Add。 变量加载优先于 Delete（以及 Add）阶段。除非启用了 LegacyOverwrite，否则不会覆盖现有的任何变量。允许设置的变量必须指定于 LegacySchema 中。第三方脚本可以用来创建 nvram.plist 文件，脚本示例可参照 Utilities。使用第三方脚本可能要将 ExposeSensitiveData 设置为 0x3 来为 boot-path 变量提供 OpenCore EFI 分区的 UUID。 警告: 这一功能非常危险，因为会将不受保护的数据传递给固件中的变量服务。只有在你的硬件不提供硬件 NVRAM 或与之不兼容时才使用。 4. LegacyOverwriteType: plist booleanFailsafe: falseDescription: 允许用 nvram.plist 文件中的变量覆盖现有 NVRAM 中的变量。 注：只有操作系统访问的到的变量会被覆盖。 5. LegacySchemaType: plist dictDescription: 允许从 GUID 映射（plist dict）中选择 NVRAM 变量设置到一个变量名称数组（plist array），格式为 plist string。 可用 * 值来接受所有用来选择 GUID 的变量。 警告：选择变量要非常慎重，因为 nvram.plist 不会被存储。比如，不要把 boot-args 或 csr-active-config 放进去，因为会绕过 SIP。 6. WriteFlashType: plist booleanFailsafe: falseDescription: 允许将所有添加的变量写入闪存。 注：这个 Quirk 本应该在大多数固件上启用，但是由于可能存在 NVRAM 变量存储 GC 或类似的问题的固件，所以我们将这个 Quirk 设计为可配置的。 要从 macOS 中读取 NVRAM 变量的值，可以使用 nvram，并将变量 GUID 和名称用 : 符号隔开，形如 nvram 7C436110-AB2A-4BBB-A880-FE41995C9F82:boot-args。 变量列表可参照相关文档（持续更新）：NVRAM Variables。 9.3 Mandatory Variables警告：这些变量可通过 PlatformNVRAM 或 PlatformInfo 的 Generic 部分添加。推荐使用 PlatformInfo 来设置这些变量。 以下变量为 macOS 运行必需： 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:FirmwareFeatures32 位 FirmwareFeatures。存在于所有 Mac 上，用来避免额外解析 SMBIOS 表。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:FirmwareFeaturesMask32 位 FirmwareFeaturesMask。存在于所有 Mac 上，用来避免额外解析 SMBIOS 表。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:MLBBoardSerialNumber。存在于较新的 Mac 上（至少 2013 年以后），用来避免额外解析 SMBIOS 表，尤其是在 boot.efi 中。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ROM主要的网络适配器的 MAC 地址或替换值。存在于较新的 Mac（至少 2013 年以后）上，用来避免访问特殊内存区域，尤其是在 boot.efi 中。 9.4 Recommended Variables建议使用以下变量来加快启动速度或改善其他表现： 7C436110-AB2A-4BBB-A880-FE41995C9F82:csr-active-config32 位系统完整性保护的位掩码，声明于 XNU 源码 csr.h。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ExtendedFirmwareFeatures结合 FirmwareFeatures 和 ExtendedFirmwareFeatures。存在于较新的 Mac 上，用来避免额外解析 SMBIOS 表。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ExtendedFirmwareFeaturesMask结合 FirmwareFeaturesMask 和 ExtendedFirmwareFeaturesMask。存在于较新的 Mac 上，用来避免额外解析 SMBIOS 表。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_BID硬件 BoardProduct（如 Mac-35C1E88140C3E6CF）。在真正的 Mac 上不存在，但可用于避免额外解析 SMBIOS 表，尤其是在 boot.efi 中。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_MLB硬件 BoardSerialNumber。覆盖 MLB，存在于较新的 Mac 上（至少 2013 年以后）。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_ROM硬件 ROM。覆盖 ROM，存在于较新的 Mac 上（至少 2013 年以后）。 7C436110-AB2A-4BBB-A880-FE41995C9F82:prev-lang:kbd定义默认键盘布局的 ASCII 字符串。格式为 lang-COUNTRY:keyboard，例如 ru-RU:252 代表俄语和 ABC 键盘。也接受简短形式：ru:252 或 ru:0（美国键盘，兼容 10.9）。完整的键盘列表解码来自 AppleKeyboardLayouts-L.dat，可前往这里查看。与之前或之后的 macOS 版本不同，在 10.14 上，使用非拉丁语键盘将无法启用 ABC 键盘，因此假如你需要使用 10.14 版本则不建议你使用这一变量。 7C436110-AB2A-4BBB-A880-FE41995C9F82:security-mode定义 FireWire 安全模式的 ASCII 字符串。这一变量旧版本才有，可在 IOFireWireController.cpp 中的 IOFireWireFamily 源码里找到。建议不要设置这个变量，这样可能会加快启动速度。设置为 full 等同于不设置该变量，设置为 none 将禁用 FireWire 安全性。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:UIScale定义 boot.efi 用户界面缩放比例的一字节数据。普通屏幕应为 01，HiDPI 屏幕应为 02。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:DefaultBackgroundColor定义 boot.efi 用户界面背景色的四字节 BGRA 数据。标准色包括 BF BF BF 00（浅灰）和 00 00 00 00（西拉黑）。其他颜色可根据用户喜好设置。 9.5 Other Variables以下变量对于某些特定的配置或进行故障排除可能会很有用： 7C436110-AB2A-4BBB-A880-FE41995C9F82:boot-args 内核参数，用于将配置传递给 Apple 内核和驱动程序。很多参数可以通过在内核或驱动程序代码中寻找 PE_parse_boot_argn 函数找到。已知的引导参数包括： acpi_layer=0xFFFFFFFF acpi_level=0xFFFF5F — 表示 ACPI_ALL_COMPONENTS batman=VALUE — AppleSmartBatteryManager 调试掩码 batman-nosmc=1 — 禁用 AppleSmartBatteryManager SMC 接口 cpus=VALUE — 最大可用 CPU 数量 debug=VALUE — Debug 掩码 io=VALUE — IOKit 调试掩码 keepsyms=1 — 显示 Panic 日志调试符号 kextlog=VALUE — Kext 调试掩码 nv_disable=1 — 禁用 NVIDIA GPU 加速 nvda_drv=1 — 启用 NVIDIA web driver 的传统方法，这一参数在 macOS 10.12 中被去除 npci=0x2000 — 旧方法 禁用 kIOPCIConfiguratorPFM64 lapic_dont_panic=1 slide=VALUE — 手动设置 KASLR 偏移值 smcdebug=VALUE — AppleSMC 调试掩码 -amd_no_dgpu_accel — 替代 WhateverGreen 的 -radvesa，用于较新的 GPUs -nehalem_error_disable -no_compat_check — 禁用机型检查 -s — 单用户模式 -v — 啰嗦模式 -x — 安全模式 这里有一些网站收集了 macOS 内置的启动参数列表：列表 1、列表 2. 7C436110-AB2A-4BBB-A880-FE41995C9F82:bootercfgBooter 参数，类似于 boot-args，但用于 boot.efi 。接受参数为一组十六进制的 64 位值，带或不带 0x。在不同阶段，boot.efi 会请求不同的调试（日志）模式（例如，在 ExitBootServices 之后它只会打印到串行调试接口）。有些 Booter 参数会控制这些请求是否成功。下面是已知请求的列表： 0x00 – INIT 0x01 – VERBOSE （如 -v，强制控制台记录日志） 0x02 – EXIT 0x03 – RESET:OK 0x04 – RESET:FAIL （如未知的 board-id，休眠错配，Panic 循环，等等） 0x05 – RESET:RECOVERY 0x06 – RECOVERY 0x07 – REAN:START 0x08 – REAN:END 0x09 – DT （不再将日志记录到设备树） 0x0A – EXITBS:START （仅强制的串行调试接口） 0x0B – EXITBS:END （仅强制的串行调试接口） 0x0C – UNKNOWN 在 10.15 中，由于某种重构和 新调试协议 的引入，10.15.4 之前的调试支持基本上不能用了。下面的一些参数和值可能不适用于 10.15.4 之前的版本。以下是已知参数的列表： boot-save-log=VALUE — 正常启动时的调试日志保存模式 0 1 2 — 默认 3 4 — 保存到文件 wake-save-log=VALUE — 休眠唤醒时的调试日志保存模式 0 — 禁用 1 2 — 默认 3 — 不可用 4 — 保存到文件，不可用 breakpoint=VALUE — 调试中断相关（在产品 boot.efi 中缺少） 0 — 禁用错误时的调试中断（默认） 1 — 启用错误时的调试中断 console=VALUE — 启用控制台日志记录 0 — 禁用控制台日志记录 1 — 当缺少调试协议时，启用控制台日志记录（默认） 2 — 无条件启用控制台日志记录（不可用） embed-log-dt=VALUE — 设备树日志记录相关 0 — 禁用设备树日志记录 1 — 启用设备树日志记录 kc-read-size=VALUE — 用于网络或磁盘缓冲 I/O 的数据块大小，用于预链接内核读取和相关用途。默认设置为 1MB(0x100000)，可以通过调整使启动更快 log-level=VALUE — 日志等级位掩码 0x01 — 启用跟踪记录（默认） serial=VALUE — 串行控制台日志记录相关 0 — 禁用串行日志记录（默认） 1 — 从 EXITBS:END 开始启用串行日志记录 1 — 从 EXITBS:START 开始启用串行日志记录 3 — 当缺少调试协议时，启用串行日志记录 4 — 无条件启用串行日志记录 timestamps=VALUE — 时间戳日志记录相关 0 — 禁用时间戳记录 1 — 启用时间戳记录（默认） log=VALUE — 10.15 开始弃用 注：如要查看现代 macOS 版本上的 boot.efi verbose 输出，请启用 AppleDebug 选项。这样会把日志保存到通用 OpenCore 日志中。对于 10.15.4 之前的版本，将 bootercfg 设置为 log=1，可以将 verbose 输出打印在屏幕上。 7C436110-AB2A-4BBB-A880-FE41995C9F82:efiboot-perf-record启用 boot.efi 中的性能日志保存功能。性能日志会被保存到物理内存中，并通过 efiboot-perf-record-data 和 efiboot-perf-record-size 变量进行指向。从 10.15.4 开始，它也可以通过 AppleDebug 选项保存到 OpenCore 日志中。 7C436110-AB2A-4BBB-A880-FE41995C9F82:bootercfg-once在首次启动后删除 Booter 参数覆盖，否则等同于 bootercfg。 7C436110-AB2A-4BBB-A880-FE41995C9F82:fmm-computer-name当前保存的主机名称，格式为 ASCII 字符串。 7C436110-AB2A-4BBB-A880-FE41995C9F82:nvda_drvNVIDIA Web Driver 的控制变量。用 ASCII 数字 1 来启用或用 0 来禁用已安装的驱动程序。 7C436110-AB2A-4BBB-A880-FE41995C9F82:StartupMute开机时禁用固件引导提示音。8 进制整数。0x00 指代不静音、其他任何值（或缺少该值）表示静音。这一选项只影响带 T2 的机器。 7C436110-AB2A-4BBB-A880-FE41995C9F82:SystemAudioVolume固件音频支持的系统音频音量等级。8 进制整数。0x80 指代静音。低位用于编码安装的音频编码解码器的音量范围。该值以 MaximumBootBeepVolume AppleHDA layout 值为上限，以避免固件中的音频播放声音过大。 "},{"title":"OpenCore 简体中文参考手册","url":"/","content":" OpenCore 参考手册 阅读须知你现在访问的是由 非官方 维护的 OpenCore 参考手册的简体中文翻译（以下简称本网站）。 本网站以及网站的维护人员和 OpenCore 的开发团队 acidanthera 以及 OpenCore 的文档版权所有者 vit9696 没有任何关系。本网站对 OpenCore 的 Logo（商标）的使用已经过 acidanthera 的授权。 由于 OpenCore 仍处于积极的维护之中，OpenCore 参考手册 仍然在高频率更新，本网站提供的内容 仅可供参考。本网站的内容和 OpenCore 官方的参考手册的任何出入，请以 OpenCore 官方的参考手册为准。 本网站提供的翻译基于如下描述的 OpenCore 官方文档： OpenCore 文档释出日期：2020.06.01 OpenCore 文档版本：d818c6012a128584cfb9149ebeab07c8d2e87b85 本网站提供的翻译适用于如下描述的 OpenCore 版本： OpenCore 版本：0.6.0 本网站以及 acidanthera 不会对因本网站引起的任何损失负责，包括但不限于 Kernel Panic、设备无法开机或正常使用、硬盘损坏或数据丢失、原子弹爆炸、第三次世界大战、SCP 基金会 无法阻止的全球 CK 级现实重构等。 有用的链接 OpenCore 官方文档 OpenCore 官方文档迭代 OpenCore Vanilla Guide — 从零开始的 OpenCore 台式机安装指南。本网站由考虑提供对该指南的简体中文翻译 从 Clover 到 OpenCore — 由本网站的发起人和创始人 Sukka 编写的 Clover 迁移 OpenCore 的教程。 精解 OpenCore | 黑果小兵 — 本网站的部分翻译参考的就是黑果小兵前辈的这篇文章 使用 OpenCore 引导黑苹果 | Xjn’s Blog — 提供了很多台式机上排错和完善的指南 维护者OpenCore 简体中文参考手册 © Sukka. 由 Sukka 和 众多的贡献者 一起维护。"},{"title":"附录 1. OpenCore 兼容 Kext 列表","url":"/kextlist.html","content":"有线网卡 AppleRTL8169Ethernet — Realtek RTL8169 官方驱动，通过电子邮件发送下载链接 AtherosE2200Ethernet.kext — 高通 Atheros Killer E2200 系列驱动 AtherosL1cEthernet.kext — 高通 Atheros AR813x/815x 驱动 IntelMausi.kext — 由 Acidanthera 维护的英特尔有线网卡驱动 IntelMausiEthernet.kext — 由原作者（Mieze）英特尔有线网卡 NullEthernetInjector.kext — RehabMan 提供的仿冒内建网卡 RealtekR1000SL.kext — Realtek 8111B/C/D/E/EP/F/G/GU/8411B 系列驱动 RealtekRTL8100.kext — Realtek RTL810X 系列驱动 RealtekRTL8111.kext — Realtek RTL8111/8168 系列驱动 Wi-Fi 和蓝牙 AirPortAtheros40.kext — 高通 Atheros AR92xx/AR93xx 驱动，仅适用于 macOS 10.13.6 和 macOS 10.14+ AirportBrcmFixup.kext — 非苹果官方博通网卡修复 ATH9KFixup.kext — 高通 Atheros AR9xxx 无线网卡修复 BrcmPatchRAM.kext — 博通网卡蓝牙固件 BT4LEContinuityFixup.kext — IOBluetoothFamily 修补 IntelBluetoothFirmware — Intel 蓝牙固件驱动 MT7610 — 联发科 MT7610 官方驱动 RT5370 — 联发科 RT5370 官方驱动 RTL8192CU — Realtek RTL8192CU 驱动 译者注：上述链接为 Google Drive 分享，直链下载地址： macOS 10.6 macOS 10.9 键盘、鼠标和触摸设备 ApplePS2SmartTouchPad.kext — 触摸板和键盘 GK701HIDDevice.kext — 华硕 Fn 键、键盘背光灯和环境光传感器 驱动 NoTouchID.kext — 禁用 Touch ID 检测 SerialMouse.kext — 使用 Microsoft 串行鼠标协议的串行鼠标驱动 VoodooI2C.kext — I2C 触摸板/屏 驱动 VoodooPS2Controller.kext — PS2 键盘/触摸板 驱动 VoodooInput.kext — 为 PS2 键盘/触摸板 提供模拟 Magic TrackPad 2 触控模拟 VoodooSMBus.kext AlpsT4USB.kext — VoodooI2C 的卫星插件 kext，为 Alps T4 USB 触控板提供原生苹果手势支持。 音频和视频 AppleALC.kext — 定制声卡驱动 EMUUSBAudio.kext — 适用于 Creative Labs EMU USB 的驱动程序 kXAudioDriver.kext — 适用于 kX 音频设备的驱动 Nvidia CUDA drivers — NVIDIA CUDA 官方驱动 Nvidia Web-drivers — NVIDIA 显卡官方驱动 SNBGraphicsMojaveInstaller — 二代酷睿核显驱动，仅适用于 macOS 10.13.6 和 macOS 10.14+ VoodooHDA.kext — 万能声卡驱动 WhateverGreen.kext — 显卡补丁驱动 Polaris22Fixup.kext — Polaris22/VegaM 显卡修复 CPU 和 SMC AppleMCEReporterDisabler.kext AsusSMC.kext — 为 ASUS 笔记本电脑上的 ALS、键盘背光、Fn 键提供支持 VirtualSMC 插件 CPUFriend.kext - CPU 变频管理 FakeSMC.kext 以及配套传感器驱动 — Clover 官方的 FakeSMC HWPEnabler.kext — 启用 HWP 驱动 OpcodeEmulator.kext — Opcode 模拟驱动 TSCAdjustReset.kext — TSC 频率同步驱动 VirtualSMC.kext 以及配套传感器驱动 VoodooTSCSync.kext — 由 Rehabman 提供的 TSC 频率同步驱动 USB and other ports IOElectrify.kext — 在雷电 3 设备上启用常开电源 Legacy_InternalHub-EHCx.kext Legacy_USB3.kext NVMeFix.kext — 由 acidanthera 提供的改善第三方 SSD 兼容性的驱动程序 USBWakeFixup.kext — 修复 Skylake 平台 USB 唤醒黑屏 SASMegaRAID.kext — LSI MegaRAID SAS 系列 RAID 控制器驱动 Sinetek-rtsx.kext — Realtek RTSX SDHC 读卡器驱动 VoodooSDHC.kext — SDHC 读卡器驱动 Other kexts AppleIntelInfo.kext — CPU / 核显 变频测试 DebugEnhancer.kext — macOS 内核调试输出驱动 HibernationFixup.kext — 修复因 RTC 变量和 NVRAM 造成的睡眠问题 Lilu.kext — SDK &amp; Library LiluFriend.kext — 用于确保 Lilu 在 L/E 下正常加载 RTCMemoryFixup.kext — 修复 BIOS CMOS (RTC) 内存和 AppleRTC 之间的冲突问题 NightShiftEnabler.kext — 解锁 NightShift WebCamera.kext — 某些旧设备的摄像头驱动 TOSMotionSensor.kext — 东芝设备的加速度传感器驱动 "},{"title":"贡献指南","url":"/about/contributing.html","content":"目录结构文档所有文件位于 source 下。 about 目录：关于项目自身的文档，如你现在看到的「贡献指南」的 md 源文件就位于这个目录下 guide 目录：如果未来项目开始收录 OpenCore 指南类的文章，就将相关的 md 文件放在这个目录下 img 目录：存放文档中使用的图片 logo 目录：存放 OpenCore 的 Logo 和网站的 favicon CNAME 文件：GitHub Pages 绑定自定义域名 index.md 文件：网站首页的 md 源文件 其余 .md 文件：经过整理的 OpenCore 参考手册的 md 源文件（需要翻译的就是这些文件） Markdown 文件的 Front-Matter 的字段说明 当你完成了对一个文件的整理、翻译后，别忘了修改 author_info 和 last_updated 两个字段！ Commit Message 规范 type init: Initialization 初始化项目、模块、组件 docs: Documentation 文档（包括 README 的更新） revert: Revert 代码回退，用于撤回某个改动 feat: New feature 新功能 fix: Fix bug 修补 bug style: Format 格式（不影响代码运行的变动） refactor: Refactor 重构（即不是新增功能，也不是修改 bug 的代码变动） test: Test 测试相关 workflow: WorkFlow 工作流相关 chore: 构建过程或辅助工具的变动 merge: 合并 Pull Request ci: 持续集成和构建相关 允许多个 type 的使用，如修复文档中的 Typo 可以用 docs/type 作为 type。 scope scope 用于说明 commit 影响的范围（一般取修改的文件的名称），紧接 type 置于 () 之内。 scope 非必须，当改动代码范围较大或者范围不明确时可忽略。 当使用 Merge Pull Request 合并不同分支时，scope 为 PR 在 GitHub 上的编号；当使用 revert 回退代码时，scope 为对应 commit 的 Title，也可以是简短的介绍。 subject subject 是 commit 目的的简短描述，不超过 50 个字符。 以动词开头 使用第一人称现在时比如 change，尽可能避免使用 changed 或 changes 首字母小写，并且 尽可能 subject 全部小写 结尾不加句号 . 当 type 是 merge 时，subject 应为 from {base branch name} into {target branch name} body Body 部分是 可选的 对本次 commit 的详细描述，可以分成多行。下面是一个范例。 和 title.subject 不同，Body 的要求如下： Body 是可选、非必须的 使用第一人称现在时比如 change，尽可能避免使用 changed 或 changes 应该说明代码变动的动机，以及与以前行为的对比。 如果使用 Squash 合并分支时，Body 为以无序列表排列的对应多条 commit 记录。 其他参考资料 Hexo 文档 hexo-theme-doku 文档 "}]