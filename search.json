[{"title":"1. 简介","url":"/1-introduction.html","content":"本文档提供关于 OpenCore 用户配置文件的信息，以使 macOS 操作系统正常工作。你应当视本文档为 OpenCore 预期行为的解释。如果在已经发布的 OpenCore 版本中找到与文档中的描述存在偏差的行为，应当视为 OpenCore 存在 Bug 或文档出现错误，应通过 Acidanthera Bugtracker 进行反馈。本文档所有其他来源或翻译都是非官方的，并且可能存在错误。 译者注： 此处以及之后的「本文档」都指代 OpenCore 的官方文档（而非你现在访问的网站）。 你应当使用英语在 Acidanthera Bugtracker 进行反馈。 本文档仅作为规范结构、并非用于提供手把手的配置教程。这类材料（译者注：即「手把手的配置教程」）都容易收到其作者的喜好和品位、对本文档的误解、过时的理解等。如果您仍然在使用这些资料来源，例如 OpenCore Vanilla Guide，请务必在参考本文档后再作出每个决定、并判断其后果。无论使用哪种来源，你都必须全面了解每种专用工具。 在通过 Acidanthera Bugtracker 反馈任何问题之前，请确保你彻底理解了 OpenCore 的每个配置选项及其对应的概念。 1.1 通用术语 plist — Subset of ASCII Property List format written in XML, also know as XML plist format version 1. Uniform Type Identifier (UTI): com.apple.property-list. Plists consist of plist objects, which are combined to form a hierarchical structure. Due to plist format not being well-defined, all the definitions of this document may only be applied after plist is considered valid by running plutil -lint. External references: , man plutil. plist type — plist collections (plist array, plist dictionary, plist key) and primitives (plist string, plist data, plist date, plist boolean, plist integer, plist real). plist object — definite realisation of plist type, which may be interpreted as value. plist array — array-like collection, conforms to array. Consists of zero or more plist\\ objects. plist dictionary — map-like (associative array) collection, conforms to dict. Consists of zero or more plist\\ keys. plist key — contains one plist object going by the name of plist key, conforms to key. Consists of printable 7-bit ASCII characters. plist string — printable 7-bit ASCII string, conforms to string. plist data — base64-encoded blob, conforms to data. plist date — ISO-8601 date, conforms to date, unsupported. plist boolean — logical state object, w hich is either true (1) or false (0), conforms to true and false. plist integer — possibly signed integer number in base 10, conforms to integer. Fits in 64-bit unsigned integer in two’s complement representation, unless a smaller signed or unsigned integral type is explicitly mentioned in specific plist object description. plist real — floating point number, conforms to real, unsupported. plist metadata — value cast to data by the implementation. Permits passing plist string, in which case the result is represented by a null-terminated sequence of bytes (aka C string),plist integer, in which case the result is represented by 32-bit little endian sequence of bytes in two’s complement representation, plist boolean, in which case the value is one byte: 01 for true and 00 for false, and plist data itself. All other types or larger integers invoke undefined behaviour. "},{"title":"10. PlatformInfo","url":"/10-platform-info.html","content":"机型信息由手动生成、填充以与 macOS 服务兼容的几个标识字段组成。配置的基础部分可以从 MacInfoPkg、一个可以从 YAML 格式的数据库中生成一组接口的工具包中获得。这些字段将会被写入三个位置： SMBIOS DataHub NVRAM 大多数字段在 SMBIOS 中指定覆盖，并且这些字段的名称符合 EDK2 SmBios.h 头文件。但是，在 Data Hub 和 NVRAM 中有几个重要的字段。有些值可以在多个字段 和/或 目标中找到，因此有两种方法可以控制它们的更新过程：手动指定所有值（默认方法）；半自动。 可以使用 dmidecode 工具来检查 SMBIOS 内容。你可以从 Acidanthera/dmidecode 下载 Acidanthera 制作的增强版。 10.1 Properties1. AutomaticType: plist booleanFailsafe: falseDescription: 基于 Generic 属性而不是 DataHub、NVRAM 和 SMBIOS 属性生成机型信息。 当 Generic 属性足够灵活的时候，这一选项将会变得非常有用。启用这一选项后，DataHub、NVRAM 和 SMBIOS 的数据不会再被使用。 2. UpdateDataHubType: plist booleanFailsafe: falseDescription: 更新 Data Hub 字段。根据 Automatic 的值，这些字段会从 Generic 或 DataHub 中读取。 3. UpdateNVRAMType: plist booleanFailsafe: falseDescription: 是否更新 NVRAM 中关于机型信息的相关字段。 根据 Automatic 的值，这些字段会从 Generic 或 PlatformNVRAM 中读取。所有其他字段都将在 NVRAM 部分中指定。 如果将此值设置为 false，则可以使用 nvram 部分更新上述变量；反之若将此值设置为 true，而同时 nvram 部分存在任何字段，会产生意料之外的行为。 4. UpdateSMBIOSType: plist booleanFailsafe: falseDescription: 更新 SMBIOS 字段。根据 Automatic 的值，这些字段会从 Generic 或 SMBIOS 中读取。 5. UpdateSMBIOSModeType: plist stringFailsafe: CreateDescription: Update SMBIOS fields approach: TryOverwrite — Overwrite if new size is &lt;= than the page-aligned original and there are no issues with legacy region unlock. Create otherwise. Has issues with some firmwares. Create — Replace the tables with newly allocated EfiReservedMemoryType at AllocateMaxAddress without any fallbacks. Overwrite — Overwrite existing gEfiSmbiosTableGuid and gEfiSmbiosTable3Guid data if it fits new size. Abort with unspecified state otherwise. Custom — Write first SMBIOS table (gEfiSmbiosTableGuid) to gOcCustomSmbiosTableGuid to workaround firmwares overwriting SMBIOS contents at ExitBootServices. Otherwise equivalent to Create. Requires patching AppleSmbios.kext and AppleACPIPlatform.kext to read from another GUID: &quot;EB9D2D31&quot; - &quot;EB9D2D35&quot; (in ASCII), done automatically by CustomSMBIOSGuid quirk. 6. GenericType: plist dictonaryOptional: When Automatic is falseDescription: Update all fields. This section is read only when Automatic is active. 7. DataHubType: plist dictonaryOptional: When Automatic is trueDescription: Update Data Hub fields. This section is read only when Automatic is not active. 8. PlatformNVRAMType: plist dictonaryOptional: When Automatic is trueDescription: Update platform NVRAM fields. This section is read only when Automatic is not active. 9. SMBIOSType: plist dictonaryOptional: When Automatic is trueDescription: Update SMBIOS fields. This section is read only when Automatic is not active. 10.2 Generic Properties1. SpoofVendorType: plist booleanFailsafe: falseDescription: 将 SMBIOS 中的 vendor 字段设置为 Acidanthera. 由于在 SystemManufacturer 相关介绍中介绍的原因，在 SMBIOS 的 vendor 字段中使用 Apple 是危险的。但是，某些固件可能无法提供有效值，可能会导致某些软件的破坏。 2. AdviseWindowsType: plist booleanFailsafe: falseDescription: 在 FirmwareFeatures 中强制提供 Windows 支持。 向 FirmwareFeatures 中添加如下比特： FW_FEATURE_SUPPORTS_CSM_LEGACY_MODE (0x1) - 如果没有此比特，且 EFI 分区不是硬盘中的第一个分区，那么则无法重新启动到硬盘里的 Windows 系统。 FW_FEATURE_SUPPORTS_UEFI_WINDOWS_BOOT (0x20000000) - 如果没有此比特，且 EFI 分区是硬盘中的第一个分区，那么则无法重新启动到硬盘里的 Windows 系统。 3. SystemProductNameType: plist stringFailsafe: MacPro6,1Description: 请参考下文 SMBIOS 章节中的 中的 SystemProductName. 4. SystemSerialNumberType: plist stringFailsafe: OPENCORE_SN1Description: 请参考下文 SMBIOS 章节中的 中的 SystemSerialNumber. 5. SystemUUIDType: plist string, GUIDFailsafe: OEM specifiedDescription: 请参考下文 SMBIOS 章节中的 中的 SystemUUID. 6. MLBType: plist stringFailsafe: OPENCORE_MLB_SN11Description: 请参考下文 SMBIOS 章节中的 中的 BoardSerialNumber. 7. ROMType: plist data, 6 bytesFailsafe: all zeroDescription: Refer to 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ROM. 10.3 DataHub Properties1. PlatformNameType: plist stringFailsafe: Not installedDescription: Sets name ingEfiMiscSubClassGuid. Value found on Macs is platform in ASCII. 2. SystemProductNameType: plist stringFailsafe: Not installedDescription: Sets Model in gEfiMiscSubClassGuid. Value found on Macs is equal to SMBIOS SystemProductName in Unicode. 3. SystemSerialNumberType: plist stringFailsafe: Not installedDescription: Sets SystemSerialNumber in gEfiMiscSubClassGuid. Value found on Macs is equal to SMBIOS SystemSerialNumber in Unicode. 4. SystemUUIDType: plist string, GUIDFailsafe: Not installedDescription: Sets system-id in gEfiMiscSubClassGuid. Value found on Macs is equal to SMBIOS SystemUUID. 5. BoardProductType: plist stringFailsafe: Not installedDescription: Sets board-id in gEfiMiscSubClassGuid. Value found on Macs is equal to SMBIOS BoardProduct in ASCII. 6. BoardRevisionType: plist data, 1 byteFailsafe: 0Description: Sets board-rev in gEfiMiscSubClassGuid. Value found on Macs seems to correspond to internal board revision (e.g. 01). 7. StartupPowerEventsType: plist integer, 64-bitFailsafe: 0Description: Sets StartupPowerEvents in gEfiMiscSubClassGuid. Value found on Macs is power management state bitmask, normally 0. Known bits read by X86PlatformPlugin.kext: 0x00000001 — Shutdown cause was a PWROK event (Same as GEN_PMCON_2 bit 0) 0x00000002 — Shutdown cause was a SYS_PWROK event (Same as GEN_PMCON_2 bit 1) 0x00000004 — Shutdown cause was a THRMTRIP#event (Same as GEN_PMCON_2 bit 3) 0x00000008 — Rebooted due to a SYS_RESET# event (Same as GEN_PMCON_2 bit 4) 0x00000010 — Power Failure (Same as GEN_PMCON_3 bit 1 PWR_FLR) 0x00000020 — Loss of RTC Well Power (Same as GEN_PMCON_3 bit 2 RTC_PWR_STS) 0x00000040 — General Reset Status (Same as GEN_PMCON_3 bit 9 GEN_RST_STS) 0xffffff80 — SUS Well Power Loss (Same as GEN_PMCON_3 bit 14) 0x00010000 — Wake cause was a ME Wake event (Same as PRSTS bit 0, ME_WAKE_STS) 0x00020000 — Cold Reboot was ME Induced event (Same as PRSTS bit 1 ME_HRST_COLD_STS) 0x00040000 — Warm Reboot was ME Induced event (Same as PRSTS bit 2 ME_HRST_WARM_STS) 0x00080000 — Shutdown was ME Induced event (Same as PRSTS bit 3 ME_HOST_PWRDN) 0x00100000 — Global reset ME Wachdog Timer event (Same as PRSTS bit 6) 0x00200000 — Global reset PowerManagment Wachdog Timer event (Same as PRSTS bit 15) 8. InitialTSCType: plist integer, 64-bitFailsafe: 0Description: Sets InitialTSC ingEfiProcessorSubClassGuid. Sets initial TSC value, normally 0. 9. FSBFrequencyType: plist integer, 64-bitFailsafe: AutomaticDescription: Sets FSBFrequency in gEfiProcessorSubClassGuid. Sets CPU FSB frequency. This value equals to CPU nominal frequency divided by CPU maximum bus ratio and is specified in Hz. Refer to MSR_NEHALEM_PLATFORM_INFO(CEh) MSR value to determine maximum bus ratio on modern Intel CPUs. 注：This value is not used on Skylake and newer but is still provided to follow suit. 10. ARTFrequencyType: plist integer, 64-bitFailsafe: AutomaticDescription: Sets ARTFrequency in gEfiProcessorSubClassGuid. This value contains CPU ART frequency, also known as crystal clock frequency. Its existence is exclusive to Skylake generation and newer. The value is specified in Hz, and is normally 24 MHz for client Intel segment, 25 MHz for server Intel segment, and 19.2 MHz for Intel Atom CPUs. macOS till 10.15 inclusive assumes 24 MHz by default. 注：On Intel Skylake X ART frequency may be a little less (approx. 0.25%) than 24 or 25 MHz due to special EMI-reduction circuit as described in Acidanthera Bugtracker. 11. DevicePathsSupportedType: plist integer, 32-bitFailsafe: Not installedDescription: Sets DevicePathsSupported in gEfiMiscSubClassGuid. Must be set to 1 for AppleACPIPlatform.kext to append SATA device paths to Boot#### and efi-boot-device-data variables. Set to 1 on all modern Macs. 12. SmcRevisionType: plist data, 6 bytesFailsafe: Not installedDescription: Sets REV in gEfiMiscSubClassGuid. Custom property read by VirtualSMC or FakeSMC to generate SMC REV key. 13. SmcBranchType: plist data, 8 bytesFailsafe: Not installedDescription: Sets RBr ingEfiMiscSubClassGuid. Custom property read by VirtualSMC or FakeSMC to generate SMC RBr key. 14. SmcPlatformType: plist data, 8 bytesFailsafe: Not installedDescription: Sets RPlt in gEfiMiscSubClassGuid. Custom property read by VirtualSMC or FakeSMC to generate SMC RPlt key. 10.4 PlatformNVRAM Properties1. BIDType: plist stringFailsafe: Not installedDescription: Specifies the value of NVRAM variable 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_BID. 2. ROMType: plist data, 6 bytesFailsafe: Not installedDescription: Specifies the values of NVRAM variables 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_ROM and 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ROM. 3. MLBType: plist stringFailsafe: Not installedDescription: Specifies the values of NVRAM variables 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_MLB and 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:MLB. 4. FirmwareFeaturesType: plist data, 8 bytesFailsafe: Not installedDescription: This variable comes in pair with FirmwareFeaturesMask.Specifies the values of NVRAM variables: 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:FirmwareFeatures 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ExtendedFirmwareFeatures 5. FirmwareFeaturesMaskType: plist data, 8 bytesFailsafe: Not installedDescription: This variable comes in pair with FirmwareFeatures. Specifies the values of NVRAM variables: 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:FirmwareFeaturesMask 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ExtendedFirmwareFeaturesMask 10.5 SMBIOS Properties1. BIOSVendorType: plist stringFailsafe: OEM specifiedSMBIOS: BIOS Information (Type 0) — VendorDescription: BIOS Vendor. SystemManufacturer 的所有规则都适用。 2. BIOSVersionType: plist stringFailsafe: OEM specifiedSMBIOS: BIOS Information (Type 0) — BIOS VersionDescription: Firmware version. This value gets updated and takes part in update delivery configuration and macOS version compatibility. This value could look like MM71.88Z.0234.B00.1809171422 in older firmwares, and is described in BiosId.h. In newer firmwares it should look like 236.0.0.0.0 or 220.230.16.0.0 (iBridge: 16.16.2542.0.0,0). iBridge version is read from BridgeOSVersion variable, and is only present on macs with T2. 3. BIOSReleaseDateType: plist stringFailsafe: OEM specifiedSMBIOS: BIOS Information (Type 0) — BIOS Release DateDescription: Firmware release date. Similar to BIOSVersion. May look like 12/08/2017. 4. SystemManufacturerType: plist stringFailsafe: OEM specifiedSMBIOS: System Information (Type 1) — ManufacturerDescription: OEM manufacturer of the particular board. Shall not be specified unless strictly required. Should not contain Apple Inc., as this confuses numerous services present in the operating system, such as firmware updates, eficheck, as well as kernel extensions developed in Acidanthera, such as Lilu and its plugins. In addition it will also make some operating systems like Linux unbootable. 5. SystemProductNameType: plist stringFailsafe: OEM specifiedSMBIOS: System Information (Type 1), Product NameDescription: Preferred Mac model used to mark the device as supported by the operating system. This value must be specified by any configuration for later automatic generation of the related values in this and other SMBIOS tables and related configuration parameters. If SystemProductName is not compatible with the target operating system, -no_compat_check boot argument may be used as an override. 注：If SystemProductName is unknown, and related fields are unspecified, default values should be assumed as being set to MacPro6,1 data. The list of known products can be found in MacInfoPkg. 6. SystemVersionType: plist stringFailsafe: OEM specifiedSMBIOS: System Information (Type 1) — VersionDescription: 产品迭代版本号。可能与 1.1 类似。 7. SystemSerialNumberType: plist stringFailsafe: OEM specifiedSMBIOS: System Information (Type 1) — Serial NumberDescription: 按照格式定义的产品序列号。已知的序列号的格式在 macserial 中。 8. SystemUUIDType: plist string, GUIDFailsafe: OEM specifiedSMBIOS: System Information (Type 1) — UUIDDescription: UUID 被设计为在时间和空间上都是唯一的标识符。It requires no central registration process. 9. SystemSKUNumberType: plist stringFailsafe: OEM specifiedSMBIOS: System Information (Type 1) — SKU NumberDescription: Mac Board ID (board-id). May look like Mac-7BA5B2D9E42DDD94 or Mac-F221BEC8 in older models. Sometimes it can be just empty. 10. SystemFamilyType: plist stringFailsafe: OEM specifiedSMBIOS: System Information (Type 1) — FamilyDescription: Family name. May look like iMac Pro. 11. BoardManufacturerType: plist stringFailsafe: OEM specifiedSMBIOS: Baseboard (or Module) Information (Type 2) - ManufacturerDescription: Board manufacturer. All rules of SystemManufacturer do apply. 12. BoardProductType: plist stringFailsafe: OEM specifiedSMBIOS: Baseboard (or Module) Information (Type 2) - ProductDescription: Mac Board ID (board-id). May look like Mac-7BA5B2D9E42DDD94 or Mac-F221BEC8 in older models. 13. BoardVersionType: plist stringFailsafe: OEM specifiedSMBIOS: Baseboard (or Module) Information (Type 2) - VersionDescription: Board version number. Varies, may match SystemProductName or SystemProductVersion. 14. BoardSerialNumberType: plist stringFailsafe: OEM specifiedSMBIOS: Baseboard (or Module) Information (Type 2) — Serial NumberDescription: Board serial number in defined format. Known formats are described in macserial. 15. BoardAssetTagType: plist stringFailsafe: OEM specifiedSMBIOS: Baseboard (or Module) Information (Type 2) — Asset TagDescription: Asset tag number. Varies, may be empty or Type2 - Board Asset Tag. 16. BoardTypeType: plist integerFailsafe: OEM specifiedSMBIOS: Baseboard (or Module) Information (Type 2) — Board TypeDescription: Either 0xA (Motherboard (includes processor, memory, and I/O) or 0xB (Processor/Memory Module), refer to Table 15 – Baseboard: Board Type for more details. 17. BoardLocationInChassisType: plist stringFailsafe: OEM specifiedSMBIOS: Baseboard (or Module) Information (Type 2) — Location in ChassisDescription: Varies, may be empty or Part Component. 18. ChassisManufacturerType: plist stringFailsafe: OEM specifiedSMBIOS: System Enclosure or Chassis (Type 3) — ManufacturerDescription: Board manufacturer. All rules of SystemManufacturer do apply. 19. ChassisTypeType: plist integerFailsafe: OEM specifiedSMBIOS: System Enclosure or Chassis (Type 3) — TypeDescription: Chassis type, refer to Table 17 — System Enclosure or Chassis Types for more details. 20. ChassisVersionType: plist stringFailsafe: OEM specifiedSMBIOS: System Enclosure or Chassis (Type 3) — VersionDescription: Should match BoardProduct. 21. ChassisSerialNumberType: plist stringFailsafe: OEM specifiedSMBIOS: System Enclosure or Chassis (Type 3) — VersionDescription: 应和 SystemSerialNumber 符合。 22. ChassisAssetTagType: plist stringFailsafe: OEM specifiedSMBIOS: System Enclosure or Chassis (Type 3) — Asset Tag NumberDescription: Chassis type name. Varies, could be empty or MacBook-Aluminum. 23. PlatformFeatureType: plist integer, 32-bitFailsafe: 0xFFFFFFFFSMBIOS: APPLE_SMBIOS_TABLE_TYPE133 - PlatformFeatureDescription: Platform features bitmask. Refer to AppleFeatures.h for more details. Use 0xFFFFFFFF value to not provide this table. 24. SmcVersionType: plist data, 16 bytesFailsafe: All zeroSMBIOS: APPLE_SMBIOS_TABLE_TYPE134 - VersionDescription: ASCII 字符串，包含 SMC 版本号（大写）。在基于 T2 芯片的 Mac 设备上缺少这一字段。当此值设置为零时，这一选项会被忽略。 25. FirmwareFeaturesType: plist data, 8 bytesFailsafe: 0SMBIOS: APPLE_SMBIOS_TABLE_TYPE128 - FirmwareFeatures and ExtendedFirmwareFeaturesDescription: 64-bit firmware features bitmask. Refer to AppleFeatures.h for more details. Lower 32 bits match FirmwareFeatures. Upper 64 bits match ExtendedFirmwareFeatures. 26.FirmwareFeaturesMaskType: plist data, 8 bytesFailsafe: 0SMBIOS: APPLE_SMBIOS_TABLE_TYPE128 - FirmwareFeaturesMask and ExtendedFirmwareFeaturesMaskDescription: Supported bits of extended firmware features bitmask. Refer to AppleFeatures.h for more details. Lower 32 bits match FirmwareFeaturesMask. Upper 64 bits match ExtendedFirmwareFeaturesMask. 27. ProcessorTypeType: plist integer, 16-bitFailsafe: AutomaticSMBIOS: APPLE_SMBIOS_TABLE_TYPE131 - ProcessorTypeDescription: Combined of Processor Major and Minor types. 28. MemoryFormFactorType: plist integer, 8-bitFailsafe: OEM specifiedSMBIOS: Memory Device (Type 17) — Form FactorDescription: Memory form factor. On Macs it should be DIMM or SODIMM."},{"title":"11. UEFI","url":"/11-uefi.html","content":"11.1 IntroductionUEFI (Unified Extensible Firmware Interface) is a specification that defines a software interface between an operating system and platform firmware. This section allows to load additional UEFI modules and/or apply tweaks for the onboard firmware. To inspect firmware contents, apply modifications and perform upgrades UEFITool and supplementary utilities can be used. 11.2 PropertiesConnectDriversType: plist booleanFailsafe: falseDescription: 驱动程序加载后执行 UEFI 控制器连接操作。 此选项对于加载文件系统驱动很有用，因为文件系统驱动通常遵循 UEFI 驱动模型（并且可能无法自行启动）。此选项对会自动连接的驱动程序来说是不必要的，并且可能会稍微减慢启动速度。 注：某些固件（特别是 Apple 的）仅连接包含操作系统的驱动器以加快启动过程。启用此选项可以在拥有多个驱动器时查看所有引导选项。 DriversType: plist arrayFailsafe: NoneDescription: 从 OC/Drivers 目录下加载选择的驱动。 设计为填充要作为 UEFI 驱动程序加载的文件名。根据固件不同、可能需要不同的驱动程序。加载不兼容的驱动程序可能会导致无法启动系统，甚至导致固件永久性损坏。OpenCore 可以使用的驱动程序包括： ApfsDriverLoader — APFS 文件系统引导驱动程序在 UEFI 固件的可启动 APFS 容器中添加了对嵌入式 APFS 驱动程序的支持。 FwRuntimeServices — OC_FIRMWARE_RUNTIME 协议通过支持只读、只写 NVRAM 变量，提升了 OpenCore 和 Lilu 的安全性。有些 Quirks 如 RequestBootVarRouting 依赖此驱动程序。由于 runtime 驱动饿性质（与目标操作系统并行运行），因此它不能在 OpenCore 本身实现，而是与 OpenCore 捆绑在一起。 HiiDatabase — 来自 MdeModulePkg 的 HII 服务驱动。Ivy Bridge 及其以后的大多数固件中都已内置此驱动程序。某些带有 GUI 的应用程序（例如 UEFI Shell）可能需要此驱动程序才能正常工作。 EnhancedFatDxe — 来自 FatPkg 的 FAT 文件系统驱动程序。这个驱动程序已经被嵌入到所有 UEFI 固件中，无法为 OpenCore 使用。众所周知，许多固件的 FAT 支持实现都有错误，导致在尝试写操作时损坏文件系统。如果在引导过程中需要写入 EFI 分区，则可能组要将此驱动程序嵌入固件中。 NvmExpressDxe — 来自MdeModulePkg 的 NVMe 驱动程序。从 Broadwell 一代开始的大多数固件都包含此驱动程序。对于 Haswell 以及更早的版本，如果安装了 NVMe SSD 驱动器，则将其嵌入固件中可能会更理想。 AppleUsbKbDxe — USB 键盘驱动在自定义 USB 键盘驱动程序的基础上新增了对 AppleKeyMapAggregator 协议的支持。这是内置的 KeySupport 的等效替代方案。根据固件不同，效果可能会更好或者更糟。 VBoxHfs — 带有 bless 支持的 HFS 文件系统驱动。是 Apple 固件中 HFSPlus 驱动的开源替代。虽然功能完善，但是启动速度比 HFSPlus 慢三倍，并且尚未经过安全审核。 XhciDxe — 来自 MdeModulePkg 的 XHCI USB controller 驱动程序。从 Sandy Bridge 代开始的大多数固件中都包含此驱动程序。在较早的固件或旧系统可以用于支持外部 USB 3.0 PCI 卡。 要从 UDK（EDK II）编译驱动程序，可以使用编译 OpenCore 类似的命令。 3. InputType: plist dictFailsafe: NoneDescription: Apply individual settings designed for input (keyboard and mouse) in Input Properties section below. 4. OutputType: plist dictFailsafe: NoneDescription: Apply individual settings designed for output (text and graphics) in Output Properties section below. 5. ProtocolsType: plist dictFailsafe: NoneDescription: Force builtin versions of select protocols described in Protocols Properties section below.注：all protocol instances are installed prior to driver loading. 6. QuirksType: plist dictFailsafe: NoneDescription: Apply individual firmware quirks described in Quirks Properties section below. 11.3 Input Properties1. KeyForgetThresholdType: plist integerFailsafe: 0Description: 两次按键之间的间隔时间，单位为毫秒。 AppleKeyMapAggregator 协议应该包含当前按下的键的固定长度的缓冲。但是大部分驱动程序仅将按键按下报告为中断、并且按住按键会导致在一定的时间间隔后再提交按下行为。一旦超时到期，我们就是用超时从缓冲区中删除一次按下的键，并且没有新提交。 此选项允许根据你的平台设置此超时。在大多数平台上有效的推荐值为 5 毫秒。作为参考，在 VMWare 上按住一个键大约每 2 毫秒就会重复一次，而在 APTIO V 上是 3 - 4 毫秒。因此，可以在较快的平台上设置稍低的值、在较慢的平台设置稍高的值，以提高响应速度。 2. KeyMergeThresholdType: plist integerFailsafe: 0Description: 按住按键被重置的间隔时间，单位为毫秒。 与 KeyForgetThreshold 类似，这一选项适用于按键提交的顺序。为了能够识别同时按下的按键，我们需要设置一个超时时间，在这个时间内可以假定这两个按键是同时按下的。 对于 VMWare，同时按下多个键的间隔是 2 毫秒。对于 APTIO V 平台为 1 毫毛。一个接一个地按下按键会导致 6 毫秒和 10 毫秒的延迟。此选项的建议值为 2 毫秒，但对于较快的平台可以选取较小的值，反之亦然。 3. KeySupportType: plist booleanFailsafe: falseDescription: 启用这一选项后将会开启内置键盘支持。 这一选项基于 AppleGenericInput（AptioInputFix），激活内部键盘拦截器驱动程序以填充 AppleKeyMapAggregator 数据库以实现输入功能。如果使用了单独的驱动程序（如 AppleUsbKbDxe），则永远不要开启这一选项。 4. KeySupportModeType: plist stringFailsafe: empty stringDescription: 将内部键盘的输入转换设置为 AppleKeyMapAggregator 协议模式。 Auto — 从下述选项中自动选择 V1 — UEFI 传统输入协议 EFI_SIMPLE_TEXT_INPUT_PROTOCOL. V2 — UEFI 现代标准输入协议 EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL. AMI — APTIO 输入协议 AMI_EFIKEYCODE_PROTOCOL. 5. KeySwapType: plist booleanFailsafe: falseDescription: 启用后将交换 Command 和 Option。 此选项对于 Option 键位于 Command 右侧的键盘来说会很有用。 6. PointerSupportType: plist booleanFailsafe: falseDescription: 启用后将试图修复 UEFI 选择器协议。 该选项通过选择 OEM 协议实现标准 UEFI 指针协议 EFI_SIMPLE_POINTER_PROTOCOL。该选项在 Z87 华硕主板可能有用（该主板的 EFI_SIMPLE_POINTER_PROTOCOL 存在问题）。 7. PointerSupportModeType: plist stringFailsafe: empty stringDescription: 设置用于内部指针驱动程序的 OEM 协议。 目前只支持 ASUS 值，使用的是 Z87 和 Z97主板上的特殊协议。更多详情请参考 LongSoft/UefiTool#116。 8. TimerResolutionType: plist integerFailsafe: 0Description: 固件始终刷新的频率（单位 100 纳秒） 设置较低的值可以提高界面和输入处理性能的响应能力。建议值为 50000（即 5 毫秒）或稍高一些。选择 ASUS Z87 主板时，请使用 60000，苹果主板请使用 100000。你也可以将此值保留为 0，由 OpenCore 自动计算。 11.4 Output Properties1. TextRendererType: plist stringFailsafe: BuiltinGraphicsDescription: Chooses renderer for text going through standard console output. Currently two renderers are supported: Builtin and System. System renderer uses firmware services for text rendering. Builtin bypassing firmware services and performs text rendering on its own. Different renderers support a different set of options. It is recommended to use Builtin renderer, as it supports HiDPI mode and uses full screen resolution. UEFI firmwares generally support ConsoleControl with two rendering modes: Graphics and Text. Some firmwares do not support ConsoleControl and rendering modes. OpenCore and macOS expect text to only be shown in Graphics mode and graphics to be drawn in any mode. Since this is not required by UEFI specification, exact behaviour varies. Valid values are combinations of text renderer and rendering mode: BuiltinGraphics — Switch to Graphics mode and use Builtin renderer with custom ConsoleControl. SystemGraphics — Switch to Graphics mode and use System renderer with custom ConsoleControl. SystemText — Switch to Text mode and use System renderer with custom ConsoleControl. SystemGeneric — Use System renderer with system ConsoleControl assuming it behaves correctly. The use of BuiltinGraphics is generally straightforward. For most platforms it is necessary to enable ProvideConsoleGop, set Resolution to Max. The use of System protocols is more complicated. In general the preferred setting is SystemGraphics or SystemText. Enabling ProvideConsoleGop, setting Resolution to Max, enabling ReplaceTabWithSpace is useful on almost all platforms. SanitiseClearScreen, IgnoreTextInGraphics, and ClearScreenOnModeSwitch are more specific, and their use depends on the firmware. 注：Some Macs, namely MacPro5,1, may have broken console output with newer GPUs, and thus only BuiltinGraphics may work for them. 2. ConsoleModeType: plist stringFailsafe: Empty stringDescription: Sets console output mode as specified with the WxH (e.g. 80x24) formatted string. Set to empty string not to change console mode. Set to Max to try to use largest available console mode. Currently Builtin text renderer supports only one console mode, so this option is ignored. 注：This field is best to be left empty on most firmwares. 3. ResolutionType: plist stringFailsafe: Empty stringDescription: Sets console output screen resolution. Set to WxH@Bpp (e.g. 1920x1080@32) or WxH (e.g. 1920x1080) formatted string to request custom resolution from GOP if available. Set to empty string not to change screen resolution. Set to Max to try to use largest available screen resolution. On HiDPI screens APPLE_VENDOR_VARIABLE_GUID UIScale NVRAM variable may need to be set to 02 to enable HiDPI scaling in in Builtin text renderer, FileVault 2 UEFI password interface, FileVault 2 UEFI password interface and boot screen logo. Refer to Recommended Variables section for more details. 注：This will fail when console handle has no GOP protocol. When the firmware does not provide it, it can be added with ProvideConsoleGop set to true. 4. ClearScreenOnModeSwitchType: plist booleanFailsafe: falseDescription: Some firmwares clear only part of screen when switching from graphics to text mode, leaving a fragment of previously drawn image visible. This option fills the entire graphics screen with black color before switching to text mode. 注：This option only applies to System renderer. 5. DirectGopRenderingType: plist booleanFailsafe: falseDescription: Use builtin graphics output protocol renderer for console. On some firmwares this may provide better performance or even fix rendering issues, like on MacPro5,1. However it is recommended not to use this option unless there is an obvious benefit as it may even result in slower scrolling. 6. IgnoreTextInGraphicsType: plist booleanFailsafe: falseDescription: Select firmwares output text onscreen in both graphics and text mode. This is normally unexpected, because random text may appear over graphical images and cause UI corruption. Setting this option to true will discard all text output when console control is in mode different from Text. 注：This option only applies to System renderer. 7. ReplaceTabWithSpaceType: plist booleanFailsafe: falseDescription: Some firmwares do not print tab characters or even everything that follows them, causing difficulties or inability to use the UEFI Shell builtin text editor to edit property lists and other documents. This option makes the console output spaces instead of tabs. 注：This option only applies to System renderer. 8. ProvideConsoleGopType: plist booleanFailsafe: falseDescription: Ensure GOP (Graphics Output Protocol) on console handle. macOS bootloader requires GOP to be present on console handle, yet the exact location of GOP is not covered by the UEFI specification. This option will ensure GOP is installed on console handle if it is present. 注：This option will also replace broken GOP protocol on console handle, which may be the case on MacPro5,1 with newer GPUs. 9. ReconnectOnResChangeType: plist booleanFailsafe: falseDescription: Reconnect console controllers after changing screen resolution. On some firmwares when screen resolution is changed via GOP, it is required to reconnect the controllers, which produce the console protocols (simple text out). Otherwise they will not produce text based on the new resolution. 注：On several boards this logic may result in black screen when launching OpenCore from Shell and thus it is optional. In versions prior to 0.5.2 this option was mandatory and not configurable. Please do not use this unless required. 10. SanitiseClearScreenType: plist booleanFailsafe: falseDescription: Some firmwares reset screen resolution to a failsafe value (like 1024x768) on the attempts to clear screen contents when large display (e.g. 2K or 4K) is used. This option attempts to apply a workaround. 注：This option only applies to System renderer. On all known affected systems ConsoleMode had to be set to empty string for this to work. 11.5 Protocols Properties1. AppleBootPolicyType: plist booleanFailsafe: falseDescription: 重新安装内置的 Apple Boot Policy 协议，可用于确保 VM 或旧版 Mac 设备上的 APFS 兼容性。 注：某些 Mac 设备（如 MacPro5,1）虽然兼容 APFS，但是其 Apple Boot Policy 协议包含了恢复分区检测问题，因此也建议启用这一选项。 2. AppleEventType: plist booleanFailsafe: falseDescription: 重新安装内置的 Apple Event 协议，可以确保在 VM 或旧版 Mac 设备上的 Faile Vault V2 兼容性。 3. AppleImageConversionType: plist booleanFailsafe: falseDescription: 重新安装内置的 Apple Image Conservation 协议。 4. AppleKeyMapType: plist booleanFailsafe: falseDescription: 重新安装内置的 Apple Key Map 协议 5. AppleSmcIoType: plist booleanFailsafe: falseDescription: 重新安装内置的 SMC I/O 协议。 这一协议代替了传统的 VirtualSmc.efi，并与所有 SMC kext 驱动兼容。如果你在用 FakeSMC，可能需要手动往 NVRAM 中添加键值对。 6. AppleUserInterfaceThemeType: plist booleanFailsafe: falseDescription: 重新安装内置的 Apple User Interface Theme 协议。 7. DataHubType: plist booleanFailsafe: falseDescription: 重新安装具有内置版本的 Data Hub 协议。如果已经安装了协议，这将删除所有先前的属性。 8. DevicePropertiesType: plist booleanFailsafe: falseDescription: 重新安装内置版本的 Device Property 协议。 如果已经安装，它将删除所有以前的属性。这一选项可用于确保在 VM 或旧版 Mac 设备上的兼容性。 9. FirmwareVolumeType: plist booleanFailsafe: falseDescription: 强制包装固件卷协议或安装新版本以支持 File Vault 2 的自定义光标图像。建议启用这一选项以确保 File Vault 2 在除 VM 和传统 Mac 设备之外的兼容性。 注：包括 VMWare 在内的多个虚拟机在 HiDPI 模式下光标会损坏，因此建议为所有虚拟机启用这一选项。 10. HashServicesType: plist booleanFailsafe: falseDescription: Forcibly reinstalls Hash Services protocols with builtin versions. Should be set to true to ensure File Vault 2 compatibility on platforms providing broken SHA-1 hashing. Can be diagnosed by invalid cursor size with UIScale set to 02, in general platforms prior to APTIO V (Haswell and older) are affected. 11. OSInfoType: plist booleanFailsafe: falseDescription: 强制使用内置版本重新安装 OS Info 协议。该协议通常用于通过固件或其他应用程序从 macOS 引导加载程序接收通知。 12. UnicodeCollationType: plist booleanFailsafe: falseDescription: Forcibly reinstalls unicode collation services with builtin version. 建议启用这一选项以确保 UEFI Shell 的兼容性。一些较旧的固件破坏了 Unicode 排序规则, 设置为 YES 可以修复这些系统上 UEFI Shell 的兼容性 (通常为用于 IvyBridge 或更旧的设备) 11.6 Quirks Properties1. ExitBootServicesDelayType: plist integerFailsafe: 0Description: 在 EXIT_BOOT_SERVICES 事件后添加延迟，单位为毫秒。 This is a very ugly quirk to circumvent “Still waiting for root device” message on select APTIO IV firmwares, namely ASUS Z87-Pro, when using FileVault 2 in particular. It seems that for some reason they execute code in parallel to EXIT_BOOT_SERVICES, which results in SATA controller being inaccessible from macOS. A better approach should be found in some future. Expect 3-5 seconds to be enough in case the quirk is needed. 2. IgnoreInvalidFlexRatioType: plist booleanFailsafe: falseDescription: Select firmwares, namely APTIO IV, may contain invalid values in MSR_FLEX_RATIO (0x194) MSR register. These values may cause macOS boot failure on Intel platforms. 注：While the option is not supposed to induce harm on unaffected firmwares, its usage is not recommended when it is not required. 3. ReleaseUsbOwnershipType: plist booleanFailsafe: falseDescription: Attempt to detach USB controller ownership from the firmware driver. While most firmwares manage to properly do that, or at least have an option for, select firmwares do not. As a result, operating system may freeze upon boot. Not recommended unless required. 4. RequestBootVarFallbackType: plist booleanFailsafe: falseDescription: Request fallback of some Boot prefixed variables from OC_VENDOR_VARIABLE_GUID to newline EFI_GLOBAL_VARIABLE_GUID. This quirk requires RequestBootVarRouting to be enabled and therefore OC_FIRMWARE_RUNTIME protocol implemented in FwRuntimeServices.efi. By redirecting Boot prefixed variables to a separate GUID namespace we achieve multiple goals: Operating systems are jailed and only controlled by OpenCore boot environment to enhance security. Operating systems do not mess with OpenCore boot priority, and guarantee fluent updates and hibernation wakes for cases that require reboots with OpenCore in the middle. Potentially incompatible boot entries, such as macOS entries, are not deleted or anyhow corrupted. However, some firmwares do their own boot option scanning upon startup by checking file presence on the available disks. Quite often this scanning includes non-standard locations, such as Windows Bootloader paths. Normally it is not an issue, but some firmwares, ASUS firmwares on APTIO V in particular, have bugs. For them scanning is implemented improperly, and firmware preferences may get accidentally corrupted due to BootOrder entry duplication (each option will be added twice) making it impossible to boot without cleaning NVRAM. To trigger the bug one should have some valid boot options (e.g. OpenCore) and then install Windows with RequestBootVarRouting enabled. As Windows bootloader option will not be created by Windows installer, the firmware will attempt to create it itself, and then corrupt its boot option list. This quirk forwards all UEFI specification valid boot options, that are not related to macOS, to the firmware into BootF### and BootOrder variables upon write. As the entries are added to the end of BootOrder, this does not break boot priority, but ensures that the firmware does not try to append a new option on its own after Windows installation for instance. 5. RequestBootVarRoutingType: plist booleanFailsafe: falseDescription: Request redirect of all Boot prefixed variables from EFI_GLOBAL_VARIABLE_GUID to newline OC_VENDOR_VARIABLE_GUID. This quirk requires OC_FIRMWARE_RUNTIME protocol implemented in FwRuntimeServices.efi. The quirk lets default boot entry preservation at times when firmwares delete incompatible boot entries. Simply said, you are required to enable this quirk to be able to reliably use Startup Disk preference pane in a firmware that is not compatible with macOS boot entries by design. 6. UnblockFsConnectType: plist booleanFailsafe: falseDescription: 某些固件通过「按驱动程序」模式下来阻止引导项加载。 注：如果惠普笔记本在 OpenCore 界面没有看到引导项时启用这一选项。"},{"title":"12. 排错","url":"/12-troubleshooting.html","content":"12.1 Windows 支持我能安装 Windows 系统吗？虽然 OpenCore 并没有提供官方的 Windows 支持，但是使用 Boot Camp 安装 64 位 UEFI Windows（即 Windows 8 及更高版本）应该是可以正常工作的。安装第三方 UEFI、或者仅部分支持 UEFI 引导的系统（如 Windows 7）可能需要额外注意。不论如何，记住以下几点： MBR (Master Boot Record) 属于 Legacy 引导，因此将不会被支持。 在同一块硬盘上安装 Windows、macOS 和 OpenCore 时，你可以在 BlessOverride 部分中指定 Windows Bootloader 的路径（\\EFI\\Microsoft\\Boot\\bootmgfw.efi）。 在 OpenCore 上应用的所有更改（ACPI、NVRAM、SMBIOS）都应该与操作系统本身无关。OpenCore 会将这些改动生效于所有操作系统，这样在 Windows 上可以获得 Boot Camp 的体验。 macOS 要求硬盘中的第一份分区为 EFI 分区，并且与 Windows 的默认布局不支持。尽管 OpenCore 确实提供了一个 解决方法，但是强烈建议不要依赖这个方法。 Windows 系统可能需要重新激活。为了避免这种情况发生，请考虑将 SystemUUID 设置为原始固件的 UUID。请注意，在旧固件上 UUID 可能是无效的（非随机的）。如果你还遇到了什么问题，可以考虑使用 HWID 或 KMS38 的 Windows 许可证。Windows 激活的细节不在本文档的讨论范围内，你应该能够在网上查找到相关资料。 我需要安装其他什么软件吗？在大多数情况下，要启用多操作系统切换、安装相关驱动程序，你将需要 Boot Camp 提供的 Windows 支持软件。为了简化下载过程、或者配置硬盘中已经安装好的 Windows，可以使用 Brigadier 这个实用软件。请注意在使用 Brigadier 之前，你可能需要先下载并安装 7-Zip。 译者注：7-zip 官方中文网站 记住，一定要使用最新版本的 Boot Camp 的 Windows 支持软件。6.1 之前的版本不支持 APFS 文件系统、因此无法运行。要下载最新的软件，请将最新 Mac 的型号作为参数传递给 Brigadier，如 ./brigadier.exe -m iMac19,1。之后，在不受支持的 Mac 型号上安装 Boot Camp，请以管理员身份运行 PowerShell，输入 msiexec /i BootCamp.msi 即可。如果你之前不小心已经安装了旧版本的 Boot Camp，则必须先通过运行 msiexec /x BootCamp.msi 将其卸载。BootCamp.msi 文件位于 BootCamp/Drivers/Apple 目录中、可以通过资源管理器访问。 译者注：在资源管理器下，按住 Shift 同时右击窗口中空白处，此时菜单中会显示「在此处运行 PowerShell」，即在当前目录下运行 PowerShell。但是这种方式启动的 PowerShell 不具备管理员权限。 尽管 Boot Camp 提供的 Windows 支持软件解决了大多数兼容性问题，但是有时候您还是需要手动解决一些问题： 要反转鼠标滚轮的滚动方向，必须按照 这个网站 提供的方法、设置 FlipFlopWheel 的值为 1。 译者注：涉及到的注册表是 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\HID\\VID_???\\VID_???\\Device Parameters.你可以在 PowerShell 中执行下述命令进行设置； 如果需要撤销更改，可以使用下述命令： RealTimeIsUniversal 必须设置为 1 以避免 Windows 和 macOS 之间的时间不同步。 译者注：众所周知，Windows 将硬件时间视为本地时间，而 macOS 会计算 UTC 后当做系统时间。通过修改上述提到的注册表值，可以让 Windows 将硬件时间视为 UTC 时间。用到的 CMD 命令如下所示： 如果要访问 Apple 的文件系统（APFS、HFS），你可能需要安装单独的软件。已知的工具有 Apple HFS+ driver (hack for Windows 10)、HFSExplorer、MacDrive、Paragon APFS、Paragon HFS+、TransMac，等等。 译者注：切记不要在 Windows 下写入 APFS 或 HFS，十有八九你会导致分区表错误和无法恢复的数据丢失。别怪我们没有警告过你！！ 为什么我会在 Boot Camp 启动硬盘 控制面板 中看到 Basic data partition？Boot Camp 使用 GPT 分区表获取每个引导选项的名称。独立安装 Windows 后，你必须手动重新标记分区。这可以挺过许多工具完成，比如开源的 gdisk，使用方法如下： Listing 3: Relabeling Windows volume 如何选择 NTFS 驱动程序提供 NTFS 读写支持的第三方驱动程序，如 NTFS-3G、Paragon NTFS、Tuxera NTFS 或 希捷移动硬盘 Paragon 驱动程序 会破坏 macOS 的功能，比如 系统偏好设置 中的 启动磁盘 选项。虽然我们仍然不建议使用这些经常破坏文件系统的驱动程序（我们推荐使用 macOS 内建的 NTFS 读写支持，可以通过终端或 GUI 启用），但是这些驱动程序的厂商也提供了他们各自的解决方案，在这里我们仅列举两个： Tuxera 的常见问题解答页面 Paragon 相关的技术支持文档 12.2 调试与其他硬件相关的项目类似，OpenCore 也支持审计与调试。使用 NOOPT 或 DEBUG 构建版本（而非 RELEASE 构建版本）可以产生更多的调试输出。对于 NOOPT 构建版本，你还可以使用 GDB 或 IDA Pro 进行调试。对于 GDB 请查看 OcSupport Debug 相关页面；对于 IDA Pro，你需要 7.3 或更高版本，更多详细信息请参考 IDA Pro 提供的页面：Debugging the XNU Kernel with IDA Pro。 To obtain the log during boot you can make the use of serial port debugging. Serial port debugging is enabled in Target, e.g. 0xB for onscreen with serial. OpenCore uses 115200 baud rate, 8 data bits, no parity, and 1 stop bit. For macOS your best choice are CP2102-based UART devices. Connect motherboard TX to USB UART RX, and motherboard GND to USB UART GND. Use screen utility to get the output, or download GUI software, such as CoolTerm. 注释: On several motherboards (and possibly USB UART dongles) PIN naming may be incorrect. It is very common to have GND swapped with RX, thus you have to connect motherboard &quot;TX&quot; to USB UART GND, and motherboard &quot;GND&quot; to USB UART RX. Remember to enable COM port in firmware settings, and never use USB cables longer than 1 meter to avoid output corruption. To additionally enable XNU kernel serial output you will need debug=0x8 boot argument. 12.3 技巧和窍门1. 啊呀呀呀我系统没法启动了我该怎么看日志啊？通常情况下，获取实际的错误信息就足够了。为此，请确保： 你正在使用 OpenCore 的 DEBUG 或 NOOPT 版本。 日志已启用（1）并且在屏幕上显示（2）：Misc =&gt; Debug =&gt; Target = 3. 将以下这些等级的日志输出到屏幕上：DEBUG_ERROR (0x80000000)、DEBUG_WARN (0x00000002) 和 DEBUG_INFO (0x00000040)：Misc =&gt; Debug =&gt; DisplayLevel = 0x80000042. 遇到 DEBUG_ERROR 这样的致命错误时中止启动：Misc =&gt; Security =&gt; HaltLevel = 0x80000000。 禁用 Watch Dog 以避免自动重启：Misc =&gt; Debug =&gt; DisableWatchDog = true。 已启用 启动菜单 显示：Misc =&gt; Boot =&gt; ShowPicker = true 如果你在日志中看不出明显的错误，请逐一检查 Quirks 部分中可用的 hacks。例如，对于 Early Boot 出现的问题（如 OpenCore 启动菜单无法显示），通过 UEFI Shell 可以查看相关调试信息。 2. 如何自定义启动项？OpenCore 遵循 Apple Bless 标准模型、从引导目录中的 .contentDetails 和 .disk_label.contentDetails 文件中提取条目名称。这些文件包含带有输入标题的 ASCII 字符串，你可以修改它们。 3. 如何选择默认启动的系统？OpenCore 使用 UEFI 首选启动项 来选择默认的启动项。设置的方式随 BIOS 不同而不同，具体请参考 macOS 启动磁盘 或 Windows Boot Camp 控制面板。 由于使用 OpenCore 提供的 BOOTx64.efi 作为首选启动项会限制这项功能（可能还会导致一些固件删除不兼容的引导选项），我们强烈建议你修改 RequestBootVarRouting quirk，这会将你所做的选择保留在 OpenCore 变量空间中。请注意，RequestBootVarRouting 需要单独的 .efi 驱动文件。 4. 安装 macOS 最简单的方法是什么？在线安装。将 Recovery 镜像（*.dmg 和 *.chunklist 文件）和 OpenCore 一起复制到一个 FAT32 分区中。加载 OpenCore 的启动菜单并选择后缀为 .dmg 的条目。如果你有强迫症，你可以修改 .contentDetails 文件改变条目显示的文字。 你可能会用到 MacInfoPkg 内置的 macrecovery.py 来下载 Recovery 镜像。 如果你需要进行离线安装，请参考 How to create a bootable installer for macOS。除了通过 App Store 或 系统更新，你还可以使用 第三方工具 下载 macOS 镜像文件。 5. 为什么无法加载 Recovery 恢复镜像 进行在线安装？可能是因为你没带 HFS+ 驱动。目前我们所知道的 Recovery 分区全都是 HFS+ 文件系统。 6. 我可以在 Apple 的硬件、或虚拟机中使用 OpenCore 吗？可以，没有必要，但请加大力度 OpenCore 支持包括 MacPro 5,1 和虚拟机在内的大部分较新的 Mac 想好。不过，OpenCore有关在 Mac 硬件上使用的具体细节微乎其微。你可以在 acidanthera/bugtracker#377 查看相关讨论。 7. 为什么 Find 和 Replace 的补丁的长度必须相等？对于 x86 机器码来说，相对寻址 无法进行大小不同的替换。对于 ACPI 代码来说这是有风险的，而且在技术上这与替换 ACPI 表等价，所以 OpenCore 没有实现。更多详细的解答可以在 AppleLife.ru 上找到。 8. 我如何从 AptioMemoryFix 迁移到 OpenCore?可以通过安装 FwRuntimeServices.efi 驱动程序并启用以下列出的 quirk 来获得与 AptioMemoryFix 类似的行为。 请注意，其中大多数功能都不需要启用。有关更多详细信息，请参阅本文档中关于它们的单独描述。 ProvideConsoleGop (UEFI quirk) AvoidRuntimeDefrag DiscardHibernateMap EnableSafeModeSlide EnableWriteUnprotector ForceExitBootServices ProtectCsmRegion ProvideCustomSlide SetupVirtualMap ShrinkMemoryMap "},{"title":"2. 配置","url":"/2-configuration.html","content":"2.1 配置术语 OC config — OpenCore 的配置文件，格式为 plist，文件名为 config.plist。OpenCore 的配置文件具有可扩展性，并被设计为具有多个命名空间的结构。每个命名空间下允许具有 plist array 或 plist dictionary，在本文档相应部分中对其进行了描述 valid key — 现在以及未来本文档中描述的 OC Config 中的 plist key object。除了明确描述的 valid keys 以外，以 # 符号开头的 key（如 #Hello）也将被视为 valid key，并被表示为注释。虽然表示为注释的值会被丢弃，但是它们仍然是 valid key。其他的 plist key 都是无效、不合法的，它们的存在可能会导致未定义、非预期的行为。 valid value — valid plist object of OC config described in this document that matches all the additional requirements in specific plist object description if any. invalid value — valid plist object of OC config described in this document that is of other plist type, does not conform to additional requirements found in specific plist object description (e.g. value range), or missing from the corresponding collection. Invalid value is read with or without an error message as any possible value of this plist object in an undetermined manner (i.e. the values may not be same across the reboots). Whilst reading an invalid value is equivalent to reading certain defined valid value, applying incompatible value to the host system may yield to undefined behaviour. optional value — valid value of OC config described in this document that reads in a certain defined manner provided in specific plist object description (instead of invalid value) when not present in OC config. All other cases of invalid value do still apply. Unless explicitly marked as optional value, any other value is required to be present and reads to invalid value if missing. fatal behaviour — behaviour leading to boot termination. Implementation must stop the boot process from going any further until next host system boot. It is allowed but not required to perform cold reboot or show any warning message. undefined behaviour — behaviour not prescribed by this document. Implementation is allowed to take any measures including but not limited to fatal behaviour, assuming any states or values, or ignoring, unless these measures negatively affect system security in general. 2.2 配置处理如果 OpenCore 发现了 OC Config，则至少会被读取并处理一次。跟你局 OpenCore 的引导机制的不同，对于多个 OC Config 文件，OpenCore 可能会读取其中任何一个或数个。如果硬盘中没有 OC Config，OpenCore 将会使用可选值和无效值的规则。 OC Config 有大小、嵌套、键数量的限制。OC Config 的大小不得超过 16 MB，嵌套层数不得超过 8 层，没个 plist object 中最多有 16384 个节点（一个 plist dictionary 将被计为一对节点）。不符合上述规则的 OC Config 文件将可能导致未定义、非预期的行为。常见的 OC Config 错误格式包括 不符合 plist DTD 存在本文档中没有记载的 plist object 违反文件大小、嵌套层级和密钥数量的限制 我们建议（但非强制）遇到格式错误的 OC Config 时不停止加载、然后继续进行就好像 OC Config 不存在一样。为了是先前向兼容性，建议（但非强制）要求实现对采用无效值的行为进行警告。采用无效值的建议做法是在使用的情况下遵守以下规则： Type Value plist string Empty string (&lt;string&gt;&lt;/string&gt;) plist data Empty data (&lt;data&gt;&lt;/data&gt;) plist integer 0 (&lt;integer&gt;0&lt;/integer&gt;) plist boolean False (&lt;false/&gt;) plist tristate False (&lt;false/&gt;) 2.3 配置结构OC Config 包括以下几个独立部分，将在本文档中分别进行介绍。默认情况下配置文件将尽可能不启用任何功能以及禁用某些功能。总的来说，这些配置的一般由如下的操作构成： Add：为数据提供 添加 操作支持 Block：为数据提供 删除/忽视 操作支持 Patch：为数据提供 补丁 操作支持 Quirks：提供特定的黑科技支持 配置文件分为以下几个独立部分： ACPI Booter DeviceProperties Kernel Misc NVRAM PlatformInfo UEFI 译者注：对上述部分的介绍位于文档的第 4 至 11 章节。你可以在本网站左侧边栏中的目录中找到这些章节的入口。 注意：出于安全原因，目前大多数属性都有默认值（译者注：后续文档中以 FailSafe 字段呈现）。如果在配置项中未指定任何值，默认值将会生效。你不应该依赖默认值的功能，必须在配置中正确指定所有字段。"},{"title":"3. Setup","url":"/3-setup.html","content":"3.1 目录结构 使用目录引导时，使用的目录结构应该遵循上述目录结构。可用的条目有： BOOTx64.efi - 初始引导程序。除非 OpenCore.efi 已作为驱动程序启动，否则将用于加载 OpenCore.efi。 ACPI - 用于存储 ACPI 补充信息的目录。 Drivers - 用于存储 UEFI 补充驱动程序的目录。 Kexts - 用于存储内核驱动（kext）补充的目录。 Tools - 用于存储补充工具的目录。 OpenCore.efi - 主引导驱动程序，负责操作系统加载。 vault.plist - OC Config 可能加载的所有文件的哈希。 config.plist - OC Config（即 OpenCore 的配置文件，见「配置术语」）。 vault.sig - vault.plist 的签名文件。 nvram.plist - OpenCore 变量导入文件。 opencore-YYYY-MM-DD-HHMMSS.txt - OpenCore 日志文件。 3.2 安装和升级如果要安装 OpenCore，请在使用 GPT 格式的硬盘上、按照上一节的文件夹结构建立文件和文件夹。尽管本文档的相应部分的确提供了有关你所需的外部资源（如 ACPI 表、UEFI 驱动程序或 kexts）的某些信息，但是本文档不保证会提供关于这些外部资源的全部信息。关于 kext 的完整信息可以查看由 OpenCore 提供的 可选 kext 列表；而本文档也在安全属性的相关章节提供了 Vauting 的相关信息。 OpenCore 的配置文件可以使用任何常规的文本编辑器（如 nano、vim、VSCode）进行编辑，但是专用软件可以带来更好的体验。在 macOS 上我们推荐使用 Xcode。你也可以使用 ProperTree ，这是一个轻量级的跨平台的开源 plist 编辑器。 如果要通过 BIOS 进行开机，你必须使用第三方 UEFI 环境提供程序。DuetPkg 是一个常用的为旧操作系统提供 Legacy 引导的 UEFI 环境提供程序。要在这样的旧操作系统上运行 OpenCore，你可以使用 BootInstall 安装 DuetPkg。 如果要升级 OpenCore，Differences.pdf 提供了 OpenCore 配置文件变更的相关信息，Changelog.md 提供了 OpenCore 的更新日志。 3.3 贡献代码OpenCore can be compiled as an ordinary EDK II. Since UDK development was abandoned by TianoCore, OpenCore requires the use of EDK II Stable. Currently supported EDK II release (potentially with patches enhancing the experience) is hosted in acidanthera/audk. The only officially supported toolchain is XCODE5. Other toolchains might work, but are neither supported, nor recommended. Contribution of clean patches is welcome. Please do follow EDK II C Codestyle. Required external package dependencies include EfiPkg, MacInfoPkg, and OcSupportPkg. To compile with XCODE5, besides Xcode, one should also install NASM and MTOC. The latest Xcode version is recommended for use despite the toolchain name. Examplecommand sequence may look as follows: For IDE usage Xcode projects are available in the root of the repositories. Another approach could be Sublime Text with EasyClangComplete plugin. Add .clang_complete file with similar content to your UDK root: Warning: Tool developers modifying config.plist or any other OpenCore files must ensure that their tool checks for opencore-version NVRAM variable (see Debug Properties section below) and warn the user if the version listed is unsupported or prerelease. OpenCore configuration may change across the releases and the tool shall ensure that it carefully follows this document. Failure to do so may result in this tool to be considered as malware and blocked with all possible means. 3.4 代码约定Just like any other project we have conventions that we follow during the development. All third-party contributors are highly recommended to read and follow the conventions listed below before submitting their patches. In general it is also recommended to firstly discuss the issue in Acidanthera Bugtracker before sending the patch to ensure no double work and to avoid your patch being rejected. Organisation. The codebase is structured in multiple repositorieswhich contain separate EDK II packages. AppleSupportPkg and OpenCorePkg are primary packages, and EfiPkg, OcSupportPkg, MacInfoPkg.dsc) are dependent packages. Whenever changes are required in multiple repositories, separate pull requests should be sent to each. Committing the changes should happen firstly to dependent repositories, secondly to primary repositories to avoid automatic build errors. Each unique commit should compile with XCODE5 and preferably with other toolchains. In the majority of the cases it can be checked by accessing the CI interface. Ensuring that static analysis finds no warnings is preferred. External pull requests and tagged commits must be validated. That said, commits in master may build but may not necessarily work. Internal branches should be named as follows: author-name-date, e.g. vit9696-ballooning-20191026. Commit messages should be prefixed with the primary module (e.g. library or code module) the changes were made in. For example, OcGuardLib: Add OC_ALIGNED macro. For non-library changes Docs or Build prefixes are used. Design. The codebase is written in a subset of freestanding C11 (C17) supported by most modern toolchains used by EDK II. Applying common software development practices or requesting clarification is recommended if any particular case is not discussed below. Never rely on undefined behaviour and try to avoid implementation defined behaviour unless explicitly covered below (feel free to create an issue when a relevant case is not present). Use OcGuardLib to ensure safe integral arithmetics avoiding overflows. Unsigned wraparound should be relied on with care and reduced to the necessary amount. Check pointers for correct alignment with OcGuardLib and do not rely on the architecture being able to dereference unaligned pointers. Use flexible array members instead of zero-length or one-length arrays where necessary. Use static assertions (STATIC_ASSERT) for type and value assumptions, and runtime assertions (ASSERT) for precondition and invariant sanity checking. Do not use runtime assertions to check for errors as they should never alter control flow and potentially be excluded. Assume UINT32/INT32 to be int-sized and use %u, %d, and %x to print them. Assume UINTN/INTN to be of unspecified size, and cast them to UINT64/INT64 for printing with %Lu, %Ld and so on as normal. Do not rely on integer promotions for numeric literals. Use explicit casts when the type isimplementation-dependent or suffixes when type size is known. Assume U for UINT32 and ULL for UINT64. Do ensure unsigned arithmetics especially in bitwise maths, shifts in particular. sizeof operator should take variables instead of types where possible to be error prone. Use ARRAY_SIZE to obtain array size in elements. Use L_STR_LEN and L_STR_SIZE macros from OcStringLib to obtain string literal sizes to ensure compiler optimisation. Do not use goto keyword. Prefer early return, break, or continue after failing to pass error checking instead of nesting conditionals. Use EFIAPI, force UEFI calling convention, only in protocols, external callbacks between modules, and functions with variadic arguments. Provide inline documentation to every added function, at least describing its inputs, outputs, precondition, postcondition, and giving a brief description. Do not use RETURN_STATUS. Assume EFI_STATUS to be a matching superset that is to be always used when BOOLEAN is not enough. Security violations should halt the system or cause a forced reboot. Codestyle. The codebase followsEDK II codestyle with few changesand clarifications. Write inline documentation for the functions and variables only once: in headers, where a header prototype is available, and inline for static variables and functions. Use line length of 120 characters or less, preferably 100 characters. Use spaces after casts, e.g. (VOID *)(UINTN) Variable. Use SPDX license headers as shown in acidanthera/bugtracker#483. Debugging. The codebase incorporates EDK II debugging and few custom features to improve the experience. Use module prefixes, 2-5 letters followed by a colon (:), for debug messages. For OpenCorePkg use OC:, for libraries and drivers use their own unique prefixes. Do not use dots (.) in the end of debug messages and separate EFI_STATUS, printed by %r, with a hyphen (e.g. OCRAM: Allocation of %u bytes failed - **%rtextbackslash n).** Use DEBUG_CODE_BEGIN () and DEBUG_CODE_END () constructions to guard debug checks that may potentially reduce the performance of release builds and are otherwise unnecessary. Use DEBUG macro to print debug messages during normal functioning, and RUNTIME_DEBUG for debugging after EXIT_BOOT_SERVICES. Use DEBUG_VERBOSE debug level to leave debug messages for future debugging of the code, which are currently not necessary. By default DEBUG_VERBOSE messages are ignored even in DEBUG builds. Use DEBUG_INFO debug level for all non critical messages (including errors) and DEBUG_BULK_INFO for extensive messages that should not appear in NVRAM log that is heavily limited in size. These messages are ignored in RELEASE builds. Use DEBUG_ERROR to print critical human visible messages that may potentially halt the boot process, and DEBUG_WARN for all other human visible errors, RELEASE builds included. "},{"title":"4. ACPI","url":"/4-acpi.html","content":"4.1 简介ACPI（Advanced Configuration and Power Interface，高级配置和电源接口）是发现和配置计算机硬件的开放标准。ACPI 规格 定义了实现用的标准表（如 DSDT、SSDT、FACS、DMAR）和各种方法（如 _DSM 和 `_PRW）。现代硬件几乎不需要更改即可保持 ACPI 兼容性，但是 OpenCore 仍然提供了修改 ACPI 的方法。 要反汇编和编译 ACPI 表，可以使用由 ACPICA 开发的 iASL compiler。你可以从 Acidanthera/MaciASL 下载 iASL 的图形界面程序。 4.2 属性列表4.2.1 AddType: plist arrayFailsafe: EmptyDescription: 从 OC/ACPI 目录加载指定的 ACPI 表。 设计为用 plist dict 值填充以描述每个块级项目。请参阅下面 4.3 Add 属性 章节。 4.2.2 BlockType: plist arrayFailsafe: EmptyDescription: 从 ACPI 栈中删除选定的表。 设计为用 plist dict 值填充以描述每个块级项目。请参阅下面 4.4 Block 属性 章节。 4.2.3 PatchType: plist arrayFailsafe: EmptyDescription: 在添加或删除 ACPI 表之前执行的二进制修补。 设计为用 plist dictionary 值填充以描述每个块级项目。请参阅下面 4.5 Patch 属性 章节。 4.2.4 QuirksType: plist dictDescription: 应用下文 4.6 Quirks 属性 章节中描述的 Quirks。 4.3 Add 属性4.2.1 CommentType: plist stringFailsafe: Empty stringDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 4.2.2 EnabledType: plist booleanFailsafe: falseDescription: 除非此值为 true，否则此 ACPI 表不会被添加。 4.2.3 PathType: plist stringFailsafe: Empty stringDescription: 需要加载的 ACPI 表所在的路径。示例值如 DSDT.aml、SubDir/SSDT-8.aml、SSDT-USBX.aml。 所有 ACPI 表都从 OC/ACPI 目录加载，加载顺序遵循数组中的项目顺序。 注： 除具有 DSDT 表标识符（由解析得到的数据、而非由其文件名决定）的表外，所有表都将作为新表插入 ACPI 栈。而 DSDT 表与其余的表不同，将会执行 DSDT 表的替换。 4.4 Block 属性4.2.1 AllType: plist booleanFailsafe: falseDescription: 如果设置为 true，则所有符合条件的 ACPI 表都会被舍弃。 否则，只舍弃第一个匹配到的。 4.2.2 CommentType: plist stringFailsafe: Empty stringDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 4.2.3 EnabledType: plist booleanFailsafe: falseDescription: 除非此值为 true，否则此 ACPI 表不会被舍弃。 4.2.4 OemTableIdType: plist data, 8 bytesFailsafe: All zeroDescription: Match table OEM ID to be equal to this value unless all zero. 4.2.5 TableLengthType: plist integerFailsafe: 0Description: Match table size to be equal to this value unless 0. 4.2.6 TableSignatureType: plist data, 4 bytesFailsafe: All zeroDescription: Match table signature to be equal to this value unless all zero. 注： Make sure not to specify table signature when the sequence needs to be replaced in multiple places. Especially when performing different kinds of renames. 4.5 Patch 属性4.5.1 CommentType: plist stringFailsafe: Empty stringDescription: Arbitrary ASCII string used to provide human readable reference for the entry. It is implementation defined whether this value is used. 4.5.2 CountType: plist integerFailsafe: 0Description: Number of patch occurrences to apply. 0 applies the patch to all occurrences found. 4.5.3 EnabledType: plist booleanFailsafe: falseDescription: This ACPI patch will not be used unless set to true. 4.5.4 FindType: plist dataFailsafe: Empty dataDescription: Data to find. Must equal to Replace in size. 4.5.5 LimitType: plist integerFailsafe: 0Description: Maximum number of bytes to search for. Can be set to 0 to look through the whole ACPI table. 4.5.6 MaskType: plist dataFailsafe: Empty dataDescription: Data bitwise mask used during find comparison. Allows fuzzy search by ignoring not masked (set to zero) bits. Can be set to empty data to be ignored. Must equal to Replace in size otherwise. 4.5.7 OemTableIdType: plist data, 8 bytesFailsafe: All zeroDescription: Match table OEM ID to be equal to this value unless all zero. 4.5.8 ReplaceType: plist dataFailsafe: Empty dataDescription: Replacement data of one or more bytes. 4.5.9 ReplaceMarkType: plist dataFailsafe: Empty dataDescription: Data bitwise mask used during replacement. Allows fuzzy replacement by updating masked (set to non-zero) bits. Can be set to empty data to be ignored. Must equal to Replace in size otherwise. 4.5.10 SkipType: plist integerFailsafe: 0Description: Number of found occurrences to be skipped before replacement is done. 4.5.11 TableLengthType: plist integerFailsafe: 0Description: Match table size to be equal to this value unless 0. 4.5.11 TableSignatureType: plist data, 4 bytesFailsafe: All zeroDescription: Match table signature to be equal to this value unless all zero. In the majority of the cases ACPI patches are not useful and harmful: Avoid renaming devices with ACPI patches. This may fail or perform improper renaming of unrelated devices (e.g. EC and EC0), be unnecessary, or even fail to rename devices in select tables. For ACPI consistency it is much safer to rename devices at I/O Registry level, as done by WhateverGreen. Avoid patching _OSI to support a higher level of feature sets unless absolutely required. Commonly this enables a number of hacks on APTIO firmwares, which result in the need to add more patches. Modern firmwares generally do not need it at all, and those that do are fine with much smaller patches. Try to avoid hacky changes like renaming _PRW or _DSM whenever possible. Several cases, where patching actually does make sense, include: Refreshing HPET (or another device) method header to avoid compatibility checks by _OSI on legacy hardware. _STA method with if ((OSFL () == Zero)) { If (HPTE) ... Return (Zero) content may be forced to always return 0xF by replacing A0 10 93 4F 53 46 4C 00 with A4 0A 0F A3 A3 A3 A3 A3. To provide custom method implementation with in an SSDT, for instance, to report functional key presses on a laptop, the original method can be replaced with a dummy name by patching _Q11 with XQ11. Tianocore AcpiAml.h source file may help understanding ACPI opcodes. 4.6 Quirks 属性4.6.1 FadtEnableResetType: plist booleanFailsafe: falseDescription: 在 FADT 表中提供寄存器复位标志，用于修复旧硬件的重启和关机。除非需要，否则不建议启用。 4.6.2 NormalizeHeadersType: plist booleanFailsafe: falseDescription: 清理 ACPI 表头字段以解决 macOS ACPI 实现错误导致的引导崩溃参考: 由 Alex James（theracermaster）在调试 AppleACPIPlatform 时发现。从 macOS Mojave (10.14) 开始，这个错误已经被修复。 4.6.3 RebaseRegionsType: plist booleanFailsafe: falseDescription: 尝试试探性地重定位 ACPI 内存区域。不建议启用这一选项，除非你需要自定义 DSDT。 ACPI 表通常由底层固件动态生成。在与位置无关的代码中，ACPI 表可能包含用于设备配置的 MMIO 区域的物理地址，通常按区域（例如 OperationRegion）分组。 更改固件设置或硬件配置，升级或修补固件不可避免地会导致动态生成的 ACPI 代码发生变化，这有时会导致上述 OperationRegion 结构中的地址发生变化。 因此，对 ACPI 表进行任何形式的修改都是非常危险的。最合理的方法是对 ACPI 进行尽可能少的更改，并尝试不替换任何表，尤其是 DSDT。 如果无法不得不替换 DSDT，则至少应尝试确保自定义 DSDT 基于最新的 DSDT 或避免对受影响区域的读写。如果没有其他帮助，可以尝试通过尝试修复 ACPI 地址来避免在 macOS 引导的 PCI Configuration Begin 阶段出现停顿的情况。 4.6.4 ResetHwSigType: plist booleanFailsafe: falseDescription: Reset FACS table HardwareSignature value to 0. 启用这一选项可以解决固件无法在重新启动过程中保持硬件签名导致的休眠唤醒问题。 4.6.5 ResetLogoStatusType: plist booleanFailsafe: falseDescription: 将 BGRT 表中 Displayed 状态字段重置为 false. 这适用于提供 BGRT 表、但随后无法处理屏幕更新的固件。如果在开机时无法显示 OEM Windows 标志的硬件可以尝试开启开启。"},{"title":"5. Booter","url":"/5-booter.html","content":"5.1 简介This section allows to apply different kinds of UEFI modifications on Apple bootloader (boot.efi). The modifications currently provide various patches and environment alterations for different firmwares. Some of these features were originally implemented as a part of AptioMemoryFix.efi, which is no longer maintained. See Tips and Tricks section for migration steps. If you are using this for the first time on a customised firmware, there is alist of checks to do first. Prior to starting please ensure that you have: Most up-to-date UEFI firmware (check your motherboard vendor website). Fast Boot and Hardware Fast Boot disabled in firmware settings if present. Above 4G Decoding or similar enabled in firmware settings if present. Note, that on some motherboards (notably ASUS WS-X299-PRO) this option causes adverse effects, and must be disabled. While no other motherboards with the same issue are known, consider this option to be first to check if you have erratic boot failures. DisableIoMapper quirk enabled, or VT-d disabled in firmware settings if present, or ACPI DMAR table dropped. No slide boot argument present in NVRAM or anywhere else. It is not necessary unless you cannot boot at all or see No slide values are usable! Use custom slide! message in the log. CFG Lock (MSR 0xE2 write protection) disabled in firmware settings if present. Cconsider patching it if you have enough skills and no option is available. See VerifyMsrE2 nots for more details. CSM (Compatibility Support Module) disabled in firmware settings if present. You may need to flash GOP ROM on NVIDIA 6xx/AMD 2xx or older. Use GopUpdate or AMD UEFI GOP MAKER in case you are not sure how. EHCI/XHCI Hand-off enabled in firmware settings only if boot stalls unless USB devices are disconnected. VT-x, Hyper Threading, Execute Disable Bit enabled in firmware settings if present. While it may not be required, sometimes you have to disable Thunderbolt support, Intel SGX, and Intel Platform Trust in firmware settings present. When debugging sleep issues you may want to (temporarily) disable Power Nap and automatic power off, which appear to sometimes cause wake to black screen or boot loop issues on older platforms. The particular issues may vary, but in general you shouldcheck ACPI tables first. Here is an example of a bug found in some Z68 motherboards. To turn Power Nap and the others off run the following commands in Terminal: 注： These settings may reset at hardware change and in certain other circumstances.To view their current state use pmset -g command in Terminal. 5.2 属性列表5.2.1 MmioWhitelistType: plist arrayDescription: Designed to be filled with plist dict values, describing addresses critical for particular firmware functioning when DevirtualiseMmio quirk is in use. See MmioWhitelist Properties section below. 译者注：如果开机卡在 PCI... 可以尝试开启 Item 1 下的 Patch 5.2.2 QuirksType: plist dictDescription: Apply individual booter quirks described in Quirks Properties section below. 5.3 MmioWhitelist 属性5.3.1 AddressType: plist integerFailsafe: 0Description: Exceptional MMIO address, which memory descriptor should be left virtualised (unchanged) by DevirtualiseMmio. This means that the firmware will be able to directly communicate with this memory region during operating system functioning, because the region this value is in will be assigned a virtual address. 5.3.2 CommentType: plist stringFailsafe: Empty stringDescription: Arbitrary ASCII string used to provide human readable reference for the entry. It is implementationdefined whether this value is used. 5.3.3 EnabledType: plist booleanFailsafe: falseDescription: This address will be devirtualised unless set to true. 5.4 Quirks 属性5.4.1 AvoidRuntimeDefragType: plist booleanFailsafe: falseDescription: 防止 boot.efi 运行时执行内存碎片整理 这个选项通过提供对可变存储的支持，修复了包括日期、时间、NVRAM、电源控制等 UEFI Runtime 服务。 注: 除 Apple 和 VMware 固件外，都需要启用此选项。 5.4.2 DevirtualiseMmioType: plist booleanFailsafe: falseDescription: 从选定的 MMIO 区域中删除 Runtime 属性。 通过删除已知内存区域的 runtime bit，此选项可减少内存映射中 stolen memory footprint。 这个 Quirks 可能会导致可用的 KASLR slides 增加，但如果没有其他措施，不一定与目标主板兼容。 通常，这会释放 64 到 256 MB的内存（具体数值会显示在调试日志中）。在某些平台上这是引导 macOS 的唯一方法，否则在引导加载程序阶段会出现内存分配错误。 该选项通常对所有固件都有用，除了一些非常古老的固件（例如 Sandy Bridge）。 在某些固件上，它可能需要一个例外映射列表。为了使 NVRAM 和休眠功能正常工作，获取其虚拟地址仍然是必要的。 请参考 MmioWhitelist 章节来实现这个。 5.4.3 DisableSingleUserType: plist booleanFailsafe: falseDescription: 禁用 Apple 单用户模式 这个选项可以禁用 CMD+S 热键和 -s 启动参数来限制单用户模式。启用这一 Quirks 后预期行为应和 T2 的模型行为类似。请参考 Apple 的 这篇文章 以了解如何在启用这一 Quirks 后继续使用单用户模式。 5.4.4 DisableVariableWriteType: plist booleanFailsafe: falseDescription: 防止 macOS 获取 NVRAM 的写入权限。 这个选项可以限制 macOS 对 NVRAM 的写入。这个 Quirk 需要 FwRuntimeServices.efi 提供了 OC_FIRMWARE_RUNTIME 协议的实现. 注: 这个 Quirk 也可以避免由于无法将变量写入 NVRAM 而导致的对操作系统的破坏。 译者注：在 Z390/HM370 等没有原生 macOS 支持 NVRAM 的主板上需要开启。 5.4.5 DiscardHibernateMapType: plist booleanFailsafe: falseDescription: 复用原始的休眠内存映射。 这一选项强制 XNU 内核忽略新提供的内存映射、认定设备从休眠状态唤醒后无需对其更改。如果你在使用 Windows，则 务必启用 这一选项，因为 Windows 要求 S4 花心后保留运行内存的大小和未知。 注: 这可能用于解决较旧硬件上的错误内存映射。如 Insyde 固件的 Ivy Bridge 笔记本电脑或者 Acer V3-571G。 除非您完全了解这一选项可能导致的后果，否则请勿使用此功能。 5.4.6 EnableSafeModeSlideType: plist booleanFailsafe: falseDescription: 修补引导加载程序以在安全模式下启用 KASLR。 这个选与启动到安全模式（启动时按住 Shift 或受用了 -x 启动参数）有关。默认情况下，安全模式会使用 slide=0，这个 Quirks 试图通过修补 boot.efi 接触这一限制。只有当 ProvideCustomSlide 启用后才可以启用本 Quirks。 注: 除非启动到安全模式失败，否则不需要启用此选项。 5.4.7 EnableWriteUnprotectorType: plist booleanFailsafe: falseDescription: 关闭 CR0 寄存器中的写入保护 This option bypasses RX̂ permissions in code pages of UEFI runtime services by removing write protection (WP) bit from CR0 register during their execution. This quirk requires OC_FIRMWARE_RUNTIME protocol implemented in FwRuntimeServices.efi. 注：The necessity of this quirk is determined by early boot crashesof the firmware. 5.4.8 ForceExitBootServicesType: plist booleanFailsafe: falseDescription: 开启后会确保 ExitBootServices 即使在 MemoryMap 发生更改时也能调用成功 Try to ensure that ExitBootServices call succeeds even with outdated MemoryMap key argument by obtaining current memory map and retrying ExitBootServices call. 注：The necessity of this quirk is determined by early boot crashes of the firmware. 请勿启用这一选项，除非你详细了解这一选项可能导致的后果。 5.4.9 ProtectCsmRegionType: plist booleanFailsafe: falseDescription: 保护 CSM 区域免于重新分配 确保将 CSM 内存区域标记为 ACPI NVS，以防止 boot.efi 或 XNU 重新定位或使用这一区域。 注：是否启用这一 Quirk 取决于你是否遇到了休眠或其他问题。AvoidRuntimeDefrag 理应能够解决所有类似的问题，所以已知的固件都不需要启用这一选项。除非你完全了解这一选项及其后果，否则请勿使用。 5.4.10 ProtectSecureBootType: plist booleanFailsafe: falseDescription: 保护 UEFI 安全启动变量不被写入。 尝试从操作系统写入 db、dbx、PK 和 KEK 时生成报告。 注：这个 Quirk 主要试图避免碎片整理导致的 NVRAM 相关问题，如 Insyde 或 MacPro5,1。 5.4.11 ProvideCustomSlideType: plist booleanFailsafe: falseDescription: 为低内存设备提供自定义 KASLR slide 值。 开启这个选项后，将会对固件进行内存映射分析，检查所有 slide（从 1 到 255）中是否有可用的。由于 boot.efi 私用 rdrand 或伪随机 rdtsc 随机生成此值，因此有可能出现冲突的 slide 值被使用并导致引导失败。如果出现潜在的冲突，这个选项将会强制为 macOS 选择一个伪随机值。这同时确保了 slide= 参数不会被传递给操作系统。 注: OpenCore 会自动检查是否需要启用这一选项。如果 OpenCore 的调试日志中出现 OCABC: Only N/256 slide values are usable! 则请启用这一选项。 5.4.12 SetupVirtualMapType: plist booleanFailsafe: falseDescription: 将 SetVirtualAddresses 调用修复为虚拟地址. Select firmwares access memory by virtual addresses after SetVirtualAddresses call, which results in early boot crashes. This quirk workarounds the problem by performing early boot identity mapping of assigned virtual addresses to physical memory. 注：是否启用这个 Quirks 取决于你是否遇到了 Early Boot 故障。目前具有内存保护支持的新固件（例如 OVMF ）由于一些原因不支持此 Quirks：acidanthera/bugtracker#719。 5.4.13 ShrinkMemoryMapType: plist booleanFailsafe: falseDescription: 尝试合并相似的内存映射条目。 Select firmwares have very large memory maps, which do not fit Apple kernel, permitting up to 64 slots for runtime memory. This quirk attempts to unify contiguous slots of similar types to prevent boot failures. 注: 是否启用这个 Quirks 取决于你是否遇到了 Early Boot 故障。Haswell 及更新版本一般都不需要启用。除非你完全了解这一选项及其后果，否则请勿使用。 5.4.14 SignalAppleOSType: plist booleanFailsafe: falseDescription: 不论使用什么操作系统、总是向 OSInfo 报告启动的是 macOS。 Mac 设备在不同的操作系统中具有不同的行为，因此如果你在使用 Mac 设备，这一功能会非常有用。例如，你可以通过启用这一选项为某些双 GPU 的 MacBook 型号中在 Windows 和 Linux 中启用 Intel GPU。"},{"title":"6. DeviceProperties","url":"/6-device-properties.html","content":"6.1 简介设备相关配置通过专用的缓存区（EfiDevicePropertyDatabase）提供给 macOS，这个缓冲区是设备路径到属性名称与值的键值对的序列化映射。 属性相关数据可以使用 gfxutil 进行调试。在 macOS 下获取当前属性数据请使用 ioreg： 6.2 属性列表6.2.1 AddType: plist dictDescription: Sets device properties from a map (plist dict) of deivce paths to a map (plist dict) of variable names and their values in plist metadata format. Device paths must be provided in canonic string format (e.g. PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)). Properties will only be set if not present and not blocked.注： 目前，属性只能通过原始驱动程序添加。因此除非安装了单独的驱动程序，否则没有理由 Block 变量。 6.2.2 BlockType: plist dictDescription: 从设备路径的映射（数据类型 plist dict）到 plist 字符串格式的变量名数组（数据类型 plist array）中删除设备属性。 译者注：这里的设置等同于 Clover 里的 ACPI 重命名 _DSM → XDSM =&gt; TgtBridge 6.3 常见属性一些常见的属性包括： device-id用户指定的设备标识符，用于 I/O 套件匹配。数据类型为 4 byte data. vendor-id用户指定的供应商标识符，用于 I/O 套件匹配。数据类型为 4 byte data. AAPL,ig-platform-idIntel GPU 缓冲帧标识符，用于在 Ivy Bridge 上选择缓冲帧区域。数据类型为 4 byte data。 AAPL,snb-platform-idIntel GPU 缓冲帧标识符，用于在 Sandy Bridge 上选择缓冲帧区域。数据类型为 4 byte data。 layout-idAppleHDA 的音频布局，4 byte data。 "},{"title":"7. Kernel","url":"/7-kernel.html","content":"7.1 简介This section allows to apply different kinds of kernelspace modifications on Apple Kernel (XNU). The modifications currently provide driver (kext) injection, kernel and driver patching, and driver blocking. 7.2 属性列表7.2.1 AddType: plist arrayFailsafe: EmptyDescription: Load selected kernel drivers from OC/Kexts directory. Designed to be filled with plist dict values, describing each driver. See Add Properties section below. Kernel driver load order follows the item order in the array, thus the dependencies should be written prior to theirconsumers. 7.2.2 BlockType: plist arrayFailsafe: EmptyDescription: Remove selected kernel drivers from prelinked kernel. Designed to be filled with plist dictionary values, describing each blocked driver. See Block Properties section below. 7.2.3 EmulateType: plist dictDescription: Emulate select hardware in kernelspace via parameters described in Emulate Properties section below. 7.2.4 PatchType: plist arrayFailsafe: EmptyDescription: Perform binary patches in kernel and drivers prior to driver addition and removal. Designed to be filled with plist dictionary values, describing each patch. See Patch Properties section below. 7.2.5 QuirksType: plist dictDescription: Apply individual kernel and driver quirks described in Quirks Properties section below. 7.3 Add 属性7.3.1 BundlePathType: plist stringFailsafe: Empty stringDescription: Kext 相对于 EFI/OC/kexts/Other/ 的路径 (e.g. Lilu.kext or MyKext.kext/Contents/PlugIns/MySubKext.kext). 注，如 VoodooPS2Controller.kext 这种包括其他 kext 驱动的，需要分别单独添加，如 VoodooPS2Controller.kext/Contents/PlugIns/VoodooPS2Keyboard.kext。 7.3.2 CommentType: plist stringFailsafe: Empty stringDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 7.3.3 EnabledType: plist booleanFailsafe: falseDescription: 是否加载该驱动. 7.3.4 ExecutablePathType: plist stringFailsafe: Empty stringDescription: Kext 中实际可执行文件的路径（如 Lilu.kext 中的可执行文件路径是 Contents/MacOS/Lilu）。 译者注：空壳 Kext 没有可执行文件（如 USBPorts.kext），此项留空即可 7.3.5 MaxKernelType: plist stringFailsafe: Empty stringDescription: Adds kernel driver on specified macOS version or older. Kernel version can be obtained with uname -r command, and should look like 3 numbers separated by dots, for example 18.7.0 is the kernel version for 10.14.6. Kernel version interpretation is implemented as follows: Kernel version comparison is implemented as follows: Here ParseDarwinVersion argument is assumed to be 3 integers obtained by splitting Darwin kernel version string from left to right by the . symbol. FindDarwinVersion function looks up Darwin kernel version by locating string in the kernel image. 7.3.6 MinKernelType: plist stringFailsafe: Empty stringDescription: Adds kernel driver on specified macOS version or newer. 注：Refer to Add MaxKernel description formatching logic. 7.3.7 PlistPathType: plist stringFailsafe: Empty stringDescription: Kext 中 Info.plist 文件的路径。一般为 Contents/Info.plist。 7.4 Block 属性7.4.1 CommentType: plist stringFailsafe: Empty stringDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 7.4.2 EnabledType: plist booleanFailsafe: falseDescription: This kernel driver will not be blocked unless set to true. 7.4.3 IdentifierType: plist stringFailsafe: Empty stringDescription: Kext bundle identifier (e.g.com.apple.driver.AppleTyMCEDriver). 7.4.4 MaxKernelType: plist stringFailsafe: Empty stringDescription: Blocks kernel driver on specified macOS version or older. 注：Refer to Add MaxKernel description for matching logic. 7.4.5 MinKernelType: plist stringFailsafe: Empty stringDescription: Blocks kernel driver on specified macOS version or newer. 注：Refer to Add MaxKernel description formatching logic. 7.5 Emulate 属性7.5.1 Cpuid1DataType: plist data, 16 bytesFailsafe: All zeroDescription: Sequence of EAX, EBX, ECX, EDX values to replace CPUID (1) call in XNU kernel. This property serves for two needs: Enabling support of an unsupported CPU model. Enabling XCPM support for an unsupported CPU variant. Normally it is only the value of EAX that needs to be taken care of, since it represents the full CPUID. The remaining bytes are to be left as zeroes. Byte order is Little Endian, so for example, A9 06 03 00 stands for CPUID 0x0306A9 (Ivy Bridge). For XCPM support it is recommended to use the following combinations. Haswell-E (0x306F2) to Haswell (0x0306C3): Cpuid1Data: C3 06 03 00 00 00 00 00 00 00 00 00 00 00 00 00Cpuid1Mask: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 Broadwell-E (0x0406F1) to Broadwell (0x0306D4):Cpuid1Data: D4 06 03 00 00 00 00 00 00 00 00 00 00 00 00 00Cpuid1Mask: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 Further explanations can be found at acidanthera/bugtracker#365. See Special NOTES for Haswell+ low-end. 7.5.2 Cpuid1MaskType: plist data, 16 bytesFailsafe: All zeroDescription: Bit mask of active bits in Cpuid1Data. When each Cpuid1Mask bit is set to 0, the original CPU bit is used,otherwise set bits take the value of Cpuid1Data. 7.6 Patch 属性7.6.1 BaseType: plist stringFailsafe: Empty stringDescription: Selects symbol-matched base for patch lookup (or immediate replacement) by obtaining the address of provided symbol name. Can be set to empty string to be ignored. 7.6.2 CommentType: plist stringFailsafe: Empty stringDescription: Arbitrary ASCII string used to provide human readable reference for the entry. It is implementation defined whether this value is used. 7.6.3 CountType: plist integerFailsafe: 0Description: Number of patch occurrences to apply. 0 applies the patch to all occurrences found. 7.6.4 EnabledType: plist booleanFailsafe: falseDescription: This kernel patch will not be used unless set to true. 7.6.5 FindType: plist dataFailsafe: Empty dataDescription: Data to find. Can be set to empty for immediate replacement at Base. Must equal to Replace in size otherwise. 7.6.6 IdentifierType: plist stringFailsafe: Empty stringDescription: Kext bundle identifier (e.g.com.apple.driver.AppleHDA) or kernel for kernel patch. 7.6.7 LimitType: plist integerFailsafe: 0Description: Maximum number of bytes to search for. Can be set to 0 to look through the whole kext or kernel. 7.6.8 MaskType: plist dataFailsafe: Empty dataDescription: Data bitwise mask used during find comparison. Allows fuzzy search by ignoring not masked (set to zero) bits. Can be set to empty data to be ignored. Must equal to Replace in size otherwise. 7.6.9 MaxKernelType: plist stringFailsafe: Empty stringDescription: Patches data on specified macOS version or older. 注：Refer to Add MaxKernel description for matching logic. 7.6.10 MinKernelType: plist stringFailsafe: Empty stringDescription: Patches data on specified macOS version or newer. 注：Refer to Add MaxKernel description for matching logic. 7.6.11 ReplaceType: plist dataFailsafe: Empty dataDescription: Replacement data of one or more bytes. 7.6.12 ReplaceMaskType: plist dataFailsafe: Empty dataDescription: Data bitwise mask used during replacement. Allows fuzzy replacement by updating masked (set to non-zero) bits. Can be set to empty data to be ignored. Must equal to Replace in size otherwise. 7.6.13 SkipType: plist integerFailsafe: 0Description: Number of found occurrences to be skipped before replacement is done. 7.7 Quirks 属性AppleCpuPmCfgLockType: plist booleanFailsafe: falseDescription: 禁用 AppleIntelCPUPowerManagement.kext 中的 PKG_CST_CONFIG_CONTROL (0xE2) 修改，从而避免早期 Kernel Panic。 某些固件会锁定 PKG_CST_CONFIG_CONTROL MSR 寄存器。可以使用捆绑的 VerifyMsrE2 工具检查其状态。 由于现代固件已经提供了 CFG Lock 相关设置、从而可以配置 PKG_CST_CONFIG_CONTROL 寄存器锁定，此选项应该尽可能避免。对于一些不显示 CFG Lock 配置的固件，可以按照下述配置进行修改： 下载 UEFITool 和 IFR-Extractor 使用 UEFITool 中打开固件镜像文件，找到 CFG Lock 的 Unicode 字符串。如果你没有找到，意味着你的固件可能不支持 CFG Lock 解锁，那么你现在可以停下来了。 从 UEFITool 菜单中的 Extract Body 选项提取 Setup.bin 中的 PE32 镜像部分。 对提取出来的文件执行 IFR-Extractor（./ifrextract Setup.bin Setup.txt）。 从 Setup.txt 中找到 CFG Lock，VarStoreInfo（或者 VarOffset、VarName），记住紧随其后的偏移量值（例如 0x123）。 下载并执行由 brainsucker 编译的 修改版 GRUB Shell。你也可以是使用 datasone 制作的 新版本 GRUB Shell。 在 GRUB Shell 中，使用 setup_var 0x123 0x00（其中 0x123 应该被替换为你在前几步找到的偏移值），然后重启电脑。 警告: 可变偏移量对于每个主板乃至每一个固件版本都是唯一的。永远不要尝试使用别人的偏移量！ AppleXcpmCfgLockType: plist booleanFailsafe: falseDescription: 禁用 XNU 内核对 PKG_CST_CONFIG_CONTROL (0xE2) 修改，从而避免早期 Kernel Panic。 注：这一选项应该避免被使用，请参考上文中关于 AppleCpuPmCfgLock 的介绍。 AppleXcpmExtraMsrsType: plist booleanFailsafe: falseDescription: 对于没有 XCMP 支持的设备，禁用对选定 CPU 的多 MSR 访问。 通常将其与 Haswell-E，Broadwell-E，Skylake-X和类似 CPU 的 Emulate 结合使用。更多关于 XCPM 修补的信息可以在 acidanthera/bugtracker#365 找到。 注：Ivy Bridge 或 Pentium CPU 将需要其他未提供的补丁。建议对前者使用 AppleIntelCpuPowerManagement.kext。 AppleXcpmForceBoostType: plist booleanFailsafe: falseDescription: 在 XCPM 模式下强制使用最大性能。 This patch writes 0xFF00 to MSR_IA32_PERF_CONTROL (0x199), effectively setting maximum multiplier for all the time. 注：尽管有助于提高性能，但是在所有操作系统上都强烈建议不要启用这一选项。只有在某些 Xeon 型号的 CPU 才有可能从这个选项中受益。 CustomSMBIOSGuidType: plist booleanFailsafe: falseDescription: 对 UpdateSMBIOSMode 自定义模式执行 GUID 修补，通常用于戴尔笔记本电脑。 DisableIoMapperType: plist booleanFailsafe: falseDescription: 禁用 XNU (VT-d) 中的 IOMapper 支持，这可能与固件的实现相冲突。 注：相比直接在 ACPI 表中删除 DMAR，我们更推荐大家使用这一选项。这样不会破坏其他操作系统中的 VT-d 支持（总会有人需要用到的，对吧？）。 DummyPowerManagementType: plist booleanFailsafe: falseDescription: 禁用 AppleIntelCpuPowerManagement。 注：这一选项旨在替代 NullCpuPowerManagement.kext，用于 macOS 中没有电源管理驱动程序的 CPU。 ExternalDiskIconsType: plist booleanFailsafe: falseDescription: 修补 AppleAHCIPort.kext 图标，使 macOS 将所有 AHCI 存储设备显示为内部硬盘。 注：这一选项应尽量避免使用。现代固件通常情况下都是兼容的。 IncreasePciBarSizeType: plist booleanFailsafe: falseDescription: 将 IOPCIFamily 中 32 位 PCI Bar 的大小从 1 GB 增加到 4 GB。 注：你应该尽可能避免使用这一选项。通常这一选项只需要在配置错误或损坏的固件上开启。 译者注：如果你的 BIOS 中存在 Above4GDecoding 选项，请直接在 BIOS 中启用。 LapicKernelPanicType: plist booleanFailsafe: falseDescription: 禁用 LAPIC 中断导致的 Kernal Panic。 译者注：惠普电脑可能需要启用这一选项。 PanicNoKextDumpType: plist booleanFailsafe: falseDescription: 在发生内核崩溃时阻止输出 Kext 列表，提供可供排错参考的崩溃日志。 PowerTimeoutKernelPanicType: plist booleanFailsafe: falseDescription: 修复 macOS Catalina 中由于设备电源状态变化超时而导致的内核崩溃。 An additional security measure was added to macOS Catalina (10.15) causing kernel panic on power change timeout for Apple drivers. Sometimes it may cause issues on misconfigured hardware, notably digital audio, which sometimes fails to wake up. For debug kernels setpowerstate_panic=0 boot argument should be used, which is otherwise equivalent to this quirk. ThirdPartyDrivesType: plist booleanFailsafe: falseDescription: 修补 IOAHCIBlockStorage.kext，以在第三方驱动器启用 TRIM、硬盘休眠等功能。 注：NVMe SSD 通常无需这一修改。对于 AHCI SSD（如 SATA SSD），macOS 从 10.15 开始提供 trimforce，可以将 01 00 00 00 值写入 APPLE_BOOT_VARIABLE_GUID 命名空间中的 EnableTRIM 变量。 XhciPortLimitType: plist booleanFailsafe: falseDescription: 修补 AppleUSBXHCI.kext、AppleUSBXHCIPCI.kext、IOUSBHostFamily.kext 以移除 15 端口限制。 注：请尽可能避免使用这一选项。USB port limit is imposed by the amount of used bits in locationID format and there is no possible way to workaround this without heavy OS modification. The only valid solution is to limit the amount of used ports to 15 (discarding some). More details can be found on AppleLife.ru."},{"title":"8. Misc","url":"/8-misc.html","content":"8.1 IntroductionThis section contains miscellaneous configuration entries for OpenCore behaviour that does not go to any other sections. 8.2 Properties1. BootType: plist dictDescription: Apply boot configuration described in Boot Properties section below. 2. BlessOverrideType: plist arrayDescription: 通过 Bless Model 添加自定义扫描路径。 Designed to be filled with plist string entries containing absolute UEFI paths to customised bootloaders, for example, \\EFI\\Microsoft\\Boot\\bootmgfw.efi for Microsoft bootloader. This allows unusual boot paths to be automaticlly discovered by the boot picker. Designwise they are equivalent to predefined blessed path, such as \\System\\Library\\CoreServices\\boot.efi, but unlike predefined bless paths they have highest priority. 3. DebugType: plist dictDescription: Apply debug configuration described in Debug Properties section below. 4. EntriesType: plist arrayDescription: Add boot entries to boot picker. Designed to be filled with plist dict values, describing each load entry. See Entry Properties section below. 5. SecurityType: plist dictDescription: Apply security configuration described in Security Properties section below. 6. ToolsType: plist arrayDescription: Add tool entries to boot picker. Designed to be filled with plist dict values, describing each load entry. See Entry Properties section below. 注：Select tools, for example, UEFI Shell are very dangerous and MUST NOT appear in production configurations, especially in vaulted ones and protected with secure boot, as they may be used to easily bypass secure boot chain. 8.3 Boot PropertiesHibernateModeType: plist stringFailsafe: NoneDescription: 休眠检测模式。 支持以下模式： None — 禁用休眠 Auto — 从 RTC 或 NVRAM 中检测 RTC — 从 RTC 检测 NVRAM — 从 NVRAM 检测 HideAuxiliaryType: plist booleanFailsafe: falseDescription: 默认情况下，隐藏开机引导项菜单中的辅助条目。 满足任一以下条件的引导项条目即会被视为「辅助项目」 该引导项是 macOS Recovery 分区 该引导项被标记为 Auxiliary 该引导项是一个系统（如 Clean NVRAM） 即使被隐藏，你仍然可以通过 空格 进入「扩展模式」查看所有条目（引导项菜单会被重新加载）： 一般的，隐藏辅助条目有助于加快启动速度。 HideSelfType: plist booleanFailsafe: falseDescription: 在 OpenCore 的启动选择中隐藏自身 EFI 分区内的其它启动项，如 UEFI OS 等。 PickerAttributesType: plist integerFailsafe: 0Description: Sets specific attributes for picker. Builtin picker supports colour arguments as a sum of foreground and background colors according to UEFI specification. The value of black background and black foreground (0) is reserved. List of colour names: 0x00 — EFI_BLACK 0x01 — EFI_BLUE 0x02 — EFI_GREEN 0x03 — EFI_CYAN 0x04 — EFI_RED 0x05 — EFI_MAGENTA 0x06 — EFI_BROWN 0x07 — EFI_LIGHTGRAY 0x08 — EFI_DARKGRAY 0x09 — EFI_LIGHTBLUE 0x0A — EFI_LIGHTGREEN 0x0B — EFI_LIGHTCYAN 0x0C — EFI_LIGHTRED 0x0D — EFI_LIGHTMAGENTA 0x0E — EFI_YELLOW 0x0F — EFI_WHITE 0x00 — EFI_BACKGROUND_BLACK 0x10 — EFI_BACKGROUND_BLUE 0x20 — EFI_BACKGROUND_GREEN 0x30 — EFI_BACKGROUND_CYAN 0x40 — EFI_BACKGROUND_RED 0x50 — EFI_BACKGROUND_MAGENTA 0x60 — EFI_BACKGROUND_BROWN 0x70 — EFI_BACKGROUND_LIGHTGRAY 注：This option may not work well with System text renderer.Setting a background different from black could help testing proper GOP functioning. PollAppleHotKeysType: plist booleanFailsafe: falseDescription: 在开机引导菜单中启用 modifier hotkey。 In addition to action hotkeys, which are partially described in PickerMode section and are normally handled by Apple BDS, there exist modifier keys, which are handled by operating system bootloader, namely boot.efi. These keys allow to change operating system behaviour by providing different boot modes. On some firmwares it may be problematic to use modifier keys due to driver incompatibilities. To workaround this problem this option allows registering select hotkeys in a more permissive manner from within boot picker. Such extensions include the support of tapping on keys in addition to holding and pressing Shift along with other keys instead of just Shift alone, which is not detectible on many PS/2 keyboards. This list of known modifier hotkeys includes: CMD+C+MINUS — disable board compatibility checking. CMD+K — boot release kernel, similar to kcsuffix=release. CMD+R — 从恢复分区启动。 CMD+S — 启动至单用户模式。 CMD+S+MINUS — disable KASLR slide, requires disabled SIP. CMD+V — 启用 -v。 Shift — 启用安全模式。 ShowPickerType: plist booleanFailsafe: falseDescription: 是否显示开机引导项。 TakeoffDelayType: plist integer, 32 bitFailsafe: 0Description: Delay in microseconds performed before handlingpicker startup and action hotkeys. Introducing a delay may give extra time to hold the right action hotkey sequence to e.g. boot to recovery mode. On some platforms setting this option to at least 5000-10000 microseconds may be necessary to access action hotkeys at all due to the nature of the keyboard driver. 译者注：0 为关闭倒计时而非跳过倒计时，相当于 Clover 的 -1。 TimeoutType: plist integer, 32 bitFailsafe: 0Description: Timeout in seconds in boot picker before automatic booting of the default boot entry. Use 0 to disable timer. PickerModeType: plist stringFailsafe: BuiltinDescription: Choose boot picker used for boot management. Picker describes underlying boot management with an optional user interface responsible for handling boot options. The following values are supported: Builtin — boot management is handled by OpenCore, a simpletext only user interface is used. External — an external boot management protocol is usedif available. Otherwise Builtin mode is used. Apple — Apple boot management is used if available.Otherwise Builtin mode is used. Upon success External mode will entirely disable all boot management in OpenCore except policy enforcement. In Apple mode it may additionally bypass policy enforcement. To implement External mode a custom user interface may utilise OcSupportPkg OcBootManagementLib. Reference example of external graphics interface is provided in ExternalUi test driver. OpenCore built-in boot picker contains a set of actions chosen during the boot process. The list of supported actions is similar to Apple BDS and in general can be accessed by holding action hotkeys during boot process. Currently the following actions are considered: Default — this is the default option, and it lets OpenCore built-in boot picker to loads the default boot option as specified in Startup Disk preference pane. ShowPicker — this option forces picker to show. Normally it can be achieved by holding OPT key during boot. Setting ShowPicker to true will make ShowPicker the default option. ResetNvram — this option performs select UEFI variable erase and is normally achieved by holding CMD+OPT+P+R key combination during boot. Another way to erase UEFI variables is to choose Reset NVRAM in the picker. This option requires AllowNvramReset to be set to true. BootApple — this options performs booting to the first found Apple operating system unless the default chosen operating system is already made by Apple. Hold X key to choose this option. BootAppleRecovery — this option performs booting to Apple operating system recovery. Either the one related to the default chosen operating system, or first found in case default chosen operating system is not made by Apple or has no recovery. Hold CMD+R key combination to choose this option. Note 1: Activated KeySupport, AppleUsbKbDxe, or similar driver is required for key handling to work. On many firmwares it is not possible to get all the keys function. Note 2: In addition to OPT OpenCore supports Escape key to display picker when ShowPicker is disabled. This key exists for Apple picker mode and for firmwares with PS/2 keyboards that fail to report held OPT key and require continual presses of Escape key to enter the boot menu. Note 3: On Macs with problematic GOP it may be difficult to access Apple BootPicker. To workaround this problem even without loading OpenCore BootKicker utility can be blessed. 8.4 Debug Properties1. DisableWatchDogType: plist booleanFailsafe: falseDescription: 某些固件可能无法成功快速启动操作系统，尤其是在调试模式下，这会导致看门狗定时器中止引导过程。此选项关闭看门狗定时器，用于排错。 2. DisplayDelayType: plist integerFailsafe: 0Description: 屏幕上打印每行输出之间的延迟。 3.DisplayLevelType: plist integer, 64 bitFailsafe: 0Description: EDK II debug level bitmask (sum) showed onscreen. Unless Target enables console (onscreen) printing, onscreen debug output will not be visible. The following levels are supported (discover more in DebugLib.h): 0x00000002 (bit 1) — DEBUG_WARN in DEBUG, NOOPT, RELEASE. 0x00000040 (bit 6) — DEBUG_INFO in DEBUG, NOOPT. 0x00400000 (bit 22) — DEBUG_VERBOSE in custom builds. 0x80000000 (bit 31) — DEBUG_ERROR in DEBUG, NOOPT, RELEASE. 4. TargetType: plist integerFailsafe: 0Description: A bitmask (sum) of enabled logging targets. By default all the logging output is hidden, so this option is required to be set when debugging is necessary. The following logging targets are supported: 0x01 (bit 0) — Enable logging, otherwise all log is discarded. 0x02 (bit 1) — 在屏幕上输出日志 0x04 (bit 2) — Enable logging to Data Hub. 0x08 (bit 3) — Enable serial port logging. 0x10 (bit 4) — Enable UEFI variable logging. 0x20 (bit 5) — Enable non-volatile UEFI variable logging. 0x40 (bit 6) — 启用在 ESP 分区生成日志文件 Console logging prints less than all the other variants. Depending on the build type (RELEASE, DEBUG, or NOOPT) different amount of logging may be read (from least to most). Data Hub 日志中不包括 Kernel 和 Kext 的日志。要获取 Data Hub 日志，请使用 ioreg： UEFI variable log does not include some messages and has no performance data. For safety reasons log size is limited to 32 kilobytes. Some firmwares may truncate it much earlier or drop completely if they have no memory. Using non-volatile flag will write the log to NVRAM flash after every printed line. To obtain UEFI variable log use the following commandin macOS: 警告: Some firmwares are reported to have broken NVRAM garbage collection. This means that they may not be able to always free space after variable deletion. Do not use non-volatile NVRAM logging without extra need on such devices. While OpenCore boot log already contains basic version information with build type and date, this data may also be found in NVRAM in opencore-version variable even with boot log disabled. File logging will create a file named opencore-YYYY-MM-DD-HHMMSS.txt at EFI volume root with log contents (the upper case letter sequence is replaced with date and time from the firmware). Please be warned that some file system drivers present in firmwares are not reliable, and may corrupt data when writing files through UEFI. Log is attempted to be written in the safest manner, and thus is very slow. Ensure that DisableWatchDog is set to true when you use a slow drive. 8.5 Security Properties1. AllowNvramResetType: plist booleanFailsafe: falseDescription: 启用这一选项后将允许使用 CMD+OPT+P+R 快捷键重置 NVRAM，同时 NVRAM Reset 条目也会出现在开机引导菜单中。 2. AllowSetDefaultType: plist booleanFailsafe: falseDescription: 允许使用 CTRL+Enter 和 CTRL+[数字] 设置默认启动项。 3. AuthRestartType: plist booleanFailsafe: falseDescription: 启用与 VirtualSMC 兼容的 authenticated restart. authenticated restart 可以在重启 FileVault2 分区时不用再次输入密码。你可以使用下述指令执行一次 authenticated restart：sudo fdesetup authrestart。macOS 在安装系统更新使用的也是 authenticated restart。 VirtualSMC 通过将磁盘加密密钥拆分保存在 NVRAM 和 RTC 中来执行 authenticated restart。虽然 OpenCore 在启动系统后立刻删除密钥，但是这仍然可能被视为安全隐患。 4. ExposeSensitiveDataType: plist integerFailsafe: 0x6Description: Sensitive data exposure bitmask (sum) to operating system. 0x01 — Expose printable booter path as an UEFI variable. 0x02 — Expose OpenCore version as an UEFI variable. 0x04 — Expose OpenCore version in boot picker menu title. 0x08 — Expose OEM information as a set of UEFI variables. Exposed booter path points to OpenCore.efi or its booter depending on the load order. To obtain booter path use the following command in macOS: To use booter path for mounting booter volume use the following command in macOS: To obtain OpenCore version use the following command in macOS: To obtain OEM information use the following commands in macOS: 5. HaltLevelType: plist integer, 64 bitFailsafe: 0x80000000 (DEBUG_ERROR)Description: EDK II debug level bitmask (sum) causing CPU to halt (stop execution) after obtaining a message of HaltLevel. Possible values match DisplayLevel values. 6. VaultType: plist stringFailsafe: SecureDescription: Enables vaulting mechanism in OpenCore. Valid values: Optional — require nothing, no vault is enforced, insecure. Basic — require vault.plist file present in OC directory. This provides basic filesystem integrity verification and may protect from unintentional filesystem corruption. Secure — require vault.sig signature file for vault.plist in OC directory. This includes Basic integrity checking but also attempts to build a trusted bootchain. vault.plist file should contain SHA-256 hashes for all files used by OpenCore. Presence of this file is highly recommended to ensure that unintentional file modifications (including filesystem corruption) do not happen unnoticed. To create this file automatically use create_vault.sh script. Regardless of the underlying filesystem, path name and case must match between config.plist and vault.plist. vault.sig file should contain a raw 256 byte RSA-2048 signature from SHA-256 hash of vault.plist. The signature is verified against the public key embedded into OpenCore.efi. To embed the public key you should do either of the following: Provide public key during the OpenCore.efi compilation in OpenCoreVault.c file. Binary patch OpenCore.efi replacing zeroes with the public key between =BEGIN OC VAULT= and ==END OC VAULT== ASCII markers. RSA public key 520 byte format description can be found in Chromium OS documentation. To convert public key from X.509 certificate or from PEM file use RsaTool. The complete set of commands to: Create vault.plist. Create a new RSA key (always do this to avoid loading old configuration). Embed RSA key into OpenCore.efi. Create vault.sig. Can look as follows: Note 1: While it may appear obvious, but you have to use an externalmethod to verify OpenCore.efi and BOOTx64.efi for secure boot path. For this you are recommended to at least enable UEFI SecureBoot with a custom certificate, and sign OpenCore.efi and BOOTx64.efi with your custom key. More details on customising secure boot on modern firmwares can be found in Taming UEFI SecureBoot paper (in Russian). Note 2: vault.plist and vault.sig are used regardless of this option when vault.plist is present or public key is embedded into OpenCore.efi. Setting this option will only ensure configuration sanity, and abort the boot process otherwise. 7. ScanPolicyType: plist integer, 32 bitFailsafe: 0xF0103Description: Define operating system detection policy. This value allows to prevent scanning (and booting) from untrusted source based on a bitmask (sum) of select flags. As it is not possible to reliably detect every file system or device type, this feature cannot be fully relied upon in open environments, and the additional measures are to be applied. Third party drivers may introduce additional security (and performance) measures following the provided scan policy. Scan policy is exposed in scan-policy variable of 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102 GUID for UEFI Boot Services only. 0x00000001 (bit 0) — OC_SCAN_FILE_SYSTEM_LOCK, restricts scanning to only known file systems defined as a part of this policy. File system drivers may not be aware of this policy, and to avoid mounting of undesired file systems it is best not to load its driver. This bit does not affect dmg mounting, which may have any file system. Known file systems are prefixed with OC_SCAN_ALLOW_FS_. 0x00000002 (bit 1) — OC_SCAN_DEVICE_LOCK, restricts scanning to only known device types defined as a part of this policy. This is not always possible to detect protocol tunneling, so be aware that on some systems it may be possible for e.g. USB HDDs to be recognised as SATA. Cases like this must be reported. Known device types are prefixed with OC_SCAN_ALLOW_DEVICE_. 0x00000100 (bit 8) — OC_SCAN_ALLOW_FS_APFS, allows scanning of APFS file system. 0x00000200 (bit 9) — OC_SCAN_ALLOW_FS_HFS, allows scanning of HFS file system. 0x00000400 (bit 10) — OC_SCAN_ALLOW_FS_ESP, allows scanning of EFI System Partition file system. 0x00000800 (bit 11) — OC_SCAN_ALLOW_FS_NTFS, allows scanning of NTFS (Msft Basic Data) file system. 0x00001000 (bit 12) — OC_SCAN_ALLOW_FS_EXT, allows scanning of EXT (Linux Root) file system. 0x00010000 (bit 16) — OC_SCAN_ALLOW_DEVICE_SATA, allow scanning SATA devices. 0x00020000 (bit 17) — OC_SCAN_ALLOW_DEVICE_SASEX, allow scanning SAS and Mac NVMe devices. 0x00040000 (bit 18) — OC_SCAN_ALLOW_DEVICE_SCSI, allow scanning SCSI devices. 0x00080000 (bit 19) — OC_SCAN_ALLOW_DEVICE_NVME, allow scanning NVMe devices. 0x00100000 (bit 20) — OC_SCAN_ALLOW_DEVICE_ATAPI, allow scanning CD/DVD devices. 0x00200000 (bit 21) — OC_SCAN_ALLOW_DEVICE_USB, allow scanning USB devices. 0x00400000 (bit 22) — OC_SCAN_ALLOW_DEVICE_FIREWIRE, allow scanning FireWire devices. 0x00800000 (bit 23) — OC_SCAN_ALLOW_DEVICE_SDCARD, allow scanning card reader devices. 注：Given the above description, 0xF0103 value is expected to allow scanning of SATA, SAS, SCSI, and NVMe devices with APFS file system, and prevent scanning of any devices with HFS or FAT32 file systems in addition to not scanning APFS file systems on USB, CD, and FireWire drives. The combination reads as: OC_SCAN_FILE_SYSTEM_LOCK OC_SCAN_DEVICE_LOCK OC_SCAN_ALLOW_FS_APFS OC_SCAN_ALLOW_DEVICE_SATA OC_SCAN_ALLOW_DEVICE_SASEX OC_SCAN_ALLOW_DEVICE_SCSI OC_SCAN_ALLOW_DEVICE_NVME 8.6 Entry PropertiesArgumentsType: plist stringFailsafe: Empty stringDescription: 对该引导条目使用的引导参数。 AuxiliaryType: plist booleanFailsafe: falseDescription: 当 HideAuxiliary 被启用时，这一值为 true 的引导条目将不会显示在开机引导菜单中。 CommentType: plist stringFailsafe: Empty stringDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 EnabledType: plist booleanFailsafe: falseDescription: 除非设置为 true，否则该引导条目不会显示在开机引导菜单中。 NameType: plist stringFailsafe: Empty stringDescription: 引导条目在开机引导菜单中显示的名字。 PathType: plist stringFailsafe: Empty stringDescription: 引导入口。 Entries specify external boot options, and therefore take device paths in Path key. These values are not checked, thus be extremely careful. Example: PciRoot(0x0)/Pci(0x1,0x1)/.../\\EFI\\COOL.EFI Tools specify internal boot options, which are part of bootloader vault, and therefore take file paths relative to OC/Tools directory. Example: Shell.efi. "},{"title":"9. NVRAM","url":"/9-nvram.html","content":"9.1 IntroductionHas plist dict type and allows to set volatile UEFI variables commonly referred as NVRAM variables. Refer to man nvram for more details. macOS extensively uses NVRAM variables for OS — Bootloader — Firmware intercommunication, and thus supplying several NVRAM is required for proper macOS functioning. Each NVRAM variable consists of its name, value, attributes (refer to UEFI specification), and its GUID, representing which `section’ NVRAM variable belongs to. macOS uses several GUIDs, including but not limited to: 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14 (APPLE_VENDOR_VARIABLE_GUID) 7C436110-AB2A-4BBB-A880-FE41995C9F82 (APPLE_BOOT_VARIABLE_GUID) 8BE4DF61-93CA-11D2-AA0D-00E098032B8C (EFI_GLOBAL_VARIABLE_GUID) 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102 (OC_VENDOR_VARIABLE_GUID) 注：Some of the variables may be added by PlatformNVRAM or Generic subsections of PlatformInfo section. Please ensure that variables of this section never collide with them, as behaviour is undefined otherwise. For proper macOS functioning it is often required to use OC_FIRMWARE_RUNTIME protocol implementation currently offered as a part of FwRuntimeServices driver. While it brings any benefits, there are certain limitations which arise depending on the use. Not all tools may be aware of protected namespaces. When RequestBootVarRouting is used Boot-prefixed variable access is restricted and protected in a separate namespace. To access the original variables tools have to be aware of OC_FIRMWARE_RUNTIME logic. Assigned NVRAM variables are not always allowed to exceed 512 bytes. This is true for Boot-prefixed variables when RequestBootVarFallback is used, and for overwriting volatile variables with non-volatile on UEFI 2.8 non-conformant firmwares. 9.2 Properties1. AddType: plist dictDescription: Sets NVRAM variables from a map (plist dict) of GUIDs to a map (plist dict) of variable names and their values in plist metadata format. GUIDs must be provided in canonic string format in upper or lower case (e.g. 8BE4DF61-93CA-11D2-AA0D-00E098032B8C). Created variables get EFI_VARIABLE_BOOTSERVICE_ACCESS and EFI_VARIABLE_RUNTIME_ACCESS attributes set. Variables will only be set if not present and not blocked. To overwrite a variable add it to Block section. This approach enables to provide default values till the operating system takes the lead. 注：If plist key does not conform to GUID format, behaviour is undefined. 2. BlockType: plist dictDescription: Removes NVRAM variables from a map (plist dict) of GUIDs to an array (plist array) of variable names in plist string format. 3. LegacyEnableType: plist booleanFailsafe: falseDescription: 允许从 ESP 分区的根目录中的 nvram.plist 文件读取 NVRAM 变量。 This file must have root plist dictionary type and contain two fields: Version — plist integer, file version, must be set to 1. Add — plist dictionary, equivalent to Add from config.plist. Variable loading happens prior to Block (and Add) phases. Unless LegacyOverwrite is enabled, it will not overwrite any existing variable. Variables allowed to be set must be specified in LegacySchema. Third-party scripts may be used to create nvram.plist file. An example of such script can be found in Utilities. The use of third-party scripts may require ExposeSensitiveData set to 0x3 to provide boot-path variable with OpenCore EFI partition UUID. 警告: 这一功能非常危险，因为这将不受保护的数据传递给固件中的变量服务。只有你的硬件不提供硬件 NVRAM 或与之不兼容时才使用。 4. LegacyOverwriteType: plist booleanFailsafe: falseDescription: 允许用 nvram.plist 文件中的变量覆盖现有 NVRAM 中的变量。 注：只有操作系统访问的到的变量会被覆盖。 5. LegacySchemaType: plist dictDescription: Allows setting select NVRAM variables from a map (plist dict) of GUIDs to an array (plist array) of variable names in plist string format. You can use * value to accept all variables for select GUID. 警告: Choose variables very carefully, as nvram.plist is not vaulted. For instance, do not put boot-args or csr-active-config, as this can bypass SIP. 6. WriteFlash Type: plist boolean Failsafe: false Description: Enables writing to flash memory for all added variables. 注：This value is recommended to be enabled on most firmwares, but is left configurable for firmwares that may have issues with NVRAM variable storage garbage collection or alike. To read NVRAM variable value from macOS one could use nvram by concatenating variable GUID and name separated by : symbol. For example, nvram 7C436110-AB2A-4BBB-A880-FE41995C9F82:boot-args. A continuously updated variable list can be found in a corresponding document: NVRAM Variables. 9.3 Mandatory Variables警告: These variables may be added by PlatformNVRAM or Generic subsections of PlatformInfo section. Using PlatformInfo is the recommend way of setting these variables. The following variables are mandatory for macOS functioning: 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:FirmwareFeatures32-bit FirmwareFeatures. Present on all Macs to avoid extra parsing of SMBIOS tables 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:FirmwareFeaturesMask32-bit FirmwareFeaturesMask. Present on all Macs to avoid extra parsing of SMBIOS tables. 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:MLBBoardSerialNumber. Present on newer Macs (2013+ at least) to avoid extra parsing of SMBIOS tables, especially in boot.efi. 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ROMPrimary network adapter MAC address or replacement value. Present on newer Macs (2013+ at least) to avoid accessing special memory region, especially in boot.efi. 9.4 Recommended VariablesThe following variables are recommended for faster startup or other improvements: 7C436110-AB2A-4BBB-A880-FE41995C9F82:csr-active-config32-bit System Integrity Protection bitmask. Declared in XNU source code in csr.h. 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ExtendedFirmwareFeaturesCombined FirmwareFeatures and ExtendedFirmwareFeatures. Present on newer Macs to avoid extra parsing of SMBIOS tables 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ExtendedFirmwareFeaturesMaskCombined FirmwareFeaturesMask and ExtendedFirmwareFeaturesMask. Present on newer Macs to avoid extra parsing of SMBIOS tables. 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_BIDHardware BoardProduct (e.g. Mac-35C1E88140C3E6CF). Not present on real Macs, but used to avoid extra parsing of SMBIOS tables, especially in boot.efi. 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_MLBHardware BoardSerialNumber. Override for MLB. Present on newer Macs (2013+ at least). 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_ROMHardware ROM. Override for ROM. Present on newer Macs (2013+ at least). 7C436110-AB2A-4BBB-A880-FE41995C9F82:prev-lang:kbdASCII string defining default keyboard layout. Format is lang-COUNTRY:keyboard, e.g. ru-RU:252 for Russian locale and ABC keyboard. Also accepts short forms: ru:252 or ru:0 (U.S. keyboard, compatible with 10.9). Full decoded keyboard list from AppleKeyboardLayouts-L.dat can be found here. Using non-latin keyboard on 10.14 will not enable ABC keyboard, unlike previous and subsequent macOS versions, and is thus not recommended in case you need 10.14. 7C436110-AB2A-4BBB-A880-FE41995C9F82:security-modeASCII string defining FireWire security mode. Legacy, can be found in IOFireWireFamily source code in IOFireWireController.cpp. It is recommended not to set this variable, which may speedup system startup. Setting to full is equivalent to not setting the variable and none disables FireWire security. 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:UIScaleOne-byte data defining boot.efi user interface scaling. Should be 01 for normal screens and 02 for HiDPI screens. 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:DefaultBackgroundColor Four-byte RGBA data defining boot.efi user interface background colour. Standard colours include BF BF BF 00 (Light Gray) and 00 00 00 00} (Syrah Black). Other colours may be set at user’s preference. 9.5 Other VariablesThe following variables may be useful for certain configurations or troubleshooting: 7C436110-AB2A-4BBB-A880-FE41995C9F82:boot-argsKernel arguments, used to pass configuration to Apple kernel and drivers. There are many arguments, which may be found by looking for the use of PE_parse_boot_argn function in the kernel or driver code. Some of the known boot arguments include: acpi_layer=0xFFFFFFFF acpi_level=0xFFFF5F (implies ACPI_ALL_COMPONENTS) batman=VALUE (AppleSmartBatteryManager debug mask) batman-nosmc=1 (disable AppleSmartBatteryManager SMC interface) cpus=VALUE (maximum number of CPUs used) debug=VALUE (debug mask) io=VALUE (IOKit debug mask) keepsyms=1 (show panic log debug symbols) kextlog=VALUE (kernel extension loading debug mask) nv_disable=1 (disables NVIDIA GPU acceleration) nvda_drv=1 (legacy way to enable NVIDIA web driver, removed in 10.12) npci=0x2000 (legacy, disables kIOPCIConfiguratorPFM64) lapic_dont_panic=1 slide=VALUE (manually set KASLR slide) smcdebug=VALUE (AppleSMC debug mask) -amd_no_dgpu_accel (alternative to WhateverGreen‘s -radvesa for new GPUs) -nehalem_error_disable -no_compat_check (disable model checking) -s (single mode) -v (verbose mode) -x (safe mode) There are multiple external places summarising macOS argument lists: example 1, example 2. 7C436110-AB2A-4BBB-A880-FE41995C9F82:bootercfgBooter arguments, similar to boot-args but for boot.efi. Accepts a set of arguments, which are hexadecimal 64-bit values with or without 0x prefix primarily for logging control: log=VALUE 1 — AppleLoggingConOutOrErrSet/AppleLoggingConOutOrErrPrint (classical ConOut/StdErr) 2 — AppleLoggingStdErrSet/AppleLoggingStdErrPrint (StdErr or serial?) 4 — AppleLoggingFileSet/AppleLoggingFilePrint (BOOTER.LOG/BOOTER.OLD file on EFI partition) debug=VALUE 1 — enables print something to BOOTER.LOG (stripped code implies there may be a crash) 2 — enables perf logging to /efi/debug-log in the device three 4 — enables timestamp printing for styled printf calls level=VALUE — Verbosity level of DEBUG output. Everything but 0x80000000 is stripped from the binary, and this is the default value. kc-read-size=VALUE — Chunk size used for buffered I/O from network or disk for prelinkedkernel reading and related. Set to 1MB (0x100000) by default, can be tuned for faster booting. 注：To quickly see verbose output from boot.efi set this to log=1 (currently this is broken in 10.15). 7C436110-AB2A-4BBB-A880-FE41995C9F82:bootercfg-onceBooter arguments override removed after first launch. Otherwise equivalent to bootercfg. 7C436110-AB2A-4BBB-A880-FE41995C9F82:fmm-computer-nameCurrent saved host name. ASCII string. 7C436110-AB2A-4BBB-A880-FE41995C9F82:nvda_drvNVIDIA Web Driver control variable. Takes ASCII digit 1 or 0 to enable or disable installed driver. "},{"title":"OpenCore 简体中文参考手册","url":"/","content":" OpenCore 参考手册（v0.5.6） 阅读须知你现在访问的是由 非官方 维护的 OpenCore 参考手册的简体中文翻译（以下简称本网站）。 本网站以及网站的维护人员和 OpenCore 的开发团队 acidanthera 以及 OpenCore 的文档版权所有者 vit9696 没有任何关系。本网站对 OpenCore 的 Logo（商标）的使用已经过 acidanthera 的授权。 由于 OpenCore 仍处于积极的维护之中，OpenCore 参考手册 仍然在高频率更新，本网站提供的内容 仅可供参考。本网站的内容和 OpenCore 官方的参考手册的任何出入，请以 OpenCore 官方的参考手册为准。 本网站提供的翻译基于如下描述的 OpenCore 官方文档： OpenCore 文档释出日期：2020.02.18 OpenCore 文档版本：70e920d95f0b13dfe899b4b7c8ba46506a0aaef8 本网站提供的翻译适用于如下描述的 OpenCore 版本： OpenCore 版本：0.5.6 本网站以及 acidanthera 不会对因本网站引起的任何损失负责，包括但不限于 Kernel Panic、设备无法开机或正常使用、硬盘损坏或数据丢失、原子弹爆炸、第三次世界大战、SCP 基金会 无法阻止的全球 CK 级现实重构等。 有用的链接 OpenCore 官方文档 OpenCore 官方文档迭代 OpenCore Vanilla Guide — 从零开始的 OpenCore 台式机安装指南。本网站由考虑提供对该指南的简体中文翻译 精解 OpenCore | 黑果小兵 — 本网站的部分翻译参考的就是黑果小兵的这篇文章 使用 OpenCore 引导黑苹果 | Xjn’s Blog — 提供了很多排错和完善的指南 维护者OpenCore 简体中文参考手册 © Sukka. 由 Sukka 和 众多的贡献者 一起维护。"},{"title":"附录 1. OpenCore 兼容 Kext 列表","url":"/kextlist.html","content":"有线网卡 AppleRTL8169Ethernet — Realtek RTL8169 官方驱动，通过电子邮件发送下载链接 AtherosE2200Ethernet.kext — 高通 Atheros Killer E2200 系列驱动 AtherosL1cEthernet.kext — 高通 Atheros AR813x/815x 驱动 IntelMausi.kext — 由 Acidanthera 维护的英特尔有线网卡驱动 IntelMausiEthernet.kext — 由原作者（Mieze）英特尔有线网卡 NullEthernetInjector.kext — RehabMan 提供的仿冒内建网卡 RealtekR1000SL.kext — Realtek 8111B/C/D/E/EP/F/G/GU/8411B 系列驱动 RealtekRTL8100.kext — Realtek RTL810X 系列驱动 RealtekRTL8111.kext — Realtek RTL8111/8168 系列驱动 Wi-Fi 和蓝牙 AirPortAtheros40.kext — 高通 Atheros AR92xx/AR93xx 驱动，仅适用于 macOS 10.13.6 和 macOS 10.14+ AirportBrcmFixup.kext — 非苹果官方博通网卡修复 ATH9KFixup.kext — 高通 Atheros AR9xxx 无线网卡修复 BrcmPatchRAM.kext — 博通网卡蓝牙固件 BT4LEContinuityFixup.kext — IOBluetoothFamily 修补 MT7610 — 联发科 MT7610 官方驱动 RT5370 — 联发科 RT5370 官方驱动 RTL8192CU — Realtek RTL8192CU 驱动 译者注：上述链接为 Google Drive 分享，直链下载地址： macOS 10.6 macOS 10.9 键盘、鼠标和触摸设备 ApplePS2SmartTouchPad.kext — 触摸板和键盘 GK701HIDDevice.kext — 华硕 Fn 键、键盘背光灯和环境光传感器 驱动 NoTouchID.kext — 禁用 Touch ID 检测 SerialMouse.kext — 使用 Microsoft 串行鼠标协议的串行鼠标驱动 VoodooI2C.kext — I2C 触摸板/屏 驱动 VoodooPS2Controller.kext — PS2 键盘/触摸板 驱动 VoodooInput.kext — 为 PS2 键盘/触摸板 提供模拟 Magic TrackPad 2 触控模拟 Video and audio AppleALC.kext — 定制万能声卡驱动 EMUUSBAudio.kext — 适用于 Creative Labs EMU USB 的驱动程序 kXAudioDriver.kext — 适用于 kX 音频设备的驱动 Nvidia CUDA drivers — NVIDIA CUDA 官方驱动 Nvidia Web-drivers — NVIDIA 显卡官方驱动 SNBGraphicsMojaveInstaller — 二代酷睿核显驱动，仅适用于 macOS 10.13.6 和 macOS 10.14+ VoodooHDA.kext — 万能声卡驱动 WhateverGreen.kext — 显卡补丁驱动 Polaris22Fixup.kext — Polaris22/VegaM 显卡修复 CPU 和 SMC AppleMCEReporterDisabler.kext AsusSMC.kext — 为 ASUS 笔记本电脑上的 ALS、键盘背光、Fn 键提供支持 VirtualSMC 插件 CPUFriend.kext - CPU 变频管理 FakeSMC.kext 以及配套传感器驱动 — Clover 官方的 FakeSMC HWPEnabler.kext — 启用 HWP 驱动 OpcodeEmulator.kext — Opcode 模拟驱动 TSCAdjustReset.kext — TSC 频率同步驱动 VirtualSMC.kext 以及配套传感器驱动 VoodooTSCSync.kext — 由 Rehabman 提供的 TSC 频率同步驱动 USB and other ports IOElectrify.kext — 在雷电 3 设备上启用常开电源 Legacy_InternalHub-EHCx.kext Legacy_USB3.kext NVMeFix.kext — 由 acidanthera 提供的改善第三方 SSD 兼容性的驱动程序 USBWakeFixup.kext — 修复 Skylake 平台 USB 唤醒黑屏 SASMegaRAID.kext — LSI MegaRAID SAS 系列 RAID 控制器驱动 Sinetek-rtsx.kext — Realtek RTSX SDHC 读卡器驱动 VoodooSDHC.kext — SDHC 读卡器驱动 Other kexts AppleIntelInfo.kext — CPU / 核显 变频测试 DebugEnhancer.kext — macOS 内核调试输出驱动 HibernationFixup.kext — 修复因 RTC 变量和 NVRAM 造成的睡眠问题 Lilu.kext — SDK &amp; Library LiluFriend.kext — 用于确保 Lilu 在 L/E 下正常加载 RTCMemoryFixup.kext — 修复 BIOS CMOS (RTC) 内存和 AppleRTC 之间的冲突问题 NightShiftUnlocker.kext — 解锁 NightShift WebCamera.kext — 某些旧设备的摄像头驱动 "},{"title":"贡献指南","url":"/about/contributing.html","content":"目录结构文档所有文件位于 source 下。 about 目录：关于项目自身的文档，如你现在看到的「贡献指南」的 md 源文件就位于这个目录下 guide 目录：如果未来项目开始收录 OpenCore 指南类的文章，就将相关的 md 文件放在这个目录下 img 目录：存放文档中使用的图片 logo 目录：存放 OpenCore 的 Logo 和网站的 favicon CNAME 文件：GitHub Pages 绑定自定义域名 index.md 文件：网站首页的 md 源文件 其余 .md 文件：经过整理的 OpenCore 参考手册的 md 源文件（需要翻译的就是这些文件） Markdown 文件的 Front-Matter 的字段说明 当你完成了对一个文件的整理、翻译后，别忘了修改 author_info 和 last_updated 两个字段！ Commit Message 规范 type init: Initialization 初始化项目、模块、组件 docs: Documentation 文档（包括 README 的更新） revert: Revert 代码回退，用于撤回某个改动 feat: New feature 新功能 fix: Fix bug 修补 bug style: Format 格式（不影响代码运行的变动） refactor: Refactor 重构（即不是新增功能，也不是修改 bug 的代码变动） test: Test 测试相关 workflow: WorkFlow 工作流相关 chore: 构建过程或辅助工具的变动 merge: 合并 Pull Request ci: 持续集成和构建相关 允许多个 type 的使用，如修复文档中的 Typo 可以用 docs/type 作为 type。 scope scope 用于说明 commit 影响的范围（一般取修改的文件的名称），紧接 type 置于 () 之内。 scope 非必须，当改动代码范围较大或者范围不明确时可忽略。 当使用 Merge Pull Request 合并不同分支时，scope 为 PR 在 GitHub 上的编号；当使用 revert 回退代码时，scope 为对应 commit 的 Title，也可以是简短的介绍。 subject subject 是 commit 目的的简短描述，不超过 50 个字符。 以动词开头 使用第一人称现在时比如 change，尽可能避免使用 changed 或 changes 首字母小写，并且 尽可能 subject 全部小写 结尾不加句号 . 当 type 是 merge 时，subject 应为 from {base branch name} into {target branch name} body Body 部分是 可选的 对本次 commit 的详细描述，可以分成多行。下面是一个范例。 和 title.subject 不同，Body 的要求如下： Body 是可选、非必须的 使用第一人称现在时比如 change，尽可能避免使用 changed 或 changes 应该说明代码变动的动机，以及与以前行为的对比。 如果使用 Squash 合并分支时，Body 为以无序列表排列的对应多条 commit 记录。 其他参考资料 Hexo 文档 hexo-theme-doku 文档 "}]